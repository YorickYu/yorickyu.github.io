<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《Effective-java》 归纳整理</title>
      <link href="2021/07/11/effective-java/"/>
      <url>2021/07/11/effective-java/</url>
      
        <content type="html"><![CDATA[<h4 id="使用枚举类型强化单例模式"><a href="#使用枚举类型强化单例模式" class="headerlink" title="使用枚举类型强化单例模式"></a>使用枚举类型强化单例模式</h4><p>单元素的枚举类型已经成为实现Singleton的最佳方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单例的一种写法</span></span><br><span class="line"><span class="comment">* 解决线程同步问题，可以防止反序列化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">SingletonEnum.INSTANCE.m();</span><br></pre></td></tr></table></figure><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>多个构造器参数可变时考虑建造者模式</p><p>Lombok中@Builder注解支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer code = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    User(String username, String password) &#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username; <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User.<span class="function">UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User.UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        UserBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">username</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> User.<span class="function">UserBuilder <span class="title">password</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="keyword">this</span>.username, <span class="keyword">this</span>.password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User.UserBuilder(username=&quot;</span> + <span class="keyword">this</span>.username + <span class="string">&quot;, password=&quot;</span> + <span class="keyword">this</span>.password + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h4><p>1 String类型合理利用元空间，不要创建String实例 （JVM）</p><p>2 不可变类尽量使用静态工厂方法而非构造器。例如 Boolean.valueOf() 优于 new Boolean()</p><p>3 评估是否有必要使用延迟初始化，延迟初始化常见在创建单例时使用，有静态内部类和DCL两种方式 （<a href="https://yloopdaed.icu/2021/04/01/cavil/?highlight=dcl">DCL单例</a>）</p><p>4 避免在循环中误用自动拆箱装箱</p><p>5 如果是非常重量级的对象，可以考虑维护自己的对象池来避免对象频繁创建 （数据库连接池）</p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>1 正确编写代码，可以查阅一些网上常见的内存泄漏案例<br>例如：HashMap中使用自定义类型时要实现hashCode和equals方法，这是个老生常谈的问题了</p><p>2 使用缓存时要合理定义缓存的粒度，最重要是不论使用什么缓存架构，都要设置过期时间和过期策略（<a href="https://yloopdaed.icu/2021/04/10/cache-structure/">缓存架构概念篇</a>）</p><p>3 对于监听器或流的使用，主要利用try finally进行显示关闭</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据清洗 SOP</title>
      <link href="2021/07/08/cover-data/"/>
      <url>2021/07/08/cover-data/</url>
      
        <content type="html"><![CDATA[<h4 id="相关数据所在-集群、库、表-信息整理"><a href="#相关数据所在-集群、库、表-信息整理" class="headerlink" title="相关数据所在 集群、库、表 信息整理"></a>相关数据所在 集群、库、表 信息整理</h4><p>1 数据量统计<br>2 游标确认表中是否存在脏数据，是否需要清理<br>3 如果涉及到多个表，梳理下他们的关系    </p><h4 id="影响面评估"><a href="#影响面评估" class="headerlink" title="影响面评估"></a>影响面评估</h4><p>1 写入入口统计<br>    有多少地方会增删改这些数据<br>2 读取接口统计<br>    有多少地方会查这些数据，一般是C端接口<br>3 后台任务、脚本、消息队列统计<br>    有多少后台任务在维护这些数据<br>    例如你修改了A表某字段的同时需要给消息队列里生产一条消息，那么你清洗这个字段的时候也需要同步给队列发消息。不然会导致后续的数据混乱<br>4 业务链路梳理<br>    在统计上面这些内容的同时，也是你熟悉业务的过程。你可以将整个业务的链路进行归纳整理，反向推到出调用方在什么场景中使用，方便后续维护</p><h4 id="备份及回滚"><a href="#备份及回滚" class="headerlink" title="备份及回滚"></a>备份及回滚</h4><p>1 全量数据备份<br>    从某一个时间戳进行全量数据备份<br>2 增量数据处理<br>    全量备份后，在清洗过程中新增或更新的数据也需要有一个处理方案。比如从binlog追回增量数据或者动态修改数据源等<br>3 回滚方案<br>    特别注意增量数据的回滚</p><h4 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h4><p>1 清理过程对业务稳定性的影响<br>2 回滚过程对业务稳定性的影响</p><h4 id="清洗方案评估"><a href="#清洗方案评估" class="headerlink" title="清洗方案评估"></a>清洗方案评估</h4><p>代码编写，自测及review</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>1 自建测试数据进行清洗<br>2 从生产环境导出数据到测试环境进行清理<br>    这是最关键的一步，可以真实检验清洗的结果，做好记录。<br>    比如清洗真实数据时遇到什么问题，哪里出了问题，如何修改，程序执行的时间等</p><h4 id="线上执行"><a href="#线上执行" class="headerlink" title="线上执行"></a>线上执行</h4><p>经过上面的测试，应该在真实执行前对清洗的结果有一个预测。执行结束后切记追评增量数据。</p><h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>1 C端接口做功能回归<br>2 数据抽样检测</p>]]></content>
      
      
      
        <tags>
            
            <tag> SOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据迁移 SOP（不停机、分片）</title>
      <link href="2021/07/06/migrate-data/"/>
      <url>2021/07/06/migrate-data/</url>
      
        <content type="html"><![CDATA[<h4 id="双写开启"><a href="#双写开启" class="headerlink" title="双写开启"></a>双写开启</h4><p>insert： 新老库同时写入<br>update：<br>    1 新库已存在这条数据 -&gt; 更新<br>    2 新库不存在这条数据 -&gt; 写入并更新</p><blockquote><p>双写提前开启也是为了保证迁移失败时数据可回滚</p></blockquote><h4 id="全量数据迁移-daemon"><a href="#全量数据迁移-daemon" class="headerlink" title="全量数据迁移 daemon"></a>全量数据迁移 daemon</h4><p>记录任务开始和结束的 timestamp(start ~ end)</p><p>读老库，写新库<br>    1 新库已存在这条数据 -&gt; 判断 gmt_modified &gt; start timestamp -&gt; 更新<br>    2 新库不存在这条数据 -&gt; 写入</p><h4 id="增量数据迁移-xxljob"><a href="#增量数据迁移-xxljob" class="headerlink" title="增量数据迁移 xxljob"></a>增量数据迁移 xxljob</h4><p>循环校验新老库的数据，如果存在不一致，将数据同步:</p><pre><code class="java">UPDATE 新表名称 SET 列名称 = 新值 WHERE gmt_modified &lt; end timestamp</code></pre><p>这个定时任务可以持续几天，对数据校验及修正</p><h4 id="切流"><a href="#切流" class="headerlink" title="切流"></a>切流</h4><p>将读取数据流量切换到新库</p><h4 id="双写关闭，完整迁移"><a href="#双写关闭，完整迁移" class="headerlink" title="双写关闭，完整迁移"></a>双写关闭，完整迁移</h4><h4 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h4><p>1 binlog读取 — canal</p><p>增量数据迁移常见的解决方式为 MySQL binlog读取。可以借助运维工具 <code>canal</code></p><p>2 分片后的主键</p><p>通常设计一个大表时，可以预留分表可用主键，因为需要保证单次查询的原子性，但是分表后又很难兼顾复杂情况的查询。</p><p>所以可以在设计表时预先根据表中高频查询的字段建立索引规则。然后将这个规则融合在主键中。</p><blockquote><p>如果没有预先埋好分表策略的主键，可以临时做一个mapping表做检索，也可以解决分表后的复杂查询问题<br>ps: 通常这种索引表可以支撑亿级数据</p></blockquote><p>3 服务拆分</p><p>将迁移服务独立拆分，避免以后重复造轮子。（迁移方案可以使用策略模式，兼容不同的情况）</p><p>4 使用游标</p><p>使用游标的方式从旧库分批select数据，经过rehash后批量插入（batch insert）到新库，此处需要配置jdbc连接串参数rewriteBatchedStatements=true才能使批处理操作生效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SOP </tag>
            
            <tag> migrate </tag>
            
            <tag> sharding </tag>
            
            <tag> 一致性hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见可分页缓存方案</title>
      <link href="2021/06/28/pageable-cache/"/>
      <url>2021/06/28/pageable-cache/</url>
      
        <content type="html"><![CDATA[<p>一、缓存key中使用page，size做标记，直接按分页结果缓存<br>适用场景：<br>1 列表长度无法提前预知<br>2 数据排列顺序不经常变更</p><p><strong>定时任务，不断更新前几页的缓存（热）数据。可以搭配JetCache + SQL直接实现多级缓存</strong></p><p>二、缓存整个列表的id（和关键信息），然后根据id获取对象<br>适用场景：<br>1 列表长度有限，且分页情况多变<br>2 对象数据或排序权重频繁更新</p><p><strong>不同的缓存方案需要在性能和数据一致性之间寻找一个平衡点</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>探测 - 单数组解决hash冲突问题</title>
      <link href="2021/06/28/hash-detection/"/>
      <url>2021/06/28/hash-detection/</url>
      
        <content type="html"><![CDATA[<p><strong>解决Hash冲突</strong></p><p>Java中常见的HashMap使用 <strong><em>数组+链表/红黑树</em></strong> 的方式解决Hash冲突问题。</p><p><strong>为什么依赖数组？</strong></p><p><strong><em>无序数组</em></strong><br>操作                           时间复杂度<br>查询                           O(1)<br>插入(空间充足)                    O(1)<br>插入(空间不足)                    O(n)+O(1)=O(n)<br>删除(末尾元素)                    O(1)<br>删除(非末尾元素且元素个数&gt;1)     O(1)+O(n)=O(n)</p><p>可见数组在查询、插入和删除时表现出的性能都非常优秀。存储数据时只需要将要存储的值的Hash值根据数组长度算出下标插入即可。</p><p>但是数组的长度不可能无限扩容，在有限的数组中存储数据必定要解决Hash冲突的问题。所以才引入了 <strong><em>数组+链表/红黑树</em></strong> 的数据结构。</p><p><strong>单数组解决Hash冲突</strong></p><p><strong><em>探测</em></strong><br>1 相邻空位 - 线性探测<br>2 间隔1、4、9、16的空位 - 平方探测</p><blockquote><p>Java应用案例： ThreadLocal<br><a href="https://yloopdaed.icu/2020/12/10/threadlocal">尝试阅读ThreadLocal源码-基础部分</a><br><a href="https://yloopdaed.icu/2020/12/13/threadlocal2">尝试阅读ThreadLocal源码-Hash冲突、启动/探测式清理、扩容</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HotKey 缓存数据结构设计</title>
      <link href="2021/06/27/hotKey/"/>
      <url>2021/06/27/hotKey/</url>
      
        <content type="html"><![CDATA[<h3 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h3><p>概念：某时刻，缓存系统面临巨大的访问量，且访问倾斜在极少的数据上</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1 集群级别：一致性哈希、缓存<br>2 单机级别：多级缓存<br>3 缓存KV存储引擎：数组+有序环（HotRing）</p><h3 id="HotRing"><a href="#HotRing" class="headerlink" title="HotRing"></a>HotRing</h3><p>基于RCU无锁引擎的热点感知型KV系统</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/%20hotring-1.png"></p><h4 id="挑战一、热点是动态变化的。如何检测？如何转移？"><a href="#挑战一、热点是动态变化的。如何检测？如何转移？" class="headerlink" title="挑战一、热点是动态变化的。如何检测？如何转移？"></a>挑战一、热点是动态变化的。如何检测？如何转移？</h4><h5 id="随机策略（读时更新）"><a href="#随机策略（读时更新）" class="headerlink" title="随机策略（读时更新）"></a>随机策略（读时更新）</h5><p>下一次访问的节点如果是hotKey，那么不移动；如果不是，随机在环中挑选一个节点<br>这种方案<strong>适合热点key集中的场景</strong>。随机采样速度快，无需计算</p><h5 id="统计策略（读时更新）"><a href="#统计策略（读时更新）" class="headerlink" title="统计策略（读时更新）"></a>统计策略（读时更新）</h5><p>统计整个有序环的访问次数和环中单个节点的访问次数，并通过公式计算下次移动节点的收益值<br>这种方案<strong>适合热点key多个的场景</strong>。会有一定的分析开销</p><h5 id="热点继承策略（写时更新）"><a href="#热点继承策略（写时更新）" class="headerlink" title="热点继承策略（写时更新）"></a>热点继承策略（写时更新）</h5><p>如果有序环中有节点被更新，那么head指向这个被更新的节点<br>如果有序环中有节点被删除，那么head指向这个被删除节点的下一个节点</p><h4 id="挑战二、读取要求低延迟。无锁，数据安全"><a href="#挑战二、读取要求低延迟。无锁，数据安全" class="headerlink" title="挑战二、读取要求低延迟。无锁，数据安全"></a>挑战二、读取要求低延迟。无锁，数据安全</h4><h5 id="CAS-gt-Compare-And-Swap"><a href="#CAS-gt-Compare-And-Swap" class="headerlink" title="CAS -&gt; Compare-And-Swap"></a>CAS -&gt; Compare-And-Swap</h5><p>操作系统级别。比较并交换</p><h5 id="RCU-gt-Read-Copy-Update"><a href="#RCU-gt-Read-Copy-Update" class="headerlink" title="RCU -&gt; Read-Copy-Update"></a>RCU -&gt; Read-Copy-Update</h5><p>读不做限制，写时复制COW -&gt; Copy-On-Write</p><h5 id="occupy"><a href="#occupy" class="headerlink" title="occupy"></a>occupy</h5><p>当一个节点被更新或者被删除时，设置为1，操作完成重置为0</p><p>无锁并发访问：<br>1 并发增，可能造成新增节点数据丢失。<br>2 并发改，可能造成更新节点数据错误。<br>3 并发增、改，可能造成新增节点数据丢失。<br>4 并发删、改，可能造成更新节点的数据丢失。<br>解决：CAS</p><p>头指针移动：</p><p>并发情况下通过 CAS + occupy 来保证移动头指针时的安全</p><h4 id="挑战三、无锁rehash（扩容）"><a href="#挑战三、无锁rehash（扩容）" class="headerlink" title="挑战三、无锁rehash（扩容）"></a>挑战三、无锁rehash（扩容）</h4><p><strong>扩容条件</strong>是查询所需的平均内存访问次数 access overhead &gt; 2 时触发rehash</p><p>三个过程：初始化、分裂、删除</p><p>整个过程会在后台创建一个rehash线程处理</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/hotring-2.png"><br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/hotring-3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> HotKey </tag>
            
            <tag> HotRing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A/B/nTest搭建 SOP</title>
      <link href="2021/06/26/abtest/"/>
      <url>2021/06/26/abtest/</url>
      
        <content type="html"><![CDATA[<h3 id="AB测试"><a href="#AB测试" class="headerlink" title="AB测试"></a>AB测试</h3><p>AB测试是为Web或App界面或流程制作两个（A/B）或多个（A/B/n）版本，在同一时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。</p><h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><h4 id="分流方案"><a href="#分流方案" class="headerlink" title="分流方案"></a>分流方案</h4><p>稳定hash算法：murmur、crc</p><h4 id="稳定性方案"><a href="#稳定性方案" class="headerlink" title="稳定性方案"></a>稳定性方案</h4><p>多级缓存：本地、远程、redis</p><h4 id="监控方案"><a href="#监控方案" class="headerlink" title="监控方案"></a>监控方案</h4><p>埋点、日志、合理配置分流算法（每个方案的最少流量应该不少于1000UV）</p><h4 id="容灾方案"><a href="#容灾方案" class="headerlink" title="容灾方案"></a>容灾方案</h4><p>手动降级：手动调整hash分流策略、关闭AB服务<br>自动降级：错误日志过多或系统负载异常时，自动修改hash分流策略，关闭分流。待系统回复后修改回去</p><h4 id="分流数据传递"><a href="#分流数据传递" class="headerlink" title="分流数据传递"></a>分流数据传递</h4><p>根据具体的业务改变，常见在 HTTP header中透出，也可以约定在JSON数据中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> A/B test </tag>
            
            <tag> SOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 工作模型</title>
      <link href="2021/06/04/redis-work-mode/"/>
      <url>2021/06/04/redis-work-mode/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/E179C828-407B-464B-8A86-42434342043E.png"></p><p>1 <strong>数据结构</strong>，用什么数据结构存储（哈希、列表、集合、有序集合。底层双端列表、压缩列表、跳表）<br>2 <strong>存储容量</strong>，存储上限<br>3 <strong>清除策略</strong>，到达存储上限后如何清除冷数据（LRU最近最少使用、FIFO先进先出、LFU最近最不常用、SOFT软引用、WEAK弱引用）<br>4 <strong>过期策略</strong>，定时清除、定期清除、惰性删除<br>5 <strong>线程安全</strong>，redis单线程保证线程安全、本地缓存需要通过锁机制保证线程安全，或者线程隔离<br>6 <strong>对外提供简明的API</strong>，见名知意<br>7 <strong>数据持久化方案</strong>，redis（RDB、AOF）、灾难预警和备份<br>8 <strong>穿透键阻塞机制</strong>，防止缓存穿透</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson smart match</title>
      <link href="2021/06/04/fastjson-smart-match/"/>
      <url>2021/06/04/fastjson-smart-match/</url>
      
        <content type="html"><![CDATA[<h3 id="下划线转驼峰"><a href="#下划线转驼峰" class="headerlink" title="下划线转驼峰"></a>下划线转驼峰</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">static class Demo &#123;</span><br><span class="line">private String productId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/fastjson/issues/523">反序列化时属性能否支持下划线格式对驼峰格式的自动转换 #523</a></p><h4 id="before-version-1-2-20"><a href="#before-version-1-2-20" class="headerlink" title="before version 1.2.20"></a>before version 1.2.20</h4><p>1 @JSONField</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JSONField(name = &quot;product_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String productId;</span><br></pre></td></tr></table></figure><p>2 PropertyNamingStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParserConfig.getGlobalInstance().propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;</span><br><span class="line">JSON.parseObject(str, RespOrderDTO.class);</span><br></pre></td></tr></table></figure><p>参考：<a href="https://github.com/alibaba/fastjson/wiki/PropertyNamingStrategy_cn">PropertyNamingStrategy_cn</a></p><h4 id="after-version-1-2-20"><a href="#after-version-1-2-20" class="headerlink" title="after version 1.2.20"></a>after version 1.2.20</h4><p>支持自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">&quot;&#123;\&quot;product_id\&quot;: \&quot;5ad557f3c0a1eab4458b45f1\&quot;&#125;&quot;</span>;</span><br><span class="line">JSON.parseObject(json, Demo.class);</span><br></pre></td></tr></table></figure><h3 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h3><p>JSON.java -&gt; parseObject 方法 -&gt; line 395</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseObject -&gt; T value = (T) parser.parseObject(clazz, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604145957990.png"></p><p>DefaultJSONParser.java -&gt; parseObject 方法 -&gt; line 698</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) ((JavaBeanDeserializer) deserializer).deserialze(<span class="keyword">this</span>, type, fieldName, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604150145774.png"></p><h3 id="deserialze-方法"><a href="#deserialze-方法" class="headerlink" title="deserialze 方法"></a>deserialze 方法</h3><p>JavaBeanDeserializer.java -&gt; deserialze 方法 -&gt; line 545</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] name_chars = fieldInfo.name_chars;</span><br></pre></td></tr></table></figure><p>这里默认的规则是先根据类的字段名做反序列化</p><p>JavaBeanDeserializer.java -&gt; deserialze 方法 -&gt; line 845</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = createInstance(parser, type);</span><br></pre></td></tr></table></figure><p>这个方法会将将目标类的class还原成对象</p><p>JavaBeanDeserializer.java -&gt; deserialze 方法 -&gt; line 892</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> match = parseField(parser, key, object, type,</span><br><span class="line">        fieldValues == <span class="keyword">null</span> ? <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="keyword">this</span>.fieldDeserializers.length) : fieldValues, setFlags);</span><br></pre></td></tr></table></figure><h3 id="parseField-核心"><a href="#parseField-核心" class="headerlink" title="parseField (核心)"></a>parseField (核心)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fieldDeserializer = smartMatch(key, setFlags);</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604141506608.png"></p><p>JavaBeanDeserializer.java -&gt; smartMatch 方法调用 -&gt; line 1313</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604165042526.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static long fnv1a_64_extract(String key)&#123;</span><br><span class="line">    long hashCode &#x3D; 0xcbf29ce484222325L;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; key.length(); ++i)&#123;</span><br><span class="line">        char ch &#x3D; key.charAt(i);</span><br><span class="line">        if(ch &#x3D;&#x3D; &#39;_&#39; || ch &#x3D;&#x3D; &#39;-&#39;)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ch &gt;&#x3D; &#39;A&#39; &amp;&amp; ch &lt;&#x3D; &#39;Z&#39;)&#123;</span><br><span class="line">            ch &#x3D; (char) (ch + 32);</span><br><span class="line">        &#125;</span><br><span class="line">        hashCode ^&#x3D; ch;</span><br><span class="line">        hashCode *&#x3D; 0x100000001b3L;</span><br><span class="line">    &#125;</span><br><span class="line">    return hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaBeanDeserializer.java -&gt; parseField 接口调用 -&gt; line 1277</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fieldDeserializer.parseField(parser, object, objectType, fieldValues);</span><br></pre></td></tr></table></figure><p>DefaultFieldDeserializer.java -&gt; parseField 方法 -&gt; line 86</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604145434459.png"></p><p>将value取出</p><p>DefaultFieldDeserializer.java -&gt; parseField 方法 -&gt; line 124</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604165608225.png"></p><p>setValue装配</p><h3 id="调用链路"><a href="#调用链路" class="headerlink" title="调用链路"></a>调用链路</h3><p>最后附上一张调用链路的断点图片，想要深入读源码的同学可以自己追踪一下</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20210604165752495.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> fastjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture + @Async 并行</title>
      <link href="2021/06/03/async-in-use/"/>
      <url>2021/06/03/async-in-use/</url>
      
        <content type="html"><![CDATA[<p>CompletableFuture + @Async 实现 <strong>串行改并行</strong> </p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1 配置一个自定义线程池</p><p>注意标记上 <code>@EnableAsync</code>，表示这个配置类中的线程池可以配合 <code>@Async</code> 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;pool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;GithubLookup-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然这里配置的线程池也可以直接通过 <code>spring</code> 使用</p></blockquote><p>2 异步任务层</p><p>独立于 <code>Controller层</code> 和 <code>Service层</code> 做一个专门管理并行任务的类，可以将所有的并行操作放在这里。</p><p>注意：<code>@Async</code> 修饰的方法必须与调用它的方法在不同类文件中并且一定要交给 <code>spring</code> 管理，否则相当于方法调用，并不会使用代理类产生异步的效果注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Async(&quot;pool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="title">testFutureTask</span><span class="params">(Integer idx)</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 用例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt;[] completableFutureArray = <span class="keyword">new</span> CompletableFuture[list.size()];</span><br><span class="line"></span><br><span class="line">LocalTime startTime = LocalTime.now();</span><br><span class="line"><span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (integer == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 串行改并行</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; integerCompletableFuture = asyncTestService.testFutureTask(integer);</span><br><span class="line">    completableFutureArray[list.indexOf(integer)] = integerCompletableFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// future 数组健壮性处理</span></span><br><span class="line">CompletableFuture&lt;Integer&gt;[] futures = removeArrayEmptyElement(completableFutureArray);</span><br><span class="line">CompletableFuture.allOf(futures).join();</span><br><span class="line"></span><br><span class="line">LocalTime endTime = LocalTime.now();</span><br><span class="line">Duration between = Duration.between(startTime, endTime);</span><br><span class="line">System.out.println(<span class="string">&quot;测试耗时：&quot;</span> + between.toMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理真实数据</span></span><br><span class="line"><span class="keyword">for</span> (CompletableFuture&lt;Integer&gt; future : futures) &#123;</span><br><span class="line">    Integer integer = future.get();</span><br><span class="line">    arrayList.add(integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/YorickYu/JPP/tree/main/src/main/java/com/yy/async">代码</a></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>1 循环调用 <code>@Async</code> 标记的方法。并将返回的 <code>CompletableFuture</code> 用数组接收。方便后续 <code>CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</code> 处理。</p><p>2 在循环调用 <code>@Async</code> 标记的方法时难免做一些过滤处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (integer == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在循环中，过滤掉integer数组中等于5的元素。</p><p>那么在 arr[] 中就会空缺一个元素，那么交给 <code>CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</code> 处理时就会产生异常。</p><p>解决：做一个 arr[] 空元素的过滤处理即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Integer&gt;[] removeArrayEmptyElement(CompletableFuture&lt;Integer&gt;[] arr) &#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;Integer&gt;&gt; list = Arrays.asList(arr);</span><br><span class="line">    List&lt;CompletableFuture&lt;Integer&gt;&gt; listNew = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;list.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(i)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            listNew.add(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture&lt;Integer&gt;[] arrayNew = listNew.toArray(<span class="keyword">new</span> CompletableFuture[listNew.size()]);</span><br><span class="line">    <span class="keyword">return</span> arrayNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 如果在 <code>@Async</code> 标记的方法中嵌套执行并行操作，那么切记需要 <strong>使用不同的自定义线程池</strong>，否则会产生死锁</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://spring.io/guides/gs/async-method/">async-method</a></p><p><a href="https://stackoverflow.com/questions/47351435/spring-async-with-completablefuture">spring-async-with-completablefuture</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Async </tag>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to break; forEach in Stream</title>
      <link href="2021/05/27/break-foreach/"/>
      <url>2021/05/27/break-foreach/</url>
      
        <content type="html"><![CDATA[<h3 id="forEach-中使用-return"><a href="#forEach-中使用-return" class="headerlink" title="forEach 中使用 return;"></a>forEach 中使用 return;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/32654929/move-to-next-item-using-java-8-foreach-loop-in-stream">Move to next item using Java 8 foreach loop in stream</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">list.forEach(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bbb&quot;</span>.equals(str)) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    lambdaExpressionEquivalent(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lambdaExpressionEquivalent</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;bbb&quot;</span>.equals(str)) <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行流中会发生运行时异常，建议使用iterator"><a href="#并行流中会发生运行时异常，建议使用iterator" class="headerlink" title="并行流中会发生运行时异常，建议使用iterator"></a>并行流中会发生运行时异常，建议使用iterator</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/D35128E7-6743-4D6C-99F6-F60E1EBF9154.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> forEach </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重</title>
      <link href="2021/05/27/list-distinctBy/"/>
      <url>2021/05/27/list-distinctBy/</url>
      
        <content type="html"><![CDATA[<p><strong>数组多条件去重</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// predicate to filter the duplicates by the given key extractor.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Object&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Object, Boolean&gt; uniqueMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> t -&gt; uniqueMap.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>or</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use Set interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Set&lt;Object&gt; seen = ConcurrentHashMap.newKeySet();</span><br><span class="line">    <span class="keyword">return</span> t -&gt; seen.add(keyExtractor.apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>用例</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animal pig = <span class="keyword">new</span> Animal().setName(<span class="string">&quot;pig&quot;</span>).setId(<span class="number">1</span>);</span><br><span class="line">Animal dog1 = <span class="keyword">new</span> Animal().setName(<span class="string">&quot;dog&quot;</span>).setId(<span class="number">2</span>);</span><br><span class="line">Animal dog2 = <span class="keyword">new</span> Animal().setName(<span class="string">&quot;dog&quot;</span>).setId(<span class="number">4</span>);</span><br><span class="line">Animal cat1 = <span class="keyword">new</span> Animal().setName(<span class="string">&quot;cat1&quot;</span>).setId(<span class="number">3</span>);</span><br><span class="line">Animal cat2 = <span class="keyword">new</span> Animal().setName(<span class="string">&quot;cat2&quot;</span>).setId(<span class="number">3</span>);</span><br><span class="line">List&lt;Animal&gt; list = Arrays.asList(pig, dog1, dog2, cat1, cat2);</span><br><span class="line"></span><br><span class="line">List&lt;Animal&gt; res = list.stream().filter(distinctByKey(Animal::getId)).filter(distinctByKey(Animal::getName)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong><em>result</em></strong>: [Animal(id=1, name=pig), Animal(id=2, name=dog), Animal(id=3, name=cat1)]</p>]]></content>
      
      
      
        <tags>
            
            <tag> Stream </tag>
            
            <tag> filter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>serverless、FaaS/BaaS、laaS/PaaS/SaaS</title>
      <link href="2021/05/26/what-is-serverless/"/>
      <url>2021/05/26/what-is-serverless/</url>
      
        <content type="html"><![CDATA[<h3 id="serverless"><a href="#serverless" class="headerlink" title="serverless"></a>serverless</h3><p>用户无需关注支撑应用服务运行的底层机制<br>1 降低运维复杂度，无需监控和维护单服务器的状态<br>2 降低运营成本，按需加载<br>3 降低迭代成本，应用的功能被解构成若干个细粒度的无状态函数。边界清晰、低耦合<br>4 提升创新效率，开发者可以投入更多的精力尝试新的想法和需求</p><h3 id="无服务实现通常分为两类"><a href="#无服务实现通常分为两类" class="headerlink" title="无服务实现通常分为两类"></a>无服务实现通常分为两类</h3><h4 id="FaaS：function-as-a-service-功能即服务"><a href="#FaaS：function-as-a-service-功能即服务" class="headerlink" title="FaaS：function as a service 功能即服务"></a>FaaS：function as a service 功能即服务</h4><p>FaaS是一种构建和部署服务端软件的新方式，面向部署单个的函数或者操作<br>在一个服务器进程中，函数不是一直处于运行状态的，它们只会在需要的时候才运行，其他时间都是空闲状态。一旦这个函数执行完毕，FaaS平台就可以随意销毁它。</p><h4 id="BaaS：backend-as-a-service-后端即服务"><a href="#BaaS：backend-as-a-service-后端即服务" class="headerlink" title="BaaS：backend as a service 后端即服务"></a>BaaS：backend as a service 后端即服务</h4><p>服务商提供领域通用的后端服务，开发者自己开发前端部分。在概念上它更接近SaaS，而BaaS则是要把应用拆分为更小的颗粒</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>从表面上看，BaaS和FaaS是两码事——前者是把应用中的各个部分完全外包出去，后者是一种新的运行代码的托管环境。那么，为什么要把它们都划归为Serverless呢？关键在于，它们都不需要你管理自己的服务器主机或者服务器进程。一个完全Serverless的app不需要你考虑架构中的任何东西。你的应用逻辑——不管是自己编程实现，还是使用第三方服务集成——运行在一个完全弹性的操作环境里。你的状态也是以同样弹性的形式存储的。<br>Serverless并不意味着没有服务器，而是你不需要操心服务器相关的事情。</p><h3 id="云计算的三个层次"><a href="#云计算的三个层次" class="headerlink" title="云计算的三个层次"></a>云计算的三个层次</h3><p><strong>laaS基础设施在最末端，PaaS平台处在中间，SaaS软件则处在最顶层</strong></p><h4 id="laaS：infrastructure-as-a-service-基础设施即服务"><a href="#laaS：infrastructure-as-a-service-基础设施即服务" class="headerlink" title="laaS：infrastructure as a service 基础设施即服务"></a>laaS：infrastructure as a service 基础设施即服务</h4><p>面向公司：提供IT基础架构（存储、网络和服务器）的云计算形式，与无服务息息相关</p><h4 id="PaaS：platform-as-a-service-平台即服务"><a href="#PaaS：platform-as-a-service-平台即服务" class="headerlink" title="PaaS：platform as a service 平台即服务"></a>PaaS：platform as a service 平台即服务</h4><p>面向开发者：旨在为用户提供一个平台，用来开发、运行和管理自己的应用，而无需构建和维护通常与该流程相关联的基础架构。云平台就是一种 PaaS。例如：阿里云、Google Cloud</p><h4 id="SaaS：software-as-a-service-软件即服务"><a href="#SaaS：software-as-a-service-软件即服务" class="headerlink" title="SaaS：software as a service 软件即服务"></a>SaaS：software as a service 软件即服务</h4><p>面向用户：将软件直接交付给用户的服务。服务会持续为用户提供更新、漏洞修复以及常规的软件维护工作，用户直接使用即可。通常通过web浏览器直接访问，消除了用户安装应用的必要</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> serverless </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务重构 SOP</title>
      <link href="2021/05/25/refactor-service/"/>
      <url>2021/05/25/refactor-service/</url>
      
        <content type="html"><![CDATA[<h3 id="什么服务需要重构？"><a href="#什么服务需要重构？" class="headerlink" title="什么服务需要重构？"></a>什么服务需要重构？</h3><p>当现有服务的扩展性、可维护性、易用性无法满足逐渐膨胀的业务增长时，就需要把服务重构提上日程了。</p><p><strong>大致流程梳理如下</strong></p><h3 id="服务梳理阶段"><a href="#服务梳理阶段" class="headerlink" title="服务梳理阶段"></a>服务梳理阶段</h3><p>1 数据库表结构梳理<br>2 redis架构方案、相关key梳理<br>3 功能梳理，前后端接口统计（流量统计）<br>4 项目中潜在的问题梳理</p><p>这个阶段算是一个前期准备阶段，就是对将要重构的项目有一个初步的了解。<br>一方面，了解的越深入，后期遇到的风险就越可控。另一方面，也需要正确的预估一个迭代周期和工时。</p><h3 id="外部依赖梳理、边界划分"><a href="#外部依赖梳理、边界划分" class="headerlink" title="外部依赖梳理、边界划分"></a>外部依赖梳理、边界划分</h3><p>这里需要明确重构后该项目的职责，把原本依赖的外部服务整理出来，把边界划分好。冗余的功能可以评估拆分成下层服务。可以以接口为单位进行整理，提升重构代码的效率。</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>代码优化、降级，限流方案优化</p><p>重构的过程中尽可能把第一个阶段中整理的潜在问题解决掉。为了保证后续业务的发展，加入基础的降级、限流方案。</p><h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><p>出入参数对齐</p><p>对原有项目进行抓包，相同环境下，用抓包的请求参数访问新接口，比对返回参数是否与老接口一致</p><h3 id="测试介入"><a href="#测试介入" class="headerlink" title="测试介入"></a>测试介入</h3><p>用例测试、功能测试</p><h3 id="运维介入"><a href="#运维介入" class="headerlink" title="运维介入"></a>运维介入</h3><p>1 上灰度环境，灰度验证。数据验证、交叉写入测试、流量比对（goReplay流量回放）<br>2 上生产环境，监控服务接入(日志 ELK、QPS grafana、CAT)、压测、蓝绿切换（网关控制）</p><h3 id="全量切换完成重构"><a href="#全量切换完成重构" class="headerlink" title="全量切换完成重构"></a>全量切换完成重构</h3><h3 id="数据验证（游标）"><a href="#数据验证（游标）" class="headerlink" title="数据验证（游标）"></a>数据验证（游标）</h3><p>统计（清洗）异常数据</p><p>写一套数据校验的接口，将生产环境的数据依次读取并完成序列化操作。<br>如果是数据库，以数据表为单位。如果是redis，那么以key为单位。注意是只读</p><h3 id="交叉测试流程"><a href="#交叉测试流程" class="headerlink" title="交叉测试流程"></a>交叉测试流程</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/C87CF8C6-863A-41DA-9CB2-0D00799C1989.png"></p><p>重构项目在生产环境写入数据前需要做必要的数据备份，以防比对不通过时进行数据回滚</p>]]></content>
      
      
      
        <tags>
            
            <tag> SOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list-to-map</title>
      <link href="2021/05/21/list-to-map/"/>
      <url>2021/05/21/list-to-map/</url>
      
        <content type="html"><![CDATA[<p>根据一定的规则将 list 转成 map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java8之前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Animal&gt; <span class="title">convertListBeforeJava8</span><span class="params">(List&lt;Animal&gt; list)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Animal&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Animal animal : list) &#123;</span><br><span class="line">        map.put(animal.getId(), animal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java8之后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Animal&gt; <span class="title">convertListAfterJava8</span><span class="params">(List&lt;Animal&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().collect(Collectors.toMap(Animal::getId, animal -&gt; animal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java8之后 处理key冲突 - IllegalStateException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Animal&gt; <span class="title">convertListAfterJava8_conflict</span><span class="params">(List&lt;Animal&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().collect(Collectors.toMap(Animal::getId, animal -&gt; animal, (ov, nv) -&gt; nv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Guava Maps</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Animal&gt; <span class="title">convertListWithGuava</span><span class="params">(List&lt;Animal&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Maps.uniqueIndex(list, Animal::getId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Animal&gt; <span class="title">convertListWithApacheCommons2</span><span class="params">(List&lt;Animal&gt; list)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Animal&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    MapUtils.populateMap(map, list, Animal::getId);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MapUtils 处理key冲突 - IllegalStateException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Animal&gt; <span class="title">convertListWithApacheCommons2_conflict</span><span class="params">(List&lt;Animal&gt; list)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Animal&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    MapUtils.populateMap(map, list, Animal::getId, animal -&gt; animal);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：<a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/collection/ListToMap.java">ArrayMerge.java</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> Java 8 </tag>
            
            <tag> MapUtils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务拆分和搭建 SOP</title>
      <link href="2021/05/09/microservices/"/>
      <url>2021/05/09/microservices/</url>
      
        <content type="html"><![CDATA[<h3 id="微服务拆分维度"><a href="#微服务拆分维度" class="headerlink" title="微服务拆分维度"></a>微服务拆分维度</h3><p>1 按系统维度：例如前后台拆分<br>2 按功能维度：例如用户服务、价格服务、商品库存服务<br>3 按读写维度：例如搜索和信息流服务、注册和下单服务</p><p><strong>每个服务也可以由若干服务支持构成</strong></p><h3 id="微服务架构搭建"><a href="#微服务架构搭建" class="headerlink" title="微服务架构搭建"></a>微服务架构搭建</h3><p>一般随着公司业务体量的增长，需要考虑从单体服务拆分成微服务架构。</p><p>微服务架构需要考虑下面几个方面：没有优先级之分（不一定完整）</p><h4 id="数据异构"><a href="#数据异构" class="headerlink" title="数据异构"></a>数据异构</h4><p>1 分库分表：以id分表、以用户分表、以数据热度分表<br>2 数据聚合：请求合并，数据闭环</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>本地缓存、缓存架构、集群、负载</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>异步处理、流量削峰、应用解耦<br>考虑消费失败和重复消费场景，需要数据校验和补偿机制<br>最终一致性</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>1 降级、限流、分组和故障隔离<br>降级要做开关，需要动态配置<br>2 流量治理和监控<br>监控不合法的流量来源并隔离治理。如果非法流量无法控制，保留版本回退的能力</p><h4 id="业务安全性"><a href="#业务安全性" class="headerlink" title="业务安全性"></a>业务安全性</h4><p>1 接口幂等<br>2 防重设计<br>3 状态机：正向逆向流程</p><h4 id="监控和预警"><a href="#监控和预警" class="headerlink" title="监控和预警"></a>监控和预警</h4><p>发现问题、定位问题和解决问题<br>全链路埋点：每一个操作经过网络、服务层、中间层都要监控</p><h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>1 动态负载<br>2 服务依赖和治理（优化）</p>]]></content>
      
      
      
        <tags>
            
            <tag> SOP </tag>
            
            <tag> Microservices </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map拼接</title>
      <link href="2021/04/27/tomap-mergemap/"/>
      <url>2021/04/27/tomap-mergemap/</url>
      
        <content type="html"><![CDATA[<p><strong>准备工作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map.merge()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> merge</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 该方法接收三个参数，一个 key 值，一个 value，一个 BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction</span></span><br><span class="line"><span class="comment">* 如果给定的 key 不存在，它就变成了 put(key, value) 。</span></span><br><span class="line"><span class="comment">* 如果 key 已经存在一些值，那么 remappingFunction 可以选择合并的方式，然后将合并得到的 newValue 赋值给原先的 key。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> yloopdaed</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 11:04 2021/4/27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Map&lt;String, Employee&gt; map3 = <span class="keyword">new</span> HashMap&lt;&gt;(map1);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (Map.Entry&lt;String, Employee&gt; entry : map2.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">    String key = entry.getKey();</span></span><br><span class="line"><span class="comment">    Employee value = entry.getValue();</span></span><br><span class="line"><span class="comment">    map3.merge(key, value, (v1, v2) -&gt; new Employee(v1.getId(), v2.getName()));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map2.forEach((key, value) -&gt; map3.merge(key, value, (v1, v2) -&gt; <span class="keyword">new</span> Employee(v1.getId(),v2.getName())));</span><br><span class="line">System.out.println(map3);</span><br></pre></td></tr></table></figure><p><strong>Collectors.toMap()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> Stream.concat()</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* toMap() 接收三个参数，一个 key 值，一个 value，一个 BinaryOperator&lt;U&gt; mergeFunction</span></span><br><span class="line"><span class="comment">* 如果 key 不存在，它就变成了 put(key, value) - 这种情况下可以 通过(v1, v2) -&gt; v1, TreeMap::new 进行默认排序</span></span><br><span class="line"><span class="comment">* 如果 key 已经存在，那么 mergeFunction 可以处理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> yloopdaed</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 11:04 2021/4/27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Map&lt;String, Employee&gt; result = Stream.concat(map1.entrySet().stream(), map2.entrySet().stream())</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">            Map.Entry::getKey,</span><br><span class="line">            Map.Entry::getValue,</span><br><span class="line">            (value1, value2) -&gt; <span class="keyword">new</span> Employee(value2.getId(), value1.getName())));</span><br></pre></td></tr></table></figure><p>代码示例：<a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/collection/InitializeMap.java">InitializeMap.java</a><br>代码示例：<a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/collection/MapMerge.java">MapMerge.java</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组拼接</title>
      <link href="2021/04/26/array-merge/"/>
      <url>2021/04/26/array-merge/</url>
      
        <content type="html"><![CDATA[<p><strong>10种方式拼接两个数组</strong></p><h4 id="List-addAll-amp-Collections-addAll"><a href="#List-addAll-amp-Collections-addAll" class="headerlink" title="List.addAll() &amp; Collections.addAll()"></a>List.addAll() &amp; Collections.addAll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> before 8</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> yloopdaed</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 21:01 2021/4/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge1</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.addAll(list1);</span><br><span class="line">    list.addAll(list2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge2</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(list1);</span><br><span class="line">    list.addAll(list2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge3</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;() &#123;&#123;</span><br><span class="line">        addAll(list1);</span><br><span class="line">        addAll(list2);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">merge4</span><span class="params">(List&lt;String&gt; list1, List&lt;String&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Collections.addAll(list, list1.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    Collections.addAll(list, list2.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-8-Stream"><a href="#Java-8-Stream" class="headerlink" title="Java 8 Stream"></a>Java 8 Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> Java 8</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> yloopdaed</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 21:02 2021/4/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge5</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(list1, list2)</span><br><span class="line">            .flatMap(x -&gt; x.stream())</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge6</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stream.of(list1, list2).forEach(list::addAll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge7</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.concat(list1.stream(), list2.stream())</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge8</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;T&gt; list = list1.stream().collect(Collectors.toList());</span><br><span class="line">    list.addAll(list2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> Guava</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> yloopdaed</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span> 21:05 2021/4/26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge9</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Lists.newArrayList(Iterables.concat(list1, list2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic method to join two lists in Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; List&lt;T&gt; <span class="title">merge10</span><span class="params">(List&lt;T&gt; list1, List&lt;T&gt; list2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;T&gt; list = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    Iterables.addAll(list, list1);</span><br><span class="line">    Iterables.addAll(list, list2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：<a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/collection/ArrayMerge.java">ArrayMerge.java</a></p><p>引用：<a href="https://www.techiedelight.com/join-two-lists-java/">10 ways to join two lists in Java</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream 底层实现</title>
      <link href="2021/04/23/inner-stream/"/>
      <url>2021/04/23/inner-stream/</url>
      
        <content type="html"><![CDATA[<h3 id="Java的演变"><a href="#Java的演变" class="headerlink" title="Java的演变"></a>Java的演变</h3><p>一直致力于让并发编程更容易、出错更少。<br><strong>Java1</strong>：线程和锁<br><strong>Java5</strong>：线程池和并发集合<br><strong>Java7</strong>：Fork/Join 分支合并框架<br><strong>Java8</strong>：Stream 流（并行）</p><h3 id="Stream并行流"><a href="#Stream并行流" class="headerlink" title="Stream并行流"></a>Stream并行流</h3><p>parallelStream，就是把内容分成多个数据块，并用不同的线程分别处理每个数据块的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .parallel() <span class="comment">// 在内部实际上就是设了一个boolean标志，调用后开始并行执行</span></span><br><span class="line">            .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>内部使用了默认的 <code>ForkJoinPool</code>，<strong>默认线程数量是你处理器的数量</strong></p><blockquote><p>通过 Runtime.getRuntime().availableProcessors()得到处理器数<br>通过 System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”); 修改系统默认线程池大小</p></blockquote><p><strong>分支/合并框架</strong> 中通过RecursiveTask进行任务切分。</p><h3 id="性能和安全性"><a href="#性能和安全性" class="headerlink" title="性能和安全性"></a>性能和安全性</h3><p>并行化并不是没有代价的。并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。但在多个内核之间移动数据的代价也可能比你想的要大，所以很重要的一点是要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。</p><h3 id="parallel建议"><a href="#parallel建议" class="headerlink" title="parallel建议"></a>parallel建议</h3><p>1 测量。并行流不一定比顺序流块。最重要的建议就是用适当的基准来测量性能<br>2 留意装箱。自动装箱和拆箱操作会大大降低性能。可以用原始类型流（数值流）<br>3 熟悉方法的使用场景。limit和findFirst这种依赖顺序的操作不适合在并行流使用。findAny可以在并行中使用<br>4 考虑流中的数据结构是否易于拆分。ArrayList拆分效率比LinkedList高得多</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/stream-2.png"></p><h3 id="fork-join建议"><a href="#fork-join建议" class="headerlink" title="fork/join建议"></a>fork/join建议</h3><p>1 对一个任务调用join方法会阻塞调用方，直到该任务做出结果。<br>2 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。<br>3 对子任务调用fork方法可以把它排进ForkJoinPool。</p><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p>划分并行任务时，应该让每个任务都用完全相同的时间完成，让所有的CPU内核都同样繁忙</p><p><strong>分支/合并框架</strong> 工程用一种称为 <strong>工作窃取（work stealing）</strong> 的技术来解决这个问题</p><blockquote><p>工作窃取（work stealing）<br>之前在 RabbitMq 的学习中，有一种消息模型 - Task Queues。这种模型下也可以设置一种模式叫：能者多劳。和工作窃取的原理类似。</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="RecursiveTask-递归"><a href="#RecursiveTask-递归" class="headerlink" title="RecursiveTask 递归"></a>RecursiveTask<R> 递归</h4><p>需要手动编写逻辑，相关代码 <a href="https://github.com/YorickYu/JPP/tree/main/src/main/java/com/yy/forkjoin">Task</a></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/stream-1.png"></p><h4 id="Spliterator-可分迭代器"><a href="#Spliterator-可分迭代器" class="headerlink" title="Spliterator 可分迭代器"></a>Spliterator 可分迭代器</h4><p>parallel并行流中拆分机制</p><p>Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。集合实现了Spliterator接口，接口提供了一个spliterator方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/stream-3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream生成斐波那契数列（无限流）</title>
      <link href="2021/04/22/Fibonacci/"/>
      <url>2021/04/22/Fibonacci/</url>
      
        <content type="html"><![CDATA[<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列。</p><p>在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）</p><p>即 <strong>这个数列从第3项开始，每一项都等于前两项之和</strong></p><h3 id="Stream实现"><a href="#Stream实现" class="headerlink" title="Stream实现"></a>Stream实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, t -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;t[<span class="number">1</span>], t[<span class="number">0</span>] + t[<span class="number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="number">10</span>)</span><br><span class="line">        .map(t -&gt; t[<span class="number">0</span>]).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>仅取了数列前10个元素。</p><p>用了一个小技巧，如果有兴趣的话我之后把过程再更新出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Fibonacci </tag>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试官：Java8到底有什么新特性？</title>
      <link href="2021/04/20/diff-of-java8/"/>
      <url>2021/04/20/diff-of-java8/</url>
      
        <content type="html"><![CDATA[<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>先罗列一下相关的关键字吧。</p><p><strong>行为参数化</strong>、<strong>函数式编程</strong>、<strong>Lambda</strong>、<strong>Stream</strong>、<strong>模式匹配</strong>、<strong>Optional</strong>、<strong>默认方法（接口多继承）</strong> 等</p><p>如果面试真的遇到这个问题，任选上面几点展现一下理解的深度。</p><h3 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力，可以让代码更适应不断变化的需求，减轻未来的工作量</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-1.png"></p><h3 id="代码传递"><a href="#代码传递" class="headerlink" title="代码传递"></a>代码传递</h3><p>Java8之前实现起来很复杂</p><p>编程语言的目的就在于操作值，值作为一等公民。Java8可以将方法看成值一样传递</p><p><strong>演变过程：传值-&gt; 类（实现接口） -&gt; 匿名类 -&gt; Lamdba（函数式接口）-&gt; 方法引用</strong></p><p>上面的函数式接口、匿名类、Lambda都属于 <strong>行为参数化</strong> 的范畴</p><p>例：void sort(Comparator&lt;? super E&gt; c) 演变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">inventory是Apple数组，Apple类中有一个weight属性</span><br><span class="line">需求是按照苹果的重量排序</span><br><span class="line"><span class="number">1</span> 类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Apple</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">inventory.sort(<span class="keyword">new</span> AppleComparator());</span><br><span class="line"><span class="number">2</span> 匿名类</span><br><span class="line">inventory.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple a1, Apple a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="number">3</span> Lambda</span><br><span class="line">inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</span><br><span class="line">静态导入 Comparator.comparing</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparing;</span><br><span class="line">inventory.sort(comparing((a) -&gt; a.getWeight()));</span><br><span class="line"><span class="number">4</span> 方法引用</span><br><span class="line">inventory.sort(comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>@FunctionalInterface：表示该接口会设计成一个函数式接口<br>用函数式接口可以干什么呢？Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例<br>1 Comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 Predicate<br>Stream<T> filter(Predicate&lt;? super T&gt; predicate);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span> <span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 Consumer<br>void forEach(Consumer&lt;? super T&gt; action);<br>void forEachOrdered(Consumer&lt;? super T&gt; action);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 Function<br><R> Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper);<br><R> Stream<R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-2.png"><br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-3.png"></p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>对上面的传递方法进行了编写优化。使代码跟干净清晰<br>语法：(parameters) -&gt; { statements; }<br>它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。<br>1 类型检查：函数式接口 -&gt; 检查泛型T绑定目标类型 -&gt; 检查抽象方法返回值 -&gt; 检查异常throws语句<br>2 类型推断：泛型T支持类型推断。使用时应该考虑程序可读性<br>3 限制：捕获局部变量<br>Lambda可以没有限制地捕获实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。（IDEA会帮你检查）</p><p><strong>为什么会有这个限制</strong>：<br>1 实例变量都存储在堆中，而局部变量则保存在栈上<br>2 命令式编程，不鼓励在lambda中改变外部变量</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>直接传递现有的方法实现。::语法<br>适用：<br>1 静态方法<br>2 任意类型实例方法<br>3 现有对象的实例方法</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-4.png"></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">strs.sort((s1, s2) -&gt; s1.compareToIgnoreCase(s2));</span><br><span class="line">strs.sort(String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><p>内部迭代思想。几乎免费的并行 parallelStream()<br>可以理解成方法引用、lambda和接口中的默认方法。都是为Stream服务的<br>虽然函数式编程中的函数的主要意思是“把函数作为一等值”，不过它也常常隐含着第二层意思，即“执行时在元素之间无互动”。</p><p>理解 <strong>集合</strong> 和 <strong>流</strong> 的区别<br>理解 <strong>外部迭代</strong> 和 <strong>内部迭代</strong> 的区别<br>理解 <strong>按需计算</strong> </p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-5.png"></p><blockquote><p>流只能被消费一次：<strong>中间操作</strong> 和 <strong>终端操作</strong> 概念</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-6.png"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>筛选、切片、映射、查找、匹配、归约、排序、分区、分组</strong></p><h5 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h5><p>1 filter(Predicate p) 筛选<br>2 distinct() 去重<br>3 limit(long maxSize) 截断<br>4 skip(long n) 跳过 limit(n)和skip(n)是互补的</p><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>1 map(Function f) 转换<br>2 flatMap(Function f) flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接<br>起来成为一个流</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-7.png"></p><h5 id="匹配和查找"><a href="#匹配和查找" class="headerlink" title="匹配和查找"></a>匹配和查找</h5><p>1 anyMatch(Predicate p) 至少匹配一个，返回boolean<br>2 allMatch(Predicate p) 全部匹配，返回boolean<br>3 noneMatch(Predicate p) 没有匹配，返回boolean<br>上面三个操作就是 <code>短路</code>，相当于 <code>&amp;&amp;和||</code><br>4 findAny() 查找任意元素，返回Optional<T><br>5 findFirst() 查找第一个元素，返回Optional<T></p><h5 id="归约：函数式编程中叫折叠"><a href="#归约：函数式编程中叫折叠" class="headerlink" title="归约：函数式编程中叫折叠"></a>归约：函数式编程中叫折叠</h5><p>1 reduce(T, BinaryOperator<T>)</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-8.png"></p><p>2 reduce(BinaryOperator<T>) 返回Optional<T><br>2.1 求最大值或最小值<br>Optional<Integer> max = numbers.stream().reduce(Integer::max);<br>Optional<Integer> min = numbers.stream().reduce(Integer::min);</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/java8-9.png"></p><p>2.2 求流中的元素个数<br>int count = menu.stream().map(d -&gt; 1).reduce(0, (a, b) -&gt; a + b); // 全映射成1，然后归约求和<br>long count = menu.stream().count();</p><p>3 collect()</p><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>sorted() 按自然规则排序<br>sorted(Comparator c) 指定规则排序</p><h5 id="分区和分组"><a href="#分区和分组" class="headerlink" title="分区和分组"></a>分区和分组</h5><p>分区：将stream按条件分为两个Map<br>分组：将集合分为多个Map</p><p>1 partitioningBy(Predicate p)<br>2 groupingBy(Function f)</p><p><strong>参考 - <a href="https://juejin.cn/post/6980135669368619045">深度掌握 Java Stream 流操作</a></strong></p><h4 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h4><p>避免暗含的装箱操作<br>1 映射 到数值流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction mapper)</span></span></span><br><span class="line"><span class="function">Double <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction mapper)</span></span></span><br></pre></td></tr></table></figure><p><strong>数值流可以很好的配合 sum() max() min() 方法</strong></p><p>2 转换回对象流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boxed()</span><br><span class="line">mapToObj(xxFunction mapper)</span><br></pre></td></tr></table></figure><h4 id="数值流范围"><a href="#数值流范围" class="headerlink" title="数值流范围"></a>数值流范围</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range(start, end)</span><br><span class="line">rangeClosed(start, end)</span><br></pre></td></tr></table></figure><p><strong>左闭右开</strong></p><h4 id="流的构建"><a href="#流的构建" class="headerlink" title="流的构建"></a>流的构建</h4><p>1 由值创建<br><code>Stream.of(&quot;Java 8 &quot;, &quot;Lambdas &quot;, &quot;In &quot;, &quot;Action&quot;);</code><br>2 由数组创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><p>3 由文件创建</p><p><code>Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;data.txt&quot;), Charset.defaultCharset())</code></p><p>4 由函数创建：无限流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate 迭代</span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println); 生成所有正偶数的流</span><br><span class="line">Stream.generate </span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println); 生成<span class="number">0</span>到<span class="number">1</span>之间的随机双精度数</span><br></pre></td></tr></table></figure><h4 id="相关关键字"><a href="#相关关键字" class="headerlink" title="相关关键字"></a>相关关键字</h4><p>1 元素序列：集合侧重于数据，流侧重于计算<br>2 源<br>3 数据处理操作：可以顺序也可以并行<br>4 流水线：流操作本身会返回一个流（链式）。延迟和短路<br>5 内部迭代 和 外部迭代</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>list.sort(comparator)而不是Collections.sort(list, comparator)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：一旦接口发生变化，实现这些接口的类往往也需要更新</strong></p><p>解决：Java8中接口支持在声明方法的同时提供实现<br>1 Java8允许在接口内声明静态方法<br>2 Java8引入了默认方法 - 指定接口方法的默认实现</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/mfun-1.png"></p><p>引入默认方法的目的：为接口的演进提供了一种平滑的方式</p><h4 id="兼容性拓展：二进制、源代码和函数行为"><a href="#兼容性拓展：二进制、源代码和函数行为" class="headerlink" title="兼容性拓展：二进制、源代码和函数行为"></a>兼容性拓展：二进制、源代码和函数行为</h4><blockquote><p>不同类型的兼容性：二进制、源代码和函数行为<br>变更对Java程序的影响大体可以分成三种类型的兼容性，分别是：<strong>二进制级的兼容</strong>、<strong>源代码级的兼容</strong>，以及<strong>函数行为的兼容</strong>。</p></blockquote><blockquote><p><strong>二进制级的兼容性</strong> 表示现有的二进制执行文件能无缝持续链接（包括验证、准备和解析）和运行。<br>比如，为接口添加一个方法就是二进制级的兼容，这种方式下，如果新添加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误。</p></blockquote><blockquote><p><strong>源代码级的兼容性</strong> 表示引入变化之后，现有的程序依然能成功编译通过。<br>比如，向接口添加新的方法就不是源码级的兼容，因为遗留代码并没有实现新引入的方法，所以它们无法顺利通过编译。</p></blockquote><blockquote><p><strong>函数行为的兼容性</strong> 表示变更发生之后，程序接受同样的输入能得到同样的结果。<br>比如，为接口添加新的方法就是函数行为兼容的，因为新添加的方法在程序中并未被调用（抑或该接口在实现中被覆盖了）。</p></blockquote><h4 id="行为的多继承"><a href="#行为的多继承" class="headerlink" title="行为的多继承"></a>行为的多继承</h4><p>这是一种让类从多个来源重用代码的能力<br><strong>Java的类只能继承单一的类，但是一个类可以实现多接口</strong><br>由于Java 8中接口方法可以包含实现，类可以从多个接口中继承它们的行为（即实现的代码）。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/mfun-2.png"></p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p><strong>如果一个类同时实现了两个接口，这两个接口恰巧又提供了同样的默认方法签名，这时会发生什么情况？</strong></p><h5 id="解决：三条规则"><a href="#解决：三条规则" class="headerlink" title="解决：三条规则"></a>解决：三条规则</h5><p>1 类中的方法（类或父类中声明的方法）优先级最高。<br>2 子接口中，优先选择最具体实现的默认方法接口（B继承A，那么B比A更具体）<br>3 如果还是无法判断，要么通过显示覆盖和调用期望的方法</p><h5 id="情况1：多层继承问题"><a href="#情况1：多层继承问题" class="headerlink" title="情况1：多层继承问题"></a>情况1：多层继承问题</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/mfun-3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决：按照规则（2），应该选择的是提供了最具体实现的默认方法的接口。由于B比A更具体，所以应该选择B的hello方法</strong></p><h5 id="情况2：平行继承问题"><a href="#情况2：平行继承问题" class="headerlink" title="情况2：平行继承问题"></a>情况2：平行继承问题</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/mfun-4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>根据规则（1）和（2）无法判断哪一个更合适，会发生编译错误</p><p><strong>解决：按照规则（3），应该给c添加显示地选择调用接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="情况3：菱形继承问题"><a href="#情况3：菱形继承问题" class="headerlink" title="情况3：菱形继承问题"></a>情况3：菱形继承问题</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/mfun-5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> D().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题比较复杂。要根据具体情况采用不同的解决方案。</p><p><strong>分析</strong>：<br>1 只有A声明了一个默认方法。所以无论调用链路如何，最终都是执行A接口中的方法<br>2 如果B或C中添加了一致的方法实现，那么根据规则（2），会调用更具体的实现<br>3 如果B和C都添加相同的方法实现，那么会发生编译错误，根据规则（3），你需要显示选择调用<br>4 如果B和C不是实现A接口中的方法。而是声明了一个一样的方法。要么D也需要为这个方法显示添加实现。否则无法编译</p><h3 id="Optional-可选类型"><a href="#Optional-可选类型" class="headerlink" title="Optional 可选类型"></a>Optional 可选类型</h3><p>表明了声明的变量值缺失是被允许的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Optional.empty()</span><br><span class="line"><span class="number">2</span> Optional.of(obj) obj必须非空</span><br><span class="line"><span class="number">3</span> Optional.ofNullable(obj) obj允许为<span class="keyword">null</span></span><br><span class="line"><span class="number">4</span> isPresent() 有值时返回<span class="keyword">true</span></span><br><span class="line"><span class="number">5</span> isPresent(Consumer&lt;T&gt; block) 有值时执行block代码块 </span><br><span class="line"><span class="number">6</span> <span class="function">T <span class="title">get</span><span class="params">()</span> 返回值</span></span><br><span class="line"><span class="function">7 T <span class="title">orElse</span><span class="params">(T other)</span> 有值时返回值，否则返回给定的默认值</span></span><br></pre></td></tr></table></figure><p>与Stream相似之处：<br>1 map() 从Optional对象中提取和转换值</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/optional-1.png"></p><p>2 flatMap() 链接 Optional 对象</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/optional-2.png"></p><p>3 filter() 条件过滤<br>如果Optional对象的值存在，并且它符合谓词的条件，filter方法就返回其值；否则它就返回一个空的Optional对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Insurance&gt; optInsurance = ...;</span><br><span class="line">optInsurance.filter(insurance -&gt; <span class="string">&quot;CambridgeInsurance&quot;</span>.equals(insurance.getName()))</span><br><span class="line">        .ifPresent(x -&gt; System.out.println(<span class="string">&quot;ok&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>null引用和Optional.empty()有什么本质的区别吗？</strong></p><p>1 从语义上，两者没有太大区别<br>2 从语法上，如果你尝试解引用一个 null ，一定会触发 NullPointerException ，不过使用Optional.empty()就完全没事儿，它是Optional类的一个有效对象，多种场景都能调用，非常有用。</p><p><strong>异常处理思路</strong></p><p>例如： Integer.parseInt(string) 如果string为null，会报异常NumberFormatException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Integer&gt; <span class="title">stringToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(Integer.parseInt(s));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他思想"><a href="#其他思想" class="headerlink" title="其他思想"></a>其他思想</h3><p>1 空引用：Optional<T> 可选类型<br>2 模式匹配：可以把模式匹配看作switch的扩展形式，可以同时将一个数据类型分解成元素<br>    为什么Java中的switch语句应该限于原始类型值和String呢?<br>3 StringJoiner<br>4 CompletableFuture<br>5 LocalDate、LocalTime、Duration</p>]]></content>
      
      
      
        <tags>
            
            <tag> -JDK 8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 2年的感受</title>
      <link href="2021/04/15/i-dont-know-java/"/>
      <url>2021/04/15/i-dont-know-java/</url>
      
        <content type="html"><![CDATA[<p>全投入转向Java开发已经差不多2年多了。</p><p>分享谈不上，说有一些感触。</p><hr><p>跟面试中造的卫星来比，工作中确实很少有机会去解决核心并棘手的问题。但是即便如此，日常的工作也不会像几年前那么容易摸鱼了。</p><p>互联网最珍贵的就是开源思想。随着大厂成熟解决方案的下放和真实业务场景复杂度的提高，对开发者的要求也会越来越高。</p><p>尤为重要的是大数据，高并发，高可用的解决方案。除此之外目前你应该熟悉：</p><p><strong>服务发现与注册、流量控制和统计、降级与熔断、安全控制、分布式存储和计算、机器学习模型等</strong></p><p>每天都有相关框架的演变和更替。这也是对开发者高要求的体现。</p><p>我之前提到过，要做一个 <a href="https://yloopdaed.icu/2021/03/08/all-life-study">终生学习者</a>。不断更新自己的技术栈，挖掘自己的技术深度和高度。</p><p>最后，享受这个过程。反正你也改变不了它</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《高性能MySQL》 归纳整理</title>
      <link href="2021/04/11/high-performance-mysql/"/>
      <url>2021/04/11/high-performance-mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><p>1 连接/线程处理<br>2 查询缓存+解析器+优化器<br>3 存储引擎</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>每个客户端连接都是mysql服务器中的一个线程，服务端会缓存这些线程，因此每个新建的连接不需要创建或销毁线程</p><h3 id="优化-amp-缓存"><a href="#优化-amp-缓存" class="headerlink" title="优化&amp;缓存"></a>优化&amp;缓存</h3><p>优化器不关心表的存储引擎<br>优化包括：重写查询，改变表的读取顺序，选择合适的索引<br>缓存：解析sql前会先检查缓存</p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>1 读写锁：共享读锁，排他写锁。写锁比读锁有更高的优先级（所以写锁可能插队到读锁前）<br>加锁这个操作本身也需要消耗资源</p><p>2 锁粒度<br>锁定的数据量，锁定的数据量越少，系统并发程度越高<br>2.1 表锁<br>开销小，会锁定整张表<br>2.2 行级锁<br>最大程度支持并发</p><a id="more"></a><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一组原子性的SQL查询，要么全部执行，要么全部失败</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>4种：读未提交、读已提交（大多数数据库默认）、可重复读（mysql默认）、串行化<br>mvcc多版本并发控制和间隙锁解决了幻读</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个事务在同一资源上互相占用<br>innodb可以检测到死锁的循环依赖，并返回一个错误（将持有最少行级排他锁的数据进行回滚）</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>帮助提高事务的效率。<br>每次修改数据，只修改其内存拷贝，再把修改行为记录到事务日志中（磁盘，追加写入）<br>所以修改数据是先写入磁盘事务日志，再慢慢将内存中的数据刷回磁盘（写2次磁盘，数据刷回磁盘时系统崩溃，重启时会根据事务日志修改数据）</p><h3 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h3><p>mysql服务器层不管理事务，事务是由存储引擎实现的。在同一个事务中，使用多个存储引擎是不可靠的（不同的表可以绑定不同的存储引擎）<br>innodb和NDB Cluster引擎支持。myisam不支持<br>默认事务是自动提交模式</p><h2 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h2><p>聚簇索引，对主键查询有很高的性能。（若表中索引较多，主键应该尽量小）<br>innodb内部做了很多优化：<br>1 读：可预测性预读，自动在内存中创建hash索引以加速读操作的自适应哈希<br>2 写：加入缓冲区。加速插入操作</p><h3 id="选择存储引擎"><a href="#选择存储引擎" class="headerlink" title="选择存储引擎"></a>选择存储引擎</h3><p>考虑：事务、备份、崩溃恢复、特有的特性</p><h3 id="改变表的存储引擎"><a href="#改变表的存储引擎" class="headerlink" title="改变表的存储引擎"></a>改变表的存储引擎</h3><p>1 alter table<br>执行时间长。原表会加读锁，复制到一张新表。外键将丢失<br>2 mysqldump工具 导出导入<br>在create table前加上drop table。可能会导致数据丢失<br>3 创建于查询 insert select<br>insert into table_innodb select *from table_myisam</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>mysql中，索引是在存储引擎层实现的</p><p>3个原则：<br>1 单行访问是很慢的。使用索引可以创建位置引用以提升效率<br>2 按顺序访问范围数据是很快的。第一，顺序IO不需要多次磁盘寻道。第二，顺序读取数据不需要额外的排序操作。<br>3 索引覆盖查询是很快的。避免回表和大量单行访问。</p><p>对查询sql的建议：<br>选择合适的索引以避免单行查找、尽可能地使用数据原生顺序从而避免额外的排序操作、尽可能使用索引覆盖查询。</p><p>理解索引是如何工作的是为了创建最合适的索引。非常重要</p><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="为什么查询会慢？"><a href="#为什么查询会慢？" class="headerlink" title="为什么查询会慢？"></a>为什么查询会慢？</h3><p>了解查询的生命周期、清楚查询的时间消耗情况<br>网络、CPU计算、生成统计信息和执行计划、锁等待（互斥等待）、上下文切换以及系统调用等<br>减少一些不必要的额外操作，消除额外的重复操作达到优化查询的目的</p><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><p>1 请求了不需要的数据：limit、只选取需要的列数据、缓存<br>2 扫描额外的记录：扫描行数、访问类型、返回的行数</p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><p>1 复杂查询分解成多个简单查询：MySQL连接和断开都是很轻量级的<br>2 切分查询：大查询切分成小查询多次执行<br>3 分解关联查询：充分利用查询缓存、单个查询可以减少锁竞争、在应用层做关联，更容易对数据库进行拆分和扩展</p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Screenshot_20210404_230318.jpg"></p><p>mysql内部优化流程<br>1 查询缓存：大小写敏感的hash查找实现<br>2 语法解析和预处理：sql语法解析，生成“解析树”<br>3 查询优化器：将语法树通过优化器转化成执行计划，优化器的作用就是找到最好的执行计划（基于成本优化）<br>    可以处理的优化类型：<br>3.1 重新定义关联表顺序<br>3.2 外连接转化成内连接<br>3.3 等价变换规则<br>3.4 优化count、min和max方法<br>3.5 扫描覆盖索引<br>3.6 子查询优化<br>3.7 提前终止查询</p><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>1 检查查询语句的哈希值是否命中（大小写敏感）<br>2 检查用户权限</p><h4 id="解析器和预处理器"><a href="#解析器和预处理器" class="headerlink" title="解析器和预处理器"></a>解析器和预处理器</h4><p>1 MySQL通过关键字将SQL语句解析成一颗“解析树”<br>2 解析器进行规则验证和解析查询<br>3 预处理器检查表、数据列、别名等的合法性，还有权限验证（这个验证通常很快）</p><h4 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h4><p>一条查询可以有多种执行方式，最后都返回相同的结果。查询优化器就是找到其中最好的执行计划<br>MySQL通常是基于成本优化，有两种优化策略：静态优化、动态优化</p><blockquote><p>查询成本 SHOW STATUS LIKE ‘Last_query_cost’<br>查看执行计划 EXPLAIN EXTENDED</p></blockquote><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>1 UNION查询<br>先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成UNION查询<br>2 JOIN查询<br>重新定义关联的顺序：MySQL会选择合适的关联顺序让查询执行的成本尽可能低。（可以使用关键字 STRAIGHT_JOIN 让优化器按照你认为的最优关联顺序执行）</p><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><p>应尽可能避免排序或者尽可能避免对大量数据排序，尽量使用索引生成的排序结果<br>MySQL排序：filesort 文件排序<br>1 数据量小在内存中进行，快速排序<br>2 数据量大需要使用磁盘，先将数据分块，每个独立块使用快速排序（每个块的快排结果存在磁盘上）<br>3 最后将各个排好序的块进行合并<br>文件排序时需要很多临时存储空间，因为每一个排序记录都会分配一个足够长的定长空间来存放。<br>例如：varchar列（UTF-8字符集）需要为每个字符预留三个字节。这样排序消耗的临时空间比次磁盘上原有表都要大很多倍</p><h2 id="关联查询时排序"><a href="#关联查询时排序" class="headerlink" title="关联查询时排序"></a>关联查询时排序</h2><p>两种情况<br>1 如果 ORDER BY 中的所有列都来自关联的第一个表，那么MySQL在关联处理第一个表时进行文件排序（Extra字段 Using filesort）<br>2 其他所有，MySQL会先将关联的结果存放在一个临时表中，然后在所有关联结束后，再进行文件排序。（Extra字段 Using temporary；Using filesort）<br>注意：5.6版本之前，LIMIT也会在排序之后应用，即使只返回少量数据，临时表和需要排序的数据量仍然很大。<br>5.6版本之后，对此进行了优化。根据实际情况抛弃不满足条件的结果，然后再进行排序</p><h2 id=""><a href="#" class="headerlink" title=".."></a>..</h2><p>持续更新</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> MySQL </tag>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存架构概念篇</title>
      <link href="2021/04/10/cache-structure/"/>
      <url>2021/04/10/cache-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着业务场景复杂度的提高和数据存储量的膨胀，为了保证整体服务平稳运行，缓存系统的地位也越来越高。</p><p>今天就近期对缓存架构的理解，梳理成一篇浅显的文章</p><h2 id="Redis缓存架构分类"><a href="#Redis缓存架构分类" class="headerlink" title="Redis缓存架构分类"></a>Redis缓存架构分类</h2><p>根据日常C端面临的实际情况，Redis 做缓存时，大体分为两种模式，分别是<strong>只读缓存</strong>和<strong>读写缓存</strong>。</p><h3 id="只读缓存（读多写少）"><a href="#只读缓存（读多写少）" class="headerlink" title="只读缓存（读多写少）"></a>只读缓存（读多写少）</h3><p>修改数据时先删除缓存，下次读请求再写入。例如：<strong>旁路型缓存</strong></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/cache1.png"></p><p>当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了</p><h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>修改数据时不删除缓存，最新的数据是在 Redis 中，通过回写策略同步数据库。例如：<strong>穿透型缓存</strong></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/cache2.png"></p><blockquote><p>回写策略<br>1 同步直写策略，写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。<br>同步直写会降低缓存的访问性能<br>2 异步写回策略，优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。<br>异步写回有数据丢失的风险</p></blockquote><p><strong>同步直写模式侧重于保证数据可靠性，而异步写回模式则侧重于提供低延迟访问</strong></p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关于是选择只读缓存，还是读写缓存，主要看我们 <strong>对写请求是否有加速的需求</strong></p><p>1 如果需要对写请求进行加速，我们选择读写缓存<br>2 如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存</p><hr><p>缓存可以放到基础架构中任何存在数据传输瓶颈的地方。</p><h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><h3 id="旁路型缓存-Look-Aside-Caching"><a href="#旁路型缓存-Look-Aside-Caching" class="headerlink" title="旁路型缓存 (Look-Aside Caching)"></a>旁路型缓存 (Look-Aside Caching)</h3><p>旁路型缓存是避免微服务从后端存储中访问数据的高性能替代方案<br>1 应用读取数据时，需要先读取 Redis；<br>2 发生缓存缺失时，需要从数据库读取数据；<br>3 发生缓存缺失时，还需要更新缓存。</p><p>这些操作都要放在应用程序中来完成。所以，<br>有一个地方就需要注意了：因为需要新增程序代码来使用缓存，所以，Redis 并不适用于那些无法获得源码的应用，例如一些很早之前开发的应用程序，它们的源码已经没有再维护了，或者是第三方供应商开发的应用，没有提供源码，所以，我们就没有办法在这些应用中进行缓存操作。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>伴随业务膨胀，缓存的一致性维护难度上涨<br>思考：<br>数据读写方的沟通难题<br>解决方案：<br>1 AOP注解，更新缓存时通知<br>2 Mybatis 触发器<br>3 binlog 处理<br>4 MQ 最终一致性</p><h3 id="穿透型缓存"><a href="#穿透型缓存" class="headerlink" title="穿透型缓存"></a>穿透型缓存</h3><p>穿透型缓存的设计原则是将缓存与后端数据库的交互细节对应用层服务隐藏<br>应用层服务所有的读写请求均请求缓存，读请求 miss 后，缓存向后端数据服务器请求数据，先更新缓存后返回<br>而写请求也是同样的，先写入缓存服务器，随后在合适的时间同步给后端服务器</p><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>实现复杂度和数据一致性的问题<br>思考：<br>选择合适的回写时间节点，和回写策略<br>合理规划缓存中的键值关系<br>解决方案：<br>1 实现复杂性无法避免，为了追求高频读写场景的缓存最大化利用<br>2 一致性问题考虑配合脚本语言，触发器等实现一个回写服务，当然还要保证缓存服务的高可用（这也不算不上解决方案）</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实缓存架构的思想内嵌是无处不在的。MySQL本身也有<code>buffer pool</code>的概念。redis中也有批处理指令和pipeline管道的概念。甚至于寄存器与系统内存之间的3级缓存概念。</p><p>硬件的定位差距总需要通过软件去弥补，协同工作</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>吹毛求疵</title>
      <link href="2021/04/01/cavil/"/>
      <url>2021/04/01/cavil/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽说吹毛求疵看似是个贬义词，但是技术上的吹毛求疵往往是有必要的。</p><p>这里会不定时更新一些日常编码中 <code>吹毛求疵</code> 的写法。目的也是为了养成一个良好的编码习惯。</p><h3 id="循环中的size判断"><a href="#循环中的size判断" class="headerlink" title="循环中的size判断"></a>循环中的size判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ~~<span class="keyword">int</span>~~ length = list.size; i &lt; length; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, length = list.size; i &lt; length; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list.size 有一定的资源消耗</p><h3 id="返回空集合"><a href="#返回空集合" class="headerlink" title="返回空集合"></a>返回空集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Result&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO.</span></span><br><span class="line">    <span class="keyword">return</span> Collections.EMPTY_LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果查询数据为空时，也需要返回一个空集合，而不是null。防止调用方空指针异常</p><h3 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singlenton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singlenton INSTANCE; <span class="comment">// JIT</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singlenton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// DCL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singlenton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// double check 1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singlenton.class) &#123; <span class="comment">// LOCK</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// double check 2</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singlenton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免对象半初始化状态</p><h3 id="局部变量赋值"><a href="#局部变量赋值" class="headerlink" title="局部变量赋值"></a>局部变量赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;    </span><br><span class="line"><span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure><p>这种写法在源码中比较常见</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Innodb 自定义Hash索引</title>
      <link href="2021/03/29/mysql-innodb-hash/"/>
      <url>2021/03/29/mysql-innodb-hash/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL中，索引是在存储引擎实现的<br>MySQL中，只有 Memory 引擎显式支持哈希索引（非唯一）<br>MySQL中，默认的Innodb引擎是不支持 Hash 索引的</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引的数据结构：槽 Slot、值 Value</p><p>每个槽的编号是顺序的，但是值不是。<strong>值存储的是指向 行 的指针</strong></p><p>优点：<br>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。</p><p>缺点：<br>1 哈希值是无序的，无法用于排序<br>2 哈希索引只支持等值比较，不支持任何范围查询<br>3 哈希冲突，索引维护操作代价很高<br>4 不支持部分列匹配查找。例如：对数据列（A,B）建立哈希索引，此时查询A列，无法使用该索引</p><p><strong>因为这些限制，哈希索引只适用于某些特定的场合</strong>。而一旦适合哈希索引 ，则它带来性能提升将非常显著。</p><h3 id="大字符串类型索引"><a href="#大字符串类型索引" class="headerlink" title="大字符串类型索引"></a>大字符串类型索引</h3><blockquote><p>这里基于 Innodb 数据引擎讨论</p></blockquote><p>由于索引本身在 Innodb 中是以 B+Tree 的数据结构存在的。如果对于大字符串类型直接建立索引显然是不合理的。（这里不展开介绍 B+ 树在 MySQL 中的相关知识）</p><p>那么，假如现在要对数据列 email 或者 url 这类数据列建立索引。应该如何保证空间和效率？</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>这是一种常见的思路，取大字符串类型的前缀建立索引，节省空间的同时尽可能过滤数据。</p><p>难点在于需要合理定位一个前缀长度，尽可能过滤重复数据。</p><p>此外需要注意的是，前缀索引会导致覆盖索引失效。这里就不详细展开了。</p><h4 id="自定义-Hash-索引"><a href="#自定义-Hash-索引" class="headerlink" title="自定义 Hash 索引"></a>自定义 Hash 索引</h4><p>这个概念其实一直存在于 Innodb 引擎中。</p><blockquote><p>innodb内部做了很多优化：<br>1 读：可预测性预读，自动在内存中创建 <strong>自适应Hash索引</strong> 以加速读操作<br>2 写：加入缓冲区。加速插入操作</p></blockquote><p>上面的内容了解即可，本文中提到的 自定义Hash索引 是在 B+树 的基础上创建一个 <strong>伪哈希索引</strong>。</p><p>思路就是新增一列记录大字符串哈希算法的结（删除原来字符串的索引）。</p><h5 id="哈希算法的选择"><a href="#哈希算法的选择" class="headerlink" title="哈希算法的选择"></a>哈希算法的选择</h5><p>不要使用 SHA1() 和 MD5() 作为哈希函数。因为这两个函数是强加密函数。计算出来的哈希值非常长，浪费空间，索引过程也更慢。他们得设计目的是加密。</p><p>CRC32() 是一个比较好的选择，计算结果较小。但是随着数据量的增多会出现明显的哈希冲突问题。可以在此基础上优化得到适合自己项目需求的哈希算法。</p><h5 id="如何维护哈希值"><a href="#如何维护哈希值" class="headerlink" title="如何维护哈希值"></a>如何维护哈希值</h5><p>由于新增了一列伪哈希数据列。所以对于行数据的更新的插入操作。都是进行相应的哈希操作。</p><p>当然这一列哈希值的维护可以进行手动维护，也可以使用触发器实现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER // </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> pseudohash_crc_in s <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> pseudohash <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SET</span> NEW.url_crc=<span class="keyword">crc32</span>(NEW.url); </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">// </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> pseudohash_crc_upd <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> pseudohash <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SET</span> NEW.url_crc=<span class="keyword">crc32</span>(NEW.url); </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">//</span><br></pre></td></tr></table></figure><h5 id="sql改写"><a href="#sql改写" class="headerlink" title="sql改写"></a>sql改写</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT id FROM url WHERE url=&quot;http://www.mysql.com&quot;;</span><br></pre></td></tr></table></figure><p>改进为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT id FROM url WHERE url=&quot;http://www.mysql.com&quot; AND url_crc=CRC32(&quot;http://www.mysql.com&quot;);</span><br></pre></td></tr></table></figure><p>由于哈希冲突。所以还是需要带有原条件，在伪哈希索引之后再扫描少量的数据。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇文章只是对于大字符串索引优化提供另一种思路。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Hash索引 </tag>
            
            <tag> 字符串索引优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redisson 锁续期</title>
      <link href="2021/03/21/redisson-watchdog/"/>
      <url>2021/03/21/redisson-watchdog/</url>
      
        <content type="html"><![CDATA[<p>redisson 默认加锁有效期 30s</p><p>watchdog 调用频率 10s，每次调用会将锁有效期更新为 30s。</p><p>如果redis服务宕机，那么锁和watchdog都会停止服务。即，锁到期会正常过期，没有死锁。</p><p>相关源码如下：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/redisson%E9%94%81%E7%BB%AD%E6%9C%9F.jpg"></p><p>参考：</p><p>简书作者，花神子 - <a href="https://www.jianshu.com/p/0d3f5395ceaf">缓存Redis 分布式锁的续期</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> redisson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis pipelines</title>
      <link href="2021/03/20/redis-pipelines/"/>
      <url>2021/03/20/redis-pipelines/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是pipelines"><a href="#什么是pipelines" class="headerlink" title="什么是pipelines"></a>什么是pipelines</h3><p>redis pipelines，管道，是redis客户端提供的一个批量处理命令。</p><p>管道操作的本质是客户端通过对管道中的指令 <code>重排序</code> 执行。这样做可以大幅节省IO时间。</p><blockquote><p>我们知道redis的工作模型是基于单线程的，我个人认为他之所以这样设计，是因为CPU的性能不是redis性能瓶颈的关键因素。而是IO。<br>redis pipelines可以通过改变命令的读写顺序，将读指令合并执行、写指令合并执行。减少IO的频率从而减少网络通信的花费。</p></blockquote><h3 id="与原生批量命令-mget-mset-的区别"><a href="#与原生批量命令-mget-mset-的区别" class="headerlink" title="与原生批量命令 mget mset 的区别"></a>与原生批量命令 mget mset 的区别</h3><p>原生批量命令是redis服务端实现的。而pipelines是redis客户端实现的。</p><p>当key的数目过多时，mget和mset的执行效率会大于pipelines</p><p><em>pipelines不会阻塞其他客户端，而mget会。</em></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pipevsmget.jpg"></p><h3 id="pipelines-底层"><a href="#pipelines-底层" class="headerlink" title="pipelines 底层"></a>pipelines 底层</h3><p>依靠 <code>网络协议栈</code> 深入内核</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pipelinesker.jpg"></p><p>流程简述：<br>客户端请求 -&gt; send buffer -&gt; 网卡（客户端） -&gt; 路由网关 -&gt; 网卡（服务器）-&gt;  recv buffer -&gt; 服务器处理<br>一个客户端请求被服务器处理完成后，原路返回。</p><p>总结：<br>1 写操作几乎没有耗时，写入客户端 send buffer 就直接返回<br>2 读操作需要经历完整的流程，最终从 recv buffer 中获取数据，这是真正耗时的操作</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>去探索一下redis单机性能的极限在哪里？</p><p>1 如果没有管道，最大承受qps是多少？<br>2 通过管道，最大承受qps是多少？</p><p>证实一下为什么redis性能瓶颈不取决于CPU，而是IO。<br>这也能换个角度更好的理解为什么redis要使用单线程模型。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 管道 </tag>
            
            <tag> mget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蚂蚁金服初试：双写一致性延伸</title>
      <link href="2021/03/18/redis-mysql-cp/"/>
      <url>2021/03/18/redis-mysql-cp/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天有幸参加了蚂蚁金服的线上初试，获益良多。</p><p>记录下来</p><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>挑选您项目中比较有亮点的部分介绍一下?</p><blockquote><p>这个问题也许大家经常遇到，也没有足够的重视。其实这个问题在我个人看来是整场面试最关键的问题。<br>因为你有机会通过这个问题介绍一个成熟的解决方案！有时候打动面试官只需要一个成熟的解决方案。<br>这不仅仅说明你在业务上横向的全局思考能力，也体现了纵向的技术理解深度。</p></blockquote><p><strong>所以这个问题，一定要好好利用。</strong></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>整场面试的重点是由 redis和mysql的双写一致性 引出的。</p><p><strong>问题是：如果mysql完成了数据更新，但是随后更新redis时失败了。如何处理？</strong></p><p>我当时没有很好的回答这个问题，思考过后与大家分享一个解决方案。</p><p>首先假设一个场景是购物车系统。使用redis hash维护了一个简单的购物车，同时持久化在mysql数据库中。</p><p>那么对于用户在购物车的操作需要反馈给数据库。</p><blockquote><p>PS：这里考虑借鉴缓冲池的思想，对用户的操作做一些预处理后再真实发生请求。尽量减少无效请求的次数。</p></blockquote><p>但是最终通过接口同步数据的时候发生了问题：mysql更新成功，随后redis写入失败。</p><blockquote><p>PS：这里先不讨论其他的双写一致性方案，比如：先删除redis数据，再更新数据库。<br>其次这里举例redis可能发生写入失败的场景：redis宕机、redis内存打满。</p></blockquote><p>此时，已经发生了redis和mysql数据不一致的情况。那么如何解决这个问题？</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>首先要进一步优化redis集群，保证redis高可用，从根源解决问题。</p><p>其次我的想法是借鉴分布式事务中 <code>最终一致性</code> 原则去解决这个问题。</p><p>这个场景中，先更新mysql，再更新redis，同时向mq中发送一条变更指令。mq会在后台消费这个变更指令，达到数据的最终一致性。</p><p>在此期间，如果用于有读请求发生，可以先去判断一下这个mq中是否存在未被消费的信息。如果有，这条读请求就直接打到数据库中。并更新redis（同时是否能让mq中的消息标记处理）</p><p>我感觉这样处理应该是可以最终保持数据一致性的。当然mq本身也要做集群高可用处理。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>整理一下正常面试的流程吧，说不定对大家有帮助。</p><p>1 从项目出发，面试官会根据项目中的业务场景发问，这需要你非常熟悉自己的项目，并且有比较完善的处理。</p><p>2 线上同步编码，会通过一个共享的编辑器窗口，现场完成几个简单的编程题。（算法、编程能力）</p><p>3 最后会问一些底层的问题：源码、JVM等</p><p>整个面试过程大约2个小时。</p><p>最主要的收获：</p><p>珍惜项目中遇到的每一个问题，提出解决方案，并不断的优化。</p><p>长久如此，肯定会有收获。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终生学习者</title>
      <link href="2021/03/08/all-life-study/"/>
      <url>2021/03/08/all-life-study/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个词早在几年前就注意过，多为一些知乎作者的自我简介。没有过多深究。</p><p>但是随着短视频平台兴起，除了毫无营养的带货、搞笑视频，我更愿意关注一些产出作品的作者。</p><p>渐渐的，我的抖音画像也趋于成熟了，我喜欢的分类大概有：汽车、金融、摄影、篮球，当然还有一些分享干货的作者。这些干货往往在众多快餐式的短视频中特别能吸引我的眼球。他们产量并不高，甚至我有时候会一次性看完他们所有的作品，收获颇丰。</p><p>最近有关注到一位20几岁的年轻作者，斯坦福学士，互联网行业工作。我发现他的标签也有一个 “终生学习者”。</p><h2 id="什么是终生学习者？如何成为？"><a href="#什么是终生学习者？如何成为？" class="headerlink" title="什么是终生学习者？如何成为？"></a>什么是终生学习者？如何成为？</h2><p>这里只能从知乎搬砖了，把准确的定义分享出来。</p><blockquote><p>信息论中有一个很有意思的概念：只有正确且少数人知道的信息才是有价值的！<br>从这个角度看，终身学习者就是努力掌握有价值的信息的人。<br>关于如何成为终身学习者，我自己并没有百分之百准确的答案，只提一点点心得：<br>1.建立准确清晰的概念。这一点是李笑来反复强调的。为什么我们听了很多道理但就是过不好这一生？实际上很多情况下是你根本没有清晰理解那个道理。没有概念，就没有行动，没有行动，就没有结果。<br>2.活在未来。这也是李笑来提出的。不断预测未来，按照未来的情况指导你当下的行动。<br>3.不落后于人。不论在财富、社会地位、健康、教育等等各个方面，都应该努力超过你身边的人，做到前50%，继而做到前90%，再做到前98%，继而升级，并且继续超越。</p></blockquote><p>作者：<a href="https://www.zhihu.com/question/53028316/answer/134617342">不知所谓</a></p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>战略上的理解<br>终生学习的周期可能是20年左右。因为平均每20几年，人就会为人父母。人需要用新的方式方法经历自己曾经经历过的一切。把子女教育成为更好的人。所以你只能不断学习，教育也要不断更新。重复基础教育中经典的=部分，并把过去的经验总结给自己的下一代。</p><p>战术上的理解<br>每个人要通过不断的学习、不断更新对事物的认识来准确的定位自己。这个过程不一定要与人对比，而是成为共有价值体系中更优秀的人。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望有朝一日自己可以成为一个终生学习者</p>]]></content>
      
      
      
        <tags>
            
            <tag> 终生学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap&lt;Long, Long&gt; 的空间效率问题</title>
      <link href="2021/02/20/HashMap-long-long/"/>
      <url>2021/02/20/HashMap-long-long/</url>
      
        <content type="html"><![CDATA[<p>为什么要讨论 <code>HashMap&lt;Long, Long&gt;</code> 这个数据结构的空间效率问题？</p><p>因为不恰当的使用数据结构可能会导致内存占用过大，从而加剧JVM垃圾回收时的用户线程停顿时间，造成不良的用户体验。</p><p><code>HashMap&lt;Long, Long&gt;</code> 有多低呢？</p><p>在 <code>HashMap&lt;Long，Long&gt;</code> 结构中：<br>1 Key和Value所存放的两个长整型数据是有效数据，共16字节（2×8字节）。<br>2 这两个长整型数据包装成 <code>java.lang.Long</code> 对象之后，就分别具有8字节的Mark Word、8字节的Klass指针，再加8字节存储数据的long值。<br>3 然后这2个Long对象组成 <code>Map.Entry</code> 之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充<br>4 最后还有HashMap中对这个Entry的8字节的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24byte)×2)+Entry(32byte)+HashMapRef(8byte)=88byte</p><p>空间效率为有效数据除以全部内存空间，即16字节/88字节=<strong>18%</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> Mark Word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆 &amp; 垃圾回收机制</title>
      <link href="2021/02/11/jvm-gc/"/>
      <url>2021/02/11/jvm-gc/</url>
      
        <content type="html"><![CDATA[<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆内存中可以细分为三个区域：<br>1 新生代Young：伊甸园区Eden、幸存0区from、幸存1区to<br>2 老年代Old：默认一个对象经历了15次GC还没被回收，会进入老年代，可以通过<code>-XX:MaxTenuringThreshold</code>更改次数<br>3 永久代Perm：方法区（1.7）/元数据区（1.8）</p><blockquote><p>永久代有两种理解：<br>1 把他理解成与堆是分开的独立区域<br>2 把他理解在堆内，逻辑上存在，物理上不占用堆内空间</p></blockquote><p>堆内存溢出OOM：OutOfMemoryError:Java heap space<br>处理堆OOM：<br>1 扩大堆内存<br>2 分析内存，找问题（定位简单，调优难）</p><p>常用调试工具：<br>1 JProfiler工具<br>2 Eclipse自带的MAT<br>3 在Java的Jdk中 jconsole.exe 和 jvisualvm.exe<br>4 <a href="https://github.com/alibaba/arthas">arthas</a></p><p>Jprofiler使用：<br>1 分析Dump内存文件<br>2 查看堆中的数据信息<br>3 查看堆中的线程信息</p><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        s += <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">        s += <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">        s += <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置运行参数：<code>-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails</code></p></blockquote><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/oom-error.jpg"></p><h5 id="分析Dump文件"><a href="#分析Dump文件" class="headerlink" title="分析Dump文件"></a>分析Dump文件</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jprofiler-obj.jpg" alt="Object"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jprofiler-thread.jpg" alt="Thread"></p><h5 id="常用调优参数"><a href="#常用调优参数" class="headerlink" title="常用调优参数"></a>常用调优参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">常见的如下：</span><br><span class="line">-Xms64m 最小堆内存 64m.</span><br><span class="line">-Xmx128m 最大堆内存 128m.</span><br><span class="line">-XX:NewSize&#x3D;30m 新生代初始化大小为30m.</span><br><span class="line">-XX:MaxNewSize&#x3D;40m 新生代最大大小为40m.</span><br><span class="line">-Xss&#x3D;256k 线程栈大小。</span><br><span class="line">-XX:+PrintGCDetails 显示堆内存信息和GC信息</span><br><span class="line">-XX:+PrintHeapAtGC 当发生 GC 时打印内存布局。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError 发送内存溢出时 dump 内存。</span><br><span class="line"></span><br><span class="line">新生代和老年代的默认比例为 1:2，也就是说新生代占用 1&#x2F;3的堆内存，而老年代占用 2&#x2F;3 的堆内存。</span><br><span class="line">可以通过参数 -XX:NewRatio&#x3D;2 来设置老年代&#x2F;新生代的比例。</span><br></pre></td></tr></table></figure><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>符合大多数成熟运营的实际情况的经验法则。<br>将Java堆划分成不同的区域，根据回收对象的年龄（经历的垃圾回收次数）分配到不同区域存储。</p><p>三大假说：<br>1 弱分代假说：绝大多数对象都是朝生夕灭<br>2 强分代假说：熬过越多次垃圾收集过程的对象就越难以清除<br>3 跨代引用假说：跨代引用相对同代引用来说占极少数</p><blockquote><p>堆划分成新生代和老年代，分代收集时对象不是孤立的，对象之间存在跨代引用<br>思考：Minor GC时一个新生代中的对象回收时被老年代引用，此时是否需要额外遍历整个老年代？<br>根据第3条假说，具体做法是：在新生代上建立一个全局数据结构（记忆集 Remembered Set），这个结构把老年代划分成若干小块，标志出哪一块存在跨代引用。只遍历这一小块即可</p></blockquote><p>不同区域的垃圾回收类型：<br>1 Minor GC：新生代收集<br>2 Major GC ：老年代收集。CMS收集器独有<br><strong>3 Mixed GC：混合收集，新生代+部分老年代。G1收集器独有</strong><br>4 Full GC：整堆收集，收集Java堆和方法区（元数据区）</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><h5 id="标记-复制算法：将存活的对象进行复制和移动"><a href="#标记-复制算法：将存活的对象进行复制和移动" class="headerlink" title="标记-复制算法：将存活的对象进行复制和移动"></a>标记-复制算法：将存活的对象进行复制和移动</h5><p>每次Minor GC都会清空Eden区和幸存to区：<br>1 将Eden中存活的对象复制到幸存to区。<br>2 将原本幸存from区中存活的对象复制到幸存to区，并交换幸存from和to区。所以最后幸存to区是空的。<br>优点：没有内存碎片<br>缺点：两个幸存区永远有一个是空的。浪费了一半的空间</p><h5 id="标记-清除算法：两次扫描"><a href="#标记-清除算法：两次扫描" class="headerlink" title="标记-清除算法：两次扫描"></a>标记-清除算法：两次扫描</h5><p>第一次扫描全部对象，对存活的对象进行标记。<br>第二次扫描全部对象，对没有标记的对象进行清除<br>优点：不浪费额外的空间<br>缺点：两次扫描，浪费时间。会产生内存碎片</p><h5 id="标记-在整理-压缩算法：在标记清除的基础上，防止内存碎片。"><a href="#标记-在整理-压缩算法：在标记清除的基础上，防止内存碎片。" class="headerlink" title="标记-在整理/压缩算法：在标记清除的基础上，防止内存碎片。"></a>标记-在整理/压缩算法：在标记清除的基础上，防止内存碎片。</h5><p>再次扫描全部对象（清除过后的对象），向一端移动存活的对象（移动对象有一定开销）<br>可以在多次标记清除算法后，再执行一次标记压缩，节省开销。<br>缺点：移动存活对象，更新引用要全程暂停程序（STW Stop The World）。<br>其实，标记-清除算法也存在STW，只是停顿的时间很短而已<br>这是为了保证结果的准确性（不然在分析或回收过程中，对象引用关系还在不断变化）</p><h5 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h5><p>很少用，与iOS中的引用计数器原理基本相同。实例每建立一个强引用就会给对应的引用计数器加一。其实类似的思想在JUC源码中有很多体现。缺点就是要维护一个引用变量。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>时间复杂度（从低到高）：复制算法 &gt; 标记清除法 &gt; 标记压缩法<br>内存整齐度：复制算法 = 标记压缩法 &gt; 标记清除法<br>内存利用率：标记压缩法 = 标记清除法 &gt; 复制算法</p><p><strong><em>复制算法</em></strong> 最佳使用场景：对象存活度较低的区域——新生代</p><p><strong><em>标记清除 + 标记压缩</em></strong> 最佳使用场景：对象存活率高，空间大的区域——老年代</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/gc_collector.png"></p><p>没有<strong>最好的</strong>收集器，更不存在<strong>万能的</strong>收集器，值有<strong>最合适的</strong>收集器</p><h5 id="Serial-收集器（新生代收集器）"><a href="#Serial-收集器（新生代收集器）" class="headerlink" title="Serial 收集器（新生代收集器）"></a>Serial 收集器（新生代收集器）</h5><p>一个<strong>单线程工作</strong>的收集器：进行垃圾收集时，必须暂停其他所有工作线程，直至收集结束。<br>特点：简单而高效，没有线程交互的开销。<br>应用：微服务应用中（虚拟机，内存小的场景）</p><h5 id="ParNew-收集器（新生代收集器）"><a href="#ParNew-收集器（新生代收集器）" class="headerlink" title="ParNew 收集器（新生代收集器）"></a>ParNew 收集器（新生代收集器）</h5><p>Serial收集器的<strong>多线程并行</strong>版本<br>收集算法、对象分配规则、回收策略等都一样，代码很多共用</p><h5 id="CMS-收集器（老年代收集器）"><a href="#CMS-收集器（老年代收集器）" class="headerlink" title="CMS 收集器（老年代收集器）"></a>CMS 收集器（老年代收集器）</h5><p>首次实现了让<strong>垃圾收集线程与用户线程同时工作</strong><br>但是它只能与Serial或者ParNew配合（默认）工作。</p><blockquote><p>相关命令：<br>-XX:+UseConcMarkSweepGC 启用CMS<br>-XX:+/-UseParNewGC 指定或禁止使用ParNew收集器。<br>-XX:ParallelGCThreads 限制垃圾收集的线程数</p></blockquote><p><strong>四个步骤：</strong><br>1 初始标记：标记一下GC Roots能直接关联的对象，速度很快<br>2 并发标记：从上面的直连对象开始遍历整个对象图，不需要STW<br>3 重新标记：修正并发标记期间变动的对象，时间也很短<br>4 并发清除：清除被标记死亡的对象，不需移动存活对象，所以不需要STW<br><strong>步骤1和3会STW</strong></p><p>缺点：<br>1 对处理器资源非常敏感，处理器核心数不足4个时不建议使用<br>2 无法处理“浮动垃圾”— 因为CMS在并发标记和清除时无需停止用户线程，有可能出现本次收集过程中出现新的垃圾对象。<br>由于浮动垃圾的问题，CMS必须预留一些内存空间（并不是老年代满了才进行垃圾回收）。CMS开始执行是到达68%空间后执行<br>3 基于标记-清除算法会产生大量内存碎片<br>解决：在多次进行标记清除后执行一次标记整理<br>-XX:+UseCMS-CompactAtFullCollection 默认开启，JDK9废除<br>-XX:CMSFullGCsBeforeCompaction 默认0，几次标记清除后执行标记整理，JDK9废除</p><h5 id="Parallel-Scavenge-收集器（新生代收集器）"><a href="#Parallel-Scavenge-收集器（新生代收集器）" class="headerlink" title="Parallel Scavenge 收集器（新生代收集器）"></a>Parallel Scavenge 收集器（新生代收集器）</h5><p>与Serial和ParNew一样，都是基于标记-复制算法，也是<strong>多线程并行</strong>的<br>与其他收集器的侧重点不同：其他关注用户线程的停顿时间，而PS侧重于吞吐量=用户代码时间/总消耗时间。<br>自适应调节策略：-XX:+UseAdaptiveSizePolicy。区别于ParNew的一个重要特性</p><h5 id="Serial-Old-收集器（老年代收集器）"><a href="#Serial-Old-收集器（老年代收集器）" class="headerlink" title="Serial Old 收集器（老年代收集器）"></a>Serial Old 收集器（老年代收集器）</h5><p>是Serial收集器的老年代版本。一个<strong>单线程</strong>收集器，基于标记-整理</p><h5 id="Parallel-Old-收集器（老年代收集器）"><a href="#Parallel-Old-收集器（老年代收集器）" class="headerlink" title="Parallel Old 收集器（老年代收集器）"></a>Parallel Old 收集器（老年代收集器）</h5><p>是Parallel Scavenge 收集器的老年代版本。支持<strong>多线程并发</strong>收集，基于标记-整理</p><h5 id="G1-收集器（分区模型）"><a href="#G1-收集器（分区模型）" class="headerlink" title="G1 收集器（分区模型）"></a>G1 收集器（分区模型）</h5><p>JDK9，服务端模式下默认的垃圾收集器，取代PS+PO组合<br>Mixed GC，不区分新生代和老年代，而是把Java堆划分为多个大小相等的独立区域（Region，单次回收的最小单元），看回收哪块内存的收益最大。<br>G1可以根据需要将这些Region扮演成不同的空间，新生代的Eden空间、Survivor空间或者老年代空间和<strong>Humongous空间</strong>，不同的空间采用不同的策略去处理。<br><strong>Humongous空间，专门用来存储大对象（超过一个Region的一半的对象），可以把这个空间理解成老年代的一部分</strong></p><p>可预测停顿时间：<br>因为G1将Region作为单次回收的最小单元。每次回收的内存空间都是Region的整数倍。<br>后台维护了一个优先级列表（优先级，回收的空间和耗时计算得出），优先处理回收价值最大的Region</p><p>问题：<br>1 跨Region引用对象如何解决？ 解决：记忆集<br>2 并发标记阶段如何保证收集线程和用户线程互不干扰？解决：SATB原始快照<br>3 如何建立起可靠的停顿预测模型？解决：衰减均值</p><p>四个步骤：<br>1 初始标记：标记一下GC Roots能直接关联的对象，并修改TAMS指针的值，速度很快<br>2 并发标记：从 GC Root开始对对重的对象进行可达性分析，递归扫描整个对象图<br>3 最终标记：处理并发标记遗留的少量SATB记录<br>4 筛选回收：对各个Region进行优先级排序，<strong>根据用户期望的停顿时间来制定回收计划</strong>，复制部分Region的存活对象到空Region，最后清理Region。必须暂停用户线程。<br><strong>步骤1,3,4都会STW</strong></p><p>缺点：<br>垃圾收集时产生的内存占用和运行时额外执行负载都比CMS高</p><p>与CMS对比总结：<br>哪款收集器好，要针对具体的场景定量比较。小内存应用上CMS的表现会优于G1。反之G1在大内存应用上可以发挥优势。这个平衡点6-8G。<br>不过就趋势而言，随着G1的不断优化，结果必定会向G1倾斜。</p><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>黑色：自己已经标记，且关联对象都标记完成，垃圾回收器不会再查询该节点<br>灰色：自己标记完成，但关联对象未标记<br>白色：没有遍历到的节点</p><p>CMS和G1都是采用三色标记法来标记对象。</p><p>通过之前的介绍，已知在CMS和G1收集器中，并发标记阶段时收集线程和用户线程是同时在工作的。与之对应的步骤三种的问题如下：</p><h5 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h5><blockquote><p>A -&gt; B -&gt; D</p></blockquote><p>并发标记过程中，标记完D节点后，B-&gt;D的引用消失了，产生浮动垃圾。下次垃圾回收器标记时再处理D垃圾</p><h5 id="对象漏标"><a href="#对象漏标" class="headerlink" title="对象漏标"></a>对象漏标</h5><blockquote><p>A -&gt; B<br>A -&gt; D</p></blockquote><p>当A节点被标记为黑色之后，又建立了对D的引用。因为黑色节点不会再被垃圾回收器处理。所以D节点会被垃圾回收器清除</p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>1 CMS对增加引用环节进行处理（Increment Update）<br>当黑色节点新增引用时，把黑色节点编程灰色，这样下次回收器标及时会扫描它的fields节点（但是在多线程标记时依然会出现漏标。<br>所以，CMS的remark阶段，必须从头扫描一遍，会产生严重的STW</p><p>2 G1则对删除引用环节进行处理(SATB 原始快照)</p><h4 id="内存分配与回收策略："><a href="#内存分配与回收策略：" class="headerlink" title="内存分配与回收策略："></a>内存分配与回收策略：</h4><p>1 对象优先在Eden分配<br>2 大对象直接进入老年代<br>    -XX:PretenureSizeThreshold=3M 超过3M的对象直接进入老年代<br>3 长期存活的对象将进入老年代<br>    -XX:MaxTenuringThreshold=15 经历多少次Minor GC后进入老年代<br>4 动态对象年龄判定<br>    如果相同年龄的对象大小总和超过幸存区的一般，那么会将他们以及比他们年龄大的对象都移动到老年代。（不一定等到年龄是15）<br>5 空间分配担保<br>    如果在Minor GC时，老年代并没有足够的空间容纳新进的对象，那么在Minor GC后立刻进行一次Full GC。<br>    开启担保 -XX:HandlePromotionFailure=true 后会判断避免这次Full GC，通常会打开担保</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 类加载器 &amp; 运行时区域</title>
      <link href="2021/02/09/java/"/>
      <url>2021/02/09/java/</url>
      
        <content type="html"><![CDATA[<h4 id="Class-Loader-和-双亲委派机制"><a href="#Class-Loader-和-双亲委派机制" class="headerlink" title="Class Loader 和 双亲委派机制"></a>Class Loader 和 双亲委派机制</h4><p>寻找类加载器：</p><p>AppClassLoader -&gt; ExtClassLoader -&gt; BootstrapClassLoader(c++中)<br>一直找到最上层的加载器后，检查能否加载当前这个类，如果可以则使用当前加载器。否则，抛出异常向下通知子加载器加载。<br>如果没有加载器可以加载这个类，报异常 <code>ClassNotFoundException</code></p><blockquote><p>注意：向上寻找加载器的过程中有一个判断这个类是否已经被加载的过程。如果加载过了就不用重复加载（保证数据安全）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student().getClass().getClassLoader();</span><br><span class="line">s.getClass() <span class="comment">// class com.yy.string.ClassLoaderTest</span></span><br><span class="line">s.getClass().getClassLoader() <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">s.getClass().getClassLoader().getParent() <span class="comment">// sun.misc.Launcher$ExtClassLoader@5ca881b5</span></span><br><span class="line">s.getClass().getClassLoader().getParent().getParent() <span class="comment">// null，在c++中，获取不到</span></span><br></pre></td></tr></table></figure><p>双亲委派机制作用：<br>1 防止重复加载同一个class<br>2 保证源码的class文件不被覆盖篡改（例如:定义一个java.lang.String的类，实例化时依然会加载jdk中的String类）</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jvm.jpg"></p><a id="more"></a><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>一种数据结构：先进后出<br>主管程序的运行，生命周期和线程同步，主线程结束，栈内存就释放了（不存在垃圾回收问题）<br>存放：基本数据类型（8个）、对象引用、实例的方法</p><p><strong>运行原理：栈帧</strong>。先入栈的方法中有一个子栈帧指向后入栈的方法。后入栈的方法有一个父栈帧指向下面的方法。一个方法执行时，会先找子栈帧指向的方法执行。即栈的最上层的方法。<br>栈溢出：StackOverflowError</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>实例变量存在堆内存中<br>这块区域也是垃圾回收器重点管理的区域，由于大多数垃圾回收器都采用 <strong>分代回收算法</strong>，所以堆内存也分为 <code>新生代</code>、<code>老年代</code>，可以方便垃圾的准确回收</p><p>常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-Xms64m 最小堆内存 64m.</span><br><span class="line">-Xmx128m 最大堆内存 128m.</span><br><span class="line">-XX:NewSize&#x3D;30m 新生代初始化大小为30m.</span><br><span class="line">-XX:MaxNewSize&#x3D;40m 新生代最大大小为40m.</span><br><span class="line">-Xss&#x3D;256k 线程栈大小。</span><br><span class="line">-XX:+PrintHeapAtGC 当发生 GC 时打印内存布局。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError 发送内存溢出时 dump 内存。</span><br><span class="line"></span><br><span class="line">新生代和老年代的默认比例为 1:2，也就是说新生代占用 1&#x2F;3的堆内存，而老年代占用 2&#x2F;3 的堆内存。</span><br><span class="line">-XX:NewRatio&#x3D;2 设置老年代&#x2F;新生代的比例。</span><br></pre></td></tr></table></figure><h4 id="堆外内存-直接内存"><a href="#堆外内存-直接内存" class="headerlink" title="堆外内存/直接内存"></a>堆外内存/直接内存</h4><p>虚引用、零拷贝<br>堆外内存不受JVM直接管理，只能借助老年代的fullGC或者调用System.gc()方法回收。（没有配置 -XX:+DisableExplicitGC）</p><p><strong>虚引用</strong>：来管理堆外内存，创建一个堆内的虚引用指向堆外内存的数据。虚引用不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Object&gt; LIST = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;M&gt; QUEUE = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PhantomReference&lt;M&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(<span class="keyword">new</span> M(), QUEUE);</span><br><span class="line">    phantomReference.get(); <span class="comment">// get不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那堆外内存什么时候回收？<br>堆内的虚引用被回收时会被加入到队列中，当系统检测到这个队列中有记录时，会调用Hotspot级别的回收方法（Cleaner类继承于PhantomReference，会有一个unsafe free方法）</p></blockquote><p><strong>零拷贝</strong>：例如在 Netty 中所有的 IO（nio） 操作都会通过 Native 函数直接分配堆外内存。<br>它是通过在堆内存中的 DirectByteBuffer 对象操作的堆外内存，避免了堆内存和堆外内存来回复制交换复制，这样的高效操作也称为零拷贝。</p><h4 id="方法区-元数据区-JDK1-8-metaspace"><a href="#方法区-元数据区-JDK1-8-metaspace" class="headerlink" title="方法区/元数据区(JDK1.8 metaspace)"></a>方法区/元数据区(JDK1.8 metaspace)</h4><p>存放：静态变量static、常量final、类信息class（构造方法、接口定义）、运行时的常量池存在方法区中。<br>这块区域也被成为永久代（从JDK1.7开始，提出了“去永久代”概念。并在JDK1.8中完全使用元空间来代替永久代）</p><blockquote><p>1.8之前<br>可利用参数 <code>-XX:PermSize</code>,<code>-XX:MaxPermSize</code> 控制初始化方法区和最大方法区大小。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        set.add(String.valueOf(i++ * <span class="number">1024</span>).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会导致运行时常量池内存溢出: java.lang.OutOfMemoryError: PermGen。</p><blockquote><p>JDK1.8之后<br>元数据区域会根据使用情况动态调整，避免了在 1.7 中由于加载类过多从而出现 java.lang.OutOfMemoryError: PermGen。<br>但也不能无限扩展，因此可以使用 -XX:MaxMetaspaceSize来控制最大内存。</p></blockquote><h5 id="intern-常量池变化"><a href="#intern-常量池变化" class="headerlink" title="intern 常量池变化"></a>intern 常量池变化</h5><p>先说结论：<br>在JDK1.6，常量池在永久代中分配，与堆是物理隔离的。<br>来到JDK1.7以后，常量池在堆中分配。</p><p>这个结论可以通过过 <code>intern()</code> 方法来验证一下：<br>intern方法，会在字符串常量池中检查是否包含，如果包含则把池中的字符串引用返回，如果不包含就把字符串加进常量池中，并返回字符串实例对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;j&quot;</span>).append(<span class="string">&quot;avazs&quot;</span>);</span><br><span class="line">String s1 = builder.toString();</span><br><span class="line">System.out.println(s1 == s1.intern()); <span class="comment">// true，返回的&quot;javazs&quot;是s1对象的引用</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;javazs&quot;</span>);</span><br><span class="line">System.out.println(s2 == s2.intern()); <span class="comment">// false，返回的&quot;javazs&quot;是s1对象的引用</span></span><br></pre></td></tr></table></figure><p><strong>上面这个代码示例在JDK1.6和JDK1.7以后的结果不同：JDK1.6中前后两处都输出false，JDK1.7以后第一个输出true，第二个输出false。</strong></p><p>原因分析：</p><p>在JDK1.6中，s1创建的实例要存入常量池中，因为常量池与堆是物理隔离的。所以要进行一个复制操作。<br>最后intern方法返回的引用时常量池中的引用，而s1引用分配在堆中。所以必然是不等的。<br>同理第二次intern方法返回的是常量池中已存在的引用，与s2也必然是不等的。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/1.6_intern.png"></p><p>在JDK1.7以后，常量池在堆中分配，所以第一次intern方法只要记录一下s1实例的引用并返回即可。所以第一次会返回true。<br>但是第二次intern方法依然是返回s1的引用。与s2也必然是不等的。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/1.7_intern.png"></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>登记native关键字修饰的方法。底层库中方法的调用，借助 <strong>本地库接口（JNI）</strong> </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Runtime Data Area </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有感</title>
      <link href="2021/02/04/jianshu-5years/"/>
      <url>2021/02/04/jianshu-5years/</url>
      
        <content type="html"><![CDATA[<blockquote><p>再牛逼的技术，也抵不过傻逼似的坚持</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jianshu-5years.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Guava 实用篇（持续更新）</title>
      <link href="2021/02/01/guava-usable/"/>
      <url>2021/02/01/guava-usable/</url>
      
        <content type="html"><![CDATA[<h4 id="字符串-amp-集合处理-Splitter-Joiner"><a href="#字符串-amp-集合处理-Splitter-Joiner" class="headerlink" title="字符串&amp;集合处理 Splitter Joiner"></a>字符串&amp;集合处理 <code>Splitter</code> <code>Joiner</code></h4><p>最近在对接JD商城，商品详情的和分类的对应关系是一个字符串（包含3级分类，用分号分隔），Guava中提供了一个比较简单的处理方式</p><h5 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将string分解成list</span></span><br><span class="line">Iterable&lt;String&gt; split = Splitter.on(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        .trimResults()</span><br><span class="line">        .omitEmptyStrings()</span><br><span class="line">        .split(<span class="string">&quot;170;1238 ; ;   2218&quot;</span>);</span><br><span class="line">split.forEach(item -&gt; &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将list连接成string</span></span><br><span class="line">String join = Joiner.on(<span class="string">&quot;;&quot;</span>).skipNulls().join(split);</span><br><span class="line">System.out.println(<span class="string">&quot;join = &quot;</span> + join);</span><br></pre></td></tr></table></figure><p>分析一下 <code>Joiner</code> 的源码，<code>Splitter</code>类似。</p><p>Joiner类中主要包含 <strong>构造方法</strong>、<strong>appendTo方法</strong>、<strong>join方法</strong>。以及一系列他们的方法重载。</p><p>就以 <code>Joiner.on(&quot;;&quot;).skipNulls().join(split)</code> 这段代码为例：</p><h6 id="on"><a href="#on" class="headerlink" title="on()"></a>on()</h6><p>创建Joiner对象，并记录分隔用的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Joiner <span class="title">on</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Joiner(separator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Joiner</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.separator = checkNotNull(separator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的就是 <code>checkNotNull()</code> 方法。这是Guava提供的 <code>null</code> 值过滤的方法。这个方法在Guava官方手册的第一章节介绍。</p><h6 id="skipNulls"><a href="#skipNulls" class="headerlink" title="skipNulls()"></a>skipNulls()</h6><p>之前提到过Joiner类中主要包含的执行逻辑的方法：appendTo方法。</p><p>Guava通过链式编程的思想，在skipNulls()方法中返回了一个匿名内部类，在匿名内部类中重写了处理逻辑的appendTo方法，提供了过滤集合null值的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Joiner <span class="title">skipNulls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Joiner(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;A extends Appendable&gt; <span class="function">A <span class="title">appendTo</span><span class="params">(A appendable, Iterator&lt;?&gt; parts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            checkNotNull(appendable, <span class="string">&quot;appendable&quot;</span>);</span><br><span class="line">            checkNotNull(parts, <span class="string">&quot;parts&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (parts.hasNext()) &#123;</span><br><span class="line">                Object part = parts.next();</span><br><span class="line">                <span class="keyword">if</span> (part != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    appendable.append(Joiner.<span class="keyword">this</span>.toString(part));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (parts.hasNext()) &#123;</span><br><span class="line">            Object part = parts.next();</span><br><span class="line">                <span class="keyword">if</span> (part != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    appendable.append(separator);</span><br><span class="line">                    appendable.append(Joiner.<span class="keyword">this</span>.toString(part));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> appendable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Joiner <span class="title">useForNull</span><span class="params">(String nullText)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;already specified skipNulls&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MapJoiner <span class="title">withKeyValueSeparator</span><span class="params">(String kvs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;can&#x27;t use .skipNulls() with maps&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名内部类中重写了 <code>appendTo</code> 方法，加入了两处 <code>null</code> 值的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (part != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>这个方法接收传入的集合，然后内部调用 <code>appendTo</code> 方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">join</span><span class="params">(Iterator&lt;?&gt; parts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendTo(<span class="keyword">new</span> StringBuilder(), parts).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里接收的参数类型是 <code>Iterator&lt;?&gt;</code> 接口。</p><p>涵盖了我们日常使用的所有集合类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* @see     Set</span><br><span class="line">* @see     List</span><br><span class="line">* @see     Map</span><br><span class="line">* @see     SortedSet</span><br><span class="line">* @see     SortedMap</span><br><span class="line">* @see     HashSet</span><br><span class="line">* @see     TreeSet</span><br><span class="line">* @see     ArrayList</span><br><span class="line">* @see     LinkedList</span><br><span class="line">* @see     Vector</span><br><span class="line">* @see     Collections</span><br><span class="line">* @see     Arrays</span><br><span class="line">* @see     AbstractCollection</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="缓存-CacheLoader"><a href="#缓存-CacheLoader" class="headerlink" title="缓存 CacheLoader"></a>缓存 <code>CacheLoader</code></h4><p>Guava 提供了一个缓存方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (CacheLoader) (key) -&gt; &#123;&#125;</span></span><br><span class="line">    <span class="keyword">private</span> CacheLoader cacheLoader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 如果找不到元素，会调用这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到 = &quot;</span> + key);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 模拟：去数据库查询/远程调用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String value = getValue();</span><br><span class="line">            loadingCache.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">1000</span>) <span class="comment">// 容量</span></span><br><span class="line">        .expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS) <span class="comment">// 过期时间</span></span><br><span class="line">        .removalListener(<span class="keyword">new</span> TestRemovalListener()) <span class="comment">// 失效监听器</span></span><br><span class="line">        .build(cacheLoader);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRemovalListener</span> <span class="keyword">implements</span> <span class="title">RemovalListener</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; notification)</span> </span>&#123;</span><br><span class="line">        String reason = String.format(<span class="string">&quot;key=%s,value=%s,reason=%s&quot;</span>, notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(<span class="string">&quot;reason:&quot;</span> + reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在LoadCache类中维护了一个AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table</p><p>具体的源码我还没有仔细看。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> String </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>feign GET 异常</title>
      <link href="2021/01/29/feign-GET/"/>
      <url>2021/01/29/feign-GET/</url>
      
        <content type="html"><![CDATA[<p>只要参数是复杂对象，即使指定了是GET方法，feign依然会以POST方法进行发送请求；</p><p>如果不加默认的注解，Feign则会对参数默认加上@RequestBody注解，而RequestBody一定是包含在请求体中的，GET方式无法包含</p><p>所以会发生 <code>method GET must not have a request body</code> 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Request.<span class="function">Builder <span class="title">method</span><span class="params">(String method, <span class="meta">@Nullable</span> RequestBody body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;method == null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method.length() == 0&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body != <span class="keyword">null</span> &amp;&amp; !HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method &quot;</span> + method + <span class="string">&quot; must not have a request body.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body == <span class="keyword">null</span> &amp;&amp; HttpMethod.requiresRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method &quot;</span> + method + <span class="string">&quot; must have a request body.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：<br>GET请求传递封装好的对象时，使用 <code>@RequestParam</code> 修饰 <code>Map&lt;String, Object&gt; </code>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Clound </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 三级缓存中 SingletonFactories 作用？</title>
      <link href="2021/01/27/spring-cache-singletonfactories/"/>
      <url>2021/01/27/spring-cache-singletonfactories/</url>
      
        <content type="html"><![CDATA[<p>Spring 为什么要设计三级缓存？<br>其中SingletonFactories工厂的作用是什么？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/singletonFactories.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 三级缓存 </tag>
            
            <tag> SingletonFactories </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式在源码中的应用</title>
      <link href="2021/01/22/patterns/"/>
      <url>2021/01/22/patterns/</url>
      
        <content type="html"><![CDATA[<p>举例一下常用设计模式在源码中的使用，帮助学习。</p><p><strong>静态工厂方法</strong><br>Calendar.getInstance()<br>java.text.NumberFormat.getInstance()<br>java.util.ResourceBundle.getBundle()</p><p><strong>工厂方法（获取实际对象）</strong><br>java.net.URLStreamHandlerFactory<br>javax.xml.bind.JAXBContext.createMarshaller</p><p><strong>抽象工厂模式（先获取工厂、再获取实际对象）</strong><br>java.sql.Connection<br>java.sql.Driver</p><p><strong>建造者模式</strong><br>Spring源码中应用<br>org.springframework.web.servlet.mvc.method.RequestMappingInfo<br>org.springframework.beans.factory.support.BeanDefinitionBuilder</p><p><strong>原型模式（hashtable、继承Cloneable）</strong><br>java.util.Arrays<br>org.springframework.beans.factory.support.AbstractBeanDefinition</p><p><strong>享元模式（hashmap）</strong><br>String\Integer\Long..<br>com.sun.org.apache.bcel.internal.generic.InstructionContstants</p><p><strong>门面模式、外观模式</strong><br>org.apache.catalina.connector.RequestFacade</p><p><strong>观察者模式</strong><br>java.util.Observable<br>org.springframework.context.ApplicationListener</p><p><strong>适配器模式</strong><br>Arrays#adList()\Collections#list()<br>org.springframework.context.event.GenericApplicationListenerAdapter</p><p><strong>装饰者模式</strong><br>javax.servlet.http.HttpServletRequestWrapper<br>javax.servlet.http.HttpServletResponseWrapper</p><p><strong>策略模式</strong><br>java.util.Comparator<br>org.springframework.beans.factory.support.InstantiationStrategy</p><p><strong>模板方法模式</strong><br>javax.servlet.http.HttpServlet<br>org.springframework.web.servlet.mvc.AbstractController</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 你没见过的单例写法</title>
      <link href="2021/01/20/nsingleton/"/>
      <url>2021/01/20/nsingleton/</url>
      
        <content type="html"><![CDATA[<p><strong>分享两种新鲜的单例写法</strong></p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * JVM保证单例、懒加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元素枚举类"><a href="#单元素枚举类" class="headerlink" title="单元素枚举类"></a>单元素枚举类</h4><p>出自 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual">Effective-Java</a> 书籍中的 <code>Chapter 2 Item 3: Enforce the singleton property with a private constructor or an enum type</code></p><p>这里给大家分享这本书的在线汉化版本，非常建议花时间学习一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式创建的单例不仅可以解决 <strong>线程同步问题</strong>，还可以 <strong>防止反序列化</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
            <tag> 静态内部类 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象存储和指针逃逸</title>
      <link href="2021/01/20/new-Object/"/>
      <url>2021/01/20/new-Object/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在 <a href="https://yloopdaed.icu/2020/10/29/memory-layout-of-java-object/">Java对象的内存布局</a> 文章的末尾提到了对象的存储位置，现在扩展一下之前的内容。</p><h3 id="对象存储在堆上还是栈上？"><a href="#对象存储在堆上还是栈上？" class="headerlink" title="对象存储在堆上还是栈上？"></a>对象存储在堆上还是栈上？</h3><p>看下面这段代码，循环创建一亿次Object对象，通常理解一个空Object对象创建会在栈中存在一个4字节的指针，指向堆中的对象16字节。<br>循环创建一亿次大概会占用1.6G的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    new Object();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 38ms</p></blockquote><p><strong><em>这是为什么？</em></strong></p><h3 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h3><p>判断对象是否在堆中进行分配有一个前提：<strong>判断逃逸状态</strong></p><h4 id="全局逃逸（GlobalEscape）"><a href="#全局逃逸（GlobalEscape）" class="headerlink" title="全局逃逸（GlobalEscape）"></a>全局逃逸（GlobalEscape）</h4><p>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p><p>1 对象是一个静态变量</p><p>2 对象是一个已经发生逃逸的对象</p><p>3 对象作为当前方法的返回值</p><h4 id="参数逃逸（ArgEscape）"><a href="#参数逃逸（ArgEscape）" class="headerlink" title="参数逃逸（ArgEscape）"></a>参数逃逸（ArgEscape）</h4><p>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</p><h4 id="没有逃逸"><a href="#没有逃逸" class="headerlink" title="没有逃逸"></a>没有逃逸</h4><p>即方法中的对象没有发生逃逸</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>JVM默认会开启逃逸分析 <code>-XX:+DoEscapeAnalysis</code></p><p>开启逃逸分析后，如果JVM分析得到对象 <strong>没有发生逃逸</strong> 的话，那么 <code>new Object()</code> 新建的对象并没有在外部被使用，所以它被优化为在栈上分配，我们知道方法执行完成后该栈帧就会被清空，所以也就不会有GC。</p><p><strong>反之：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    Object o &#x3D; new Object();</span><br><span class="line">    o.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 8014ms</p></blockquote><p>会使对象发生逃逸的常见方式：</p><p>1 对象被赋值给堆中对象的字段和类的静态变量</p><p>2 对象被传进了不确定的代码中去运行</p><h3 id="基于逃逸分析的优化"><a href="#基于逃逸分析的优化" class="headerlink" title="基于逃逸分析的优化"></a>基于逃逸分析的优化</h3><p>也就是基于JVM逃逸分析机制对代码进行一些优化，提升代码的性能。</p><p>这部分内容可以参考：<a href="https://zhuanlan.zhihu.com/p/59215831">JVM之逃逸分析</a></p><hr><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/NewObject类中查看。</p><p>结论: JVM虚拟机逃逸分析是默认开启的，对象不会逃逸的时候优先在栈上分配，否则在堆上分配。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆、栈 </tag>
            
            <tag> 指针逃逸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个线程池封装背后</title>
      <link href="2021/01/19/custom-thread-pool/"/>
      <url>2021/01/19/custom-thread-pool/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要自定义线程池"><a href="#为什么要自定义线程池" class="headerlink" title="为什么要自定义线程池"></a>为什么要自定义线程池</h4><p>Java <code>Executors</code> 为我们构建线程池提供了几种的静态工厂方法。功能强大、简单易用、工厂模式等。看上去是个不错的选择。</p><p><strong>但是，这些线程池的使用可能会造成严重的后果。</strong></p><p>话题要从 <a href="https://zhuanlan.zhihu.com/p/32867181">一次Java线程池误用引发的血案和总结</a> 引出。头条的系统中由于使用了 <code>newFixedThreadPool</code> 造成了服务器内存溢出熔断</p><p>同时，阿里在 <strong>嵩山版Java开发手册</strong> 中也【强制】不允许使用Executors去创建线程池。</p><p>那么问题究竟出在哪里呢？</p><a id="more"></a><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>1 interface Executor<br>2 interface ExecutorService extends Executor<br>3 abstract class AbstractExecutorService implements ExecutorService<br>4 class ThreadPoolExecutor extends AbstractExecutorService</p><h5 id="ThreadPoolExecutor-构造方法"><a href="#ThreadPoolExecutor-构造方法" class="headerlink" title="ThreadPoolExecutor 构造方法"></a>ThreadPoolExecutor 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>1 int corePoolSize  核心线程数</p><p>2 int maximumPoolSize  最大线程数</p><p>3 long keepAliveTime  非核心线程数空闲时等待的时间</p><p>4 TimeUnit unit       keepAliveTime 的时间单位</p><p>5 BlockingQueue<Runnable> workQueue   阻塞队列<br>    在任意时刻，不管并发有多高，永远只有一个线程能够进行队列的入队或者出队操作！（线程安全）<br>    5.1 ArrayBlockingQueue 数组结构的有界阻塞队列<br>    5.2 LinkedBlockingQueue 链表结构的有界阻塞队列<br>    5.3 DelayQueue    队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。<br>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>    5.4 PriorityBlockingQueue 基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。<br>    5.5 SynchronousQueue  这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p><p>6 ThreadFactory threadFactory 线程工厂</p><p>7 RejectedExecutionHandler handler  拒绝策略<br>    AbortPolicy 抛异常<br>    CallerRunsPolicy<br>    DiscardOldestPolicy<br>    DiscardPolicy 丢弃任务</p><h5 id="线程池状态及AtomicInteger-ctl"><a href="#线程池状态及AtomicInteger-ctl" class="headerlink" title="线程池状态及AtomicInteger ctl"></a>线程池状态及AtomicInteger ctl</h5><p>ThreadPoolExecutor类中定义了一个volatile int变量runState来表示线程池的状态</p><p>1 running  能接受新任务以及处理已添加的任务<br>2 shutdown    不接受新任务，可以处理已经添加的任务<br>3 stop    不接受新任务，不处理已经添加的任务，并且中断正在处理的任务<br>4 tidying    所有的任务已经终止，ctl记录的任务数量为0，ctl负责记录线程池的运行状态与活动线程数量<br>5 terminated    线程池彻底终止</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pool%20runstate.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>AtomicInteger ctl<br>共32位<br>高3位记录线程池生命状态<br>后29位记录当前工作线程数</p><h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二次判断：</p><p>在多线程环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程状态立即就发生改变。</p><p>判断是否将command加入workqueue是线程池之前的状态，倘若没有二次检查，如果线程池处于非RUNNING状态，那么command永远不会执行。</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>详细：<br>1 线程总数量 &lt; corePoolSize，新建一个核心线程执行任务<br>2 线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待（线程复用）<br>3 当缓存队列满了，会创建非核心线程去执行任务<br>4 总线程数达到了maximumPoolSize，拒绝策略处理</p><p>流程(先后):<br>核心线程-&gt;队列-&gt;最大线程-&gt;拒绝策略</p><h5 id="为什么不安全？"><a href="#为什么不安全？" class="headerlink" title="为什么不安全？"></a>为什么不安全？</h5><p>前面铺垫了这么多，我们来看为什么Java提供的线程池不安全。</p><p><strong>1 newFixedThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 newSingleThreadExecutor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式创建的线程池对象设置的 <code>缓冲队列</code> 为 <code>LinkedBlockingQueue</code>，长度为 <code>Integer.MAX_VALUE</code>。所以几乎不会触发拒绝策略。当大量请求堆积时会造成OOM。</p><p><strong>3 newCachedThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 ScheduledThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式创建的线程池对象设置的 <code>最大线程池数量</code> 为 <code>Integer.MAX_VALUE</code>。所以几乎不会触发拒绝策略。当大量请求堆积时会造成OOM。</p><h4 id="封装一个简易的线程池"><a href="#封装一个简易的线程池" class="headerlink" title="封装一个简易的线程池"></a>封装一个简易的线程池</h4><p>借助开源类库 <code>apache</code> 和 <code>guava</code> 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 线程池维护线程的最少数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minPoolSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/** 线程池维护线程的最大数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/** 线程池维护线程所允许的空闲时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleSeconds = <span class="number">1800</span>;</span><br><span class="line">    <span class="comment">/** 线程池所使用的缓冲队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueBlockSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor executor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolTools</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;custom-create-thread-%d&quot;</span>).build(); <span class="comment">// guava</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executor = <span class="keyword">new</span> ThreadPoolExecutor(minPoolSize, maxPoolSize, idleSeconds,</span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">/* 时间单位,秒 */</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueBlockSize),</span><br><span class="line">                namedThreadFactory,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()); <span class="comment">/* 重试添加当前加入失败的任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> </p><h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadPoolTools threadPoolTools = <span class="keyword">new</span> ThreadPoolTools();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            threadPoolTools.execute(ExecutorsTest::run);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolTools.executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!threadPoolTools.executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程还在执行。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;一共处理了:&quot;</span>+ (end - start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的使用方式不仅可以避免OOM的问题，也方便通过自定义的线程名称查看日志信息。</p><h4 id="用spring管理线程池"><a href="#用spring管理线程池" class="headerlink" title="用spring管理线程池"></a>用spring管理线程池</h4><p>这种写法更为常见，使用更便利。一般可以配合线上的 <code>服务配置</code> 达到动态线程池的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交给Spring管理</span></span><br><span class="line"><span class="comment">     * 参数自行配置，也可以交给 服务配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(value = &quot;customThreadPool&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildCustomThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;custom-create-thread-%d&quot;</span>).build(); <span class="comment">// guava</span></span><br><span class="line"></span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">50</span>),namedThreadFactory,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
            <tag> guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 查询笔记</title>
      <link href="2021/01/08/rabbitmq/"/>
      <url>2021/01/08/rabbitmq/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此文档在 <a href="https://www.baizhiedu.xin/front/index#/main">百知</a> 的RabbitMQ视频教程笔记基础上改动而来。</p></blockquote><h2 id="MQ引言"><a href="#MQ引言" class="headerlink" title="MQ引言"></a>MQ引言</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p><code>MQ</code>(Message Quene) :  翻译为 <code>消息队列</code>,通过典型的 <code>生产者</code>和<code>消费者</code>模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 <code>消息中间件</code>    通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><h3 id="MQ有哪些"><a href="#MQ有哪些" class="headerlink" title="MQ有哪些"></a>MQ有哪些</h3><p>当今市面上有很多主流的消息中间件，如老牌的<code>ActiveMQ</code>、<code>RabbitMQ</code>，炙手可热的<code>Kafka</code>，阿里巴巴自主开发<code>RocketMQ</code>等。</p><h3 id="不同MQ特点"><a href="#不同MQ特点" class="headerlink" title="不同MQ特点"></a>不同MQ特点</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**1.ActiveMQ**</span></span><br><span class="line">ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!</span><br><span class="line"></span><br><span class="line"><span class="strong">**2.Kafka**</span></span><br><span class="line">Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。</span><br><span class="line"></span><br><span class="line"><span class="strong">**3.RocketMQ**</span></span><br><span class="line">RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。</span><br><span class="line"></span><br><span class="line"><span class="strong">**4.RabbitMQ**</span></span><br><span class="line">RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</span><br></pre></td></tr></table></figure><blockquote><p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p></blockquote><a id="more"></a><hr><h2 id="RabbitMQ-的引言"><a href="#RabbitMQ-的引言" class="headerlink" title="RabbitMQ 的引言"></a>RabbitMQ 的引言</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><blockquote><p>基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190925215603036-9419777.png"></p><p><code>官网</code>: <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p><code>官方教程</code>: <a href="https://www.rabbitmq.com/#getstarted">https://www.rabbitmq.com/#getstarted</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**AMQP 协议**</span></span><br><span class="line">AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是</span><br></pre></td></tr></table></figure><p>AMQP协议模型:<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200311182438041.png"></p><h3 id="RabbitMQ-的安装"><a href="#RabbitMQ-的安装" class="headerlink" title="RabbitMQ 的安装"></a>RabbitMQ 的安装</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><code>官网下载地址</code>: <a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190925220115235.png"></p><blockquote><p><code>最新版本</code>: 3.7.18</p></blockquote><h4 id="下载的安装包"><a href="#下载的安装包" class="headerlink" title="下载的安装包"></a>下载的安装包</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190925220343521.png"></p><blockquote><p><code>注意</code>:这里的安装包是centos7安装的包</p></blockquote><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**1.将rabbitmq安装包上传到linux系统中**</span></span><br><span class="line"><span class="code">erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code">rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**2.安装Erlang依赖包**</span></span><br><span class="line"><span class="code">rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**3.安装RabbitMQ安装包(需要联网)**</span></span><br><span class="line"><span class="code">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span></span><br><span class="line"><span class="code">注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**4.复制配置文件**</span></span><br><span class="line"><span class="code">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**5.查看配置文件位置**</span></span><br><span class="line"><span class="code">ls /etc/rabbitmq/rabbitmq.config</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**6.修改配置文件(参见下图:)**</span></span><br><span class="line"><span class="code">vim /etc/rabbitmq/rabbitmq.config </span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190925222230260-3836271.png"></p><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190925222329200-3836312.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**7.执行如下命令,启动rabbitmq中的插件管理**</span></span><br><span class="line"><span class="code">rabbitmq-plugins enable rabbitmq_management</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">出现如下说明:</span></span><br><span class="line"><span class="code">  Enabling plugins on node rabbit@localhost:</span></span><br><span class="line"><span class="code">  rabbitmq_management</span></span><br><span class="line"><span class="code">  The following plugins have been configured:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    rabbitmq_management_agent</span></span><br><span class="line"><span class="code">    rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code">  Applying plugin configuration to rabbit@localhost...</span></span><br><span class="line"><span class="code">  The following plugins have been enabled:</span></span><br><span class="line"><span class="code">    rabbitmq_management</span></span><br><span class="line"><span class="code">    rabbitmq_management_agent</span></span><br><span class="line"><span class="code">    rabbitmq_web_dispatch</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">  set 3 plugins.</span></span><br><span class="line"><span class="code">  Offline change; changes will take effect at broker restart.</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**8.启动RabbitMQ的服务**</span></span><br><span class="line"><span class="code">systemctl start rabbitmq-server</span></span><br><span class="line"><span class="code">systemctl restart rabbitmq-server</span></span><br><span class="line"><span class="code">systemctl stop rabbitmq-server</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**9.查看服务状态(见下图:)**</span></span><br><span class="line"><span class="code">systemctl status rabbitmq-server</span></span><br><span class="line"><span class="code">  rabbitmq-server.service - RabbitMQ broker</span></span><br><span class="line"><span class="code">    Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class="line"><span class="code">    Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span></span><br><span class="line"><span class="code">  Main PID: 2904 (beam.smp)</span></span><br><span class="line"><span class="code">    Status: &quot;Initialized&quot;</span></span><br><span class="line"><span class="code">    CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class="line"><span class="code">      ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span></span><br><span class="line"><span class="code">      MBlmbcs...</span></span><br><span class="line"><span class="code">      ├─3220 erl_child_setup 32768</span></span><br><span class="line"><span class="code">      ├─3243 inet_gethost 4</span></span><br><span class="line"><span class="code">      └─3244 inet_gethost 4</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190925222743776-3836511.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**10.关闭防火墙服务**</span></span><br><span class="line"><span class="code">systemctl disable firewalld</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span></span><br><span class="line"><span class="code">    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span></span><br><span class="line"><span class="code">systemctl stop firewalld   </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**11.访问web管理界面**</span></span><br><span class="line"><span class="code">http://localhost:15672/</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190926194738708-3836601.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**12.登录管理界面**</span></span><br><span class="line"><span class="code">username:  guest</span></span><br><span class="line"><span class="code">password:  guest</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20190926194954822-3836665.png"></p><hr><h3 id="RabiitMQ-配置"><a href="#RabiitMQ-配置" class="headerlink" title="RabiitMQ 配置"></a>RabiitMQ 配置</h3><h4 id="RabbitMQ-管理命令行"><a href="#RabbitMQ-管理命令行" class="headerlink" title="RabbitMQ 管理命令行"></a>RabbitMQ 管理命令行</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**1.服务启动相关**</span></span><br><span class="line">  systemctl start|restart|stop|status rabbitmq-server</span><br><span class="line"></span><br><span class="line"><span class="strong">**2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ**</span></span><br><span class="line"><span class="code">rabbitmqctl  help  可以查看更多命令</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">**3.插件管理命令行**</span></span><br><span class="line"><span class="code">rabbitmq-plugins enable|list|disable </span></span><br></pre></td></tr></table></figure><h3 id="web管理界面介绍"><a href="#web管理界面介绍" class="headerlink" title="web管理界面介绍"></a>web管理界面介绍</h3><h4 id="overview概览"><a href="#overview概览" class="headerlink" title="overview概览"></a>overview概览</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126162026720.png"></p><p>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况<br>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。<br>Exchanges：交换机，用来实现消息的路由<br>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</p><h4 id="Admin用户和虚拟主机管理"><a href="#Admin用户和虚拟主机管理" class="headerlink" title="Admin用户和虚拟主机管理"></a>Admin用户和虚拟主机管理</h4><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126162617280.png"></p><p>上面的Tags选项，其实是指定用户的角色，可选的有以下几个：</p><ul><li><p><code>超级管理员(administrator)</code></p><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p></li><li><p><code>监控者(monitoring)</code></p><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p></li><li><p><code>策略制定者(policymaker)</code></p><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p></li><li><p><code>普通管理者(management)</code></p><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p></li><li><p><code>其他</code></p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p></li></ul><h5 id="创建虚拟主机"><a href="#创建虚拟主机" class="headerlink" title="创建虚拟主机"></a>创建虚拟主机</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**虚拟主机**</span></span><br><span class="line"><span class="code">为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126163023153.png"></p><h5 id="绑定虚拟主机和用户"><a href="#绑定虚拟主机和用户" class="headerlink" title="绑定虚拟主机和用户"></a>绑定虚拟主机和用户</h5><p>创建好虚拟主机，我们还要给用户添加访问权限：</p><p>点击添加好的虚拟主机：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126163506795.png"></p><p>进入虚拟机设置界面:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126163631889.png"></p><hr><h2 id="RabbitMQ-的第一个程序"><a href="#RabbitMQ-的第一个程序" class="headerlink" title="RabbitMQ 的第一个程序"></a>RabbitMQ 的第一个程序</h2><h3 id="AMQP协议的回顾"><a href="#AMQP协议的回顾" class="headerlink" title="AMQP协议的回顾"></a>AMQP协议的回顾</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200312140114784.png"></p><h3 id="RabbitMQ支持的消息模型"><a href="#RabbitMQ支持的消息模型" class="headerlink" title="RabbitMQ支持的消息模型"></a>RabbitMQ支持的消息模型</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126165434784.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126165459282.png"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第一种模型-直连"><a href="#第一种模型-直连" class="headerlink" title="第一种模型(直连)"></a>第一种模型(直连)</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126165840602.png"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><h4 id="开发生产者"><a href="#开发生产者" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;10.15.0.9&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">//创建通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"><span class="comment">//参数1: 是否持久化  参数2:是否独占队列 参数3:是否自动删除  参数4:其他属性</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>, <span class="keyword">null</span>,<span class="string">&quot;hello rabbitmq&quot;</span>.getBytes());</span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h4 id="开发消费者"><a href="#开发消费者" class="headerlink" title="开发消费者"></a>开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;10.15.0.9&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;ems&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/ems&quot;</span>);</span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="参数的说明"><a href="#参数的说明" class="headerlink" title="参数的说明"></a>参数的说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="string">&#x27;参数1&#x27;</span>:用来声明通道对应的队列</span><br><span class="line"><span class="string">&#x27;参数2&#x27;</span>:用来指定是否持久化队列</span><br><span class="line"><span class="string">&#x27;参数3&#x27;</span>:用来指定是否独占队列</span><br><span class="line"><span class="string">&#x27;参数4&#x27;</span>:用来指定是否自动删除队列</span><br><span class="line"><span class="string">&#x27;参数5&#x27;</span>:对队列的额外配置</span><br></pre></td></tr></table></figure><hr><h3 id="第二种模型-work-quene"><a href="#第二种模型-work-quene" class="headerlink" title="第二种模型(work quene)"></a>第二种模型(work quene)</h3><p><code>Work queues</code>，也被称为（<code>Task queues</code>），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200314221002008.png"></p><p>角色：</p><ul><li>P：生产者：任务的发布者</li><li>C1：消费者-1，领取任务并且完成任务，假设完成速度较慢</li><li>C2：消费者-2：领取任务并完成任务，假设完成速度快</li></ul><h4 id="开发生产者-1"><a href="#开发生产者-1" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, (i+<span class="string">&quot;====&gt;:我是消息&quot;</span>).getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MessageProperties.PERSISTENT_TEXT_PLAIN 数据持久化</span></span><br></pre></td></tr></table></figure><h4 id="开发消费者-1"><a href="#开发消费者-1" class="headerlink" title="开发消费者-1"></a>开发消费者-1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="开发消费者-2"><a href="#开发消费者-2" class="headerlink" title="开发消费者-2"></a>开发消费者-2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);   <span class="comment">//处理消息比较慢 一秒处理一个消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200314223242058.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200314223302207.png"></p><blockquote><p><code>总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</code></p></blockquote><h4 id="消息自动确认机制"><a href="#消息自动确认机制" class="headerlink" title="消息自动确认机制"></a>消息自动确认机制</h4><blockquote><p>Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled.</p><p>But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);<span class="comment">//一次只接受一条未确认的消息</span></span><br><span class="line"><span class="comment">//参数2:autoAsk 关闭自动确认消息</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="keyword">false</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">      <span class="comment">// 参数1: 确认队列中的具体消息</span></span><br><span class="line">      <span class="comment">// 参数2: 是否开启多个消息同时确认</span></span><br><span class="line">    channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);<span class="comment">//手动确认消息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>设置通道一次只能消费一个消息</p></li><li><p>关闭消息的自动确认,开启手动确认消息</p></li></ul><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200314230412178.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200314230423280.png"></p><p>达成结果：</p><p>1 能者多劳</p><p>2 消息不丢失</p><hr><h3 id="第三种模型-fanout"><a href="#第三种模型-fanout" class="headerlink" title="第三种模型(fanout)"></a>第三种模型(fanout)</h3><p><code>fanout 扇出 也称为广播</code></p><p> <img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126213115873.png"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li> 可以有多个消费者</li><li> 每个<strong>消费者有自己的queue</strong>（队列）</li><li> 每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li> <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li> 交换机把消息发送给绑定过的所有队列</li><li> 队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ul><h4 id="开发生产者-2"><a href="#开发生产者-2" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);<span class="comment">//广播 一条消息多个消费者同时消费</span></span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,<span class="string">&quot;hello&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><h4 id="开发消费者-1-1"><a href="#开发消费者-1-1" class="headerlink" title="开发消费者-1"></a>开发消费者-1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//将临时队列绑定exchange</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="开发消费者-2-1"><a href="#开发消费者-2-1" class="headerlink" title="开发消费者-2"></a>开发消费者-2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//将临时队列绑定exchange</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="开发消费者-3"><a href="#开发消费者-3" class="headerlink" title="开发消费者-3"></a>开发消费者-3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//将临时队列绑定exchange</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//处理消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者3: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200315180653207.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200315180708489.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200315180728035.png"></p><hr><h3 id="第四种模型-Routing"><a href="#第四种模型-Routing" class="headerlink" title="第四种模型(Routing)"></a>第四种模型(Routing)</h3><h4 id="Routing-之订阅模型-Direct-直连"><a href="#Routing-之订阅模型-Direct-直连" class="headerlink" title="Routing 之订阅模型-Direct(直连)"></a>Routing 之订阅模型-Direct(直连)</h4><p><code>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</code></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p>流程:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191126220145375.png"></p><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><h5 id="开发生产者-3"><a href="#开发生产者-3" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;logs_direct&quot;</span>,key,<span class="keyword">null</span>,(<span class="string">&quot;指定的route key&quot;</span>+key+<span class="string">&quot;的消息&quot;</span>).getBytes());</span><br></pre></td></tr></table></figure><h5 id="开发消费者-1-2"><a href="#开发消费者-1-2" class="headerlink" title="开发消费者-1"></a>开发消费者-1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列和交换机</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;warn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="开发消费者-2-2"><a href="#开发消费者-2-2" class="headerlink" title="开发消费者-2"></a>开发消费者-2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列和交换机</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;logs_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="测试生产者发送Route-key为error的消息时"><a href="#测试生产者发送Route-key为error的消息时" class="headerlink" title="测试生产者发送Route key为error的消息时"></a>测试生产者发送Route key为error的消息时</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200316102613933.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200316102627912.png"></p><h5 id="测试生产者发送Route-key为info的消息时"><a href="#测试生产者发送Route-key为info的消息时" class="headerlink" title="测试生产者发送Route key为info的消息时"></a>测试生产者发送Route key为info的消息时</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200316102925740.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200316102947326.png"></p><hr><h4 id="Routing-之订阅模型-Topic"><a href="#Routing-之订阅模型-Topic" class="headerlink" title="Routing 之订阅模型-Topic"></a>Routing 之订阅模型-Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！这种模型<code>Routingkey</code> 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20191127121900255.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**统配符**</span></span><br><span class="line"><span class="bullet">  *</span> (star) can substitute for exactly one word.    匹配不多不少恰好1个词</span><br><span class="line">  # (hash) can substitute for zero or more words.  匹配一个或多个词</span><br><span class="line">如:</span><br><span class="line">  audit.#    匹配audit.irs.corporate或者 audit.irs 等</span><br><span class="line">  audit.<span class="emphasis">*   只能匹配 audit.irs</span></span><br></pre></td></tr></table></figure><h5 id="开发生产者-4"><a href="#开发生产者-4" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生命交换机和交换机类型 topic 使用动态路由(通配符方式)</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line">String routekey = <span class="string">&quot;user.save&quot;</span>;<span class="comment">//动态路由key</span></span><br><span class="line"><span class="comment">//发布消息</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;topics&quot;</span>,routekey,<span class="keyword">null</span>,(<span class="string">&quot;这是路由中的动态订阅模型,route key: [&quot;</span>+routekey+<span class="string">&quot;]&quot;</span>).getBytes());</span><br></pre></td></tr></table></figure><h5 id="开发消费者-1-3"><a href="#开发消费者-1-3" class="headerlink" title="开发消费者-1"></a>开发消费者-1</h5><p><code>Routing Key中使用*通配符方式</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列与交换机并设置获取交换机中动态路由</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;user.*&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="开发消费者-2-3"><a href="#开发消费者-2-3" class="headerlink" title="开发消费者-2"></a>开发消费者-2</h5><p><code>Routing Key中使用#通配符方式</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//创建临时队列</span></span><br><span class="line">String queue = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//绑定队列与交换机并设置获取交换机中动态路由</span></span><br><span class="line">channel.queueBind(queue,<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;user.#&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费消息</span></span><br><span class="line">channel.basicConsume(queue,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2: &quot;</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h5><p> <img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200316113935785.png"></p><p> <img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200316114000459.png"></p><h2 id="SpringBoot中使用RabbitMQ"><a href="#SpringBoot中使用RabbitMQ" class="headerlink" title="SpringBoot中使用RabbitMQ"></a>SpringBoot中使用RabbitMQ</h2><h3 id="搭建初始环境"><a href="#搭建初始环境" class="headerlink" title="搭建初始环境"></a>搭建初始环境</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置配置文件"><a href="#配置配置文件" class="headerlink" title="配置配置文件"></a>配置配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springboot_rabbitmq</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">10.15</span><span class="number">.0</span><span class="number">.9</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/ems</span></span><br></pre></td></tr></table></figure><p><code>RabbitTemplate</code>  用来简化操作     使用时候直接在项目中注入即可使用</p><h3 id="第一种hello-world模型使用"><a href="#第一种hello-world模型使用" class="headerlink" title="第一种hello world模型使用"></a>第一种hello world模型使用</h3><h4 id="开发生产者-5"><a href="#开发生产者-5" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发消费者-1"><a href="#开发消费者-1" class="headerlink" title="开发消费者"></a>开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Queue创建的队列是默认持久化，非独占，非自动删除</p><h3 id="第二种work模型使用"><a href="#第二种work模型使用" class="headerlink" title="第二种work模型使用"></a>第二种work模型使用</h3><h4 id="开发生产者-6"><a href="#开发生产者-6" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;work&quot;</span>,<span class="string">&quot;hello work!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发消费者-2"><a href="#开发消费者-2" class="headerlink" title="开发消费者"></a>开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkCustomer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置</code></p></blockquote><h3 id="Fanout-广播模型"><a href="#Fanout-广播模型" class="headerlink" title="Fanout 广播模型"></a>Fanout 广播模型</h3><h4 id="开发生产者-7"><a href="#开发生产者-7" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanout</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;logs&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;这是日志广播&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发消费者-3"><a href="#开发消费者-3" class="headerlink" title="开发消费者"></a>开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue,</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue, //创建临时队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)  //绑定交换机类型</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Route-路由模型"><a href="#Route-路由模型" class="headerlink" title="Route 路由模型"></a>Route 路由模型</h3><h4 id="开发生产者-8"><a href="#开发生产者-8" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;directs&quot;</span>,<span class="string">&quot;error&quot;</span>,<span class="string">&quot;error 的日志信息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发消费者-4"><a href="#开发消费者-4" class="headerlink" title="开发消费者"></a>开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings =&#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue(),</span></span><br><span class="line"><span class="meta">                    key=&#123;&quot;info&quot;,&quot;error&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span></span><br><span class="line"><span class="meta">            )&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings =&#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue(),</span></span><br><span class="line"><span class="meta">                    key=&#123;&quot;error&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span></span><br><span class="line"><span class="meta">            )&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic-订阅模型-动态路由模型"><a href="#Topic-订阅模型-动态路由模型" class="headerlink" title="Topic 订阅模型(动态路由模型)"></a>Topic 订阅模型(动态路由模型)</h3><h4 id="开发生产者-9"><a href="#开发生产者-9" class="headerlink" title="开发生产者"></a>开发生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//topic</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;topics&quot;</span>,<span class="string">&quot;user.save.findAll&quot;</span>,<span class="string">&quot;user.save.findAll 的消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发消费者-5"><a href="#开发消费者-5" class="headerlink" title="开发消费者"></a>开发消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopCustomer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;user.*&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive1</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message1 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue,</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;user.#&quot;&#125;,</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;message2 = &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="MQ的应用场景"><a href="#MQ的应用场景" class="headerlink" title="MQ的应用场景"></a>MQ的应用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p><code>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</code></p><ul><li><code>串行方式:</code> 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </li></ul><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/SouthEast-4860248.png" alt="这里写图片描述"></p><ul><li><code>并行方式: </code>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </li></ul><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/SouthEast-20191127211112660.png" alt="这里写图片描述"></p><ul><li><code>消息队列:</code>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  <code>消息队列</code>: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </li></ul><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/592892-20190520220249900-1679743651.jpg" alt="img"></p><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p><code>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. </code></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/SouthEast-20191127211247287.png" alt="这里写图片描述"></p><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 </p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/SouthEast-20191127211304085.png" alt="这里写图片描述"></p><ul><li><p><code>订单系统:</code>用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p></li><li><p><code>库存系统:</code>订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p></li></ul><h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p><code>场景:</code> 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  </p><p><code>作用:</code> </p><p>​1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^)<br>​<br>2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/SouthEast-20191127211341601.png" alt="这里写图片描述"></p><p>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  </p><p>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p><hr><h2 id="RabbitMQ的集群"><a href="#RabbitMQ的集群" class="headerlink" title="RabbitMQ的集群"></a>RabbitMQ的集群</h2><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><h4 id="普通集群-副本集群"><a href="#普通集群-副本集群" class="headerlink" title="普通集群(副本集群)"></a>普通集群(副本集群)</h4><blockquote><p>All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster   –摘自官网</p></blockquote><p><code>默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</code></p><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320094147471.png"></p><p>​核心解决问题:  <code>当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</code></p><h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.集群规划</span></span><br><span class="line">node1: 10.15.0.3  mq1  master 主节点</span><br><span class="line">node2: 10.15.0.4  mq2  repl1  副本节点</span><br><span class="line">node3: 10.15.0.5  mq3  repl2  副本节点</span><br><span class="line"></span><br><span class="line"><span class="section"># 1.克隆三台机器主机名和ip映射</span></span><br><span class="line">vim /etc/hosts加入:</span><br><span class="line">  10.15.0.3 mq1</span><br><span class="line">  10.15.0.4 mq2</span><br><span class="line">  10.15.0.5 mq3</span><br><span class="line">node1: vim /etc/hostname 加入:  mq1</span><br><span class="line">node2: vim /etc/hostname 加入:  mq2</span><br><span class="line">node3: vim /etc/hostname 加入:  mq3</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行:</span></span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</span><br><span class="line"></span><br><span class="line"><span class="section"># 3.查看cookie是否一致:</span></span><br><span class="line">node1: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">node2: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line">node3: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="line"></span><br><span class="line"><span class="section"># 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面:</span></span><br><span class="line">rabbitmq-server -detached </span><br><span class="line"></span><br><span class="line"><span class="section"># 5.在node2和node3执行加入集群命令:</span></span><br><span class="line">1.关闭       rabbitmqctl stop<span class="emphasis">_app</span></span><br><span class="line"><span class="emphasis">2.加入集群    rabbitmqctl join_</span>cluster rabbit@mq1</span><br><span class="line">3.启动服务    rabbitmqctl start<span class="emphasis">_app</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 6.查看集群状态,任意节点执行:</span></span><br><span class="line"><span class="emphasis">rabbitmqctl cluster_</span>status</span><br><span class="line"></span><br><span class="line"><span class="section"># 7.如果出现如下显示,集群搭建成功:</span></span><br><span class="line">Cluster status of node rabbit@mq3 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,</span><br><span class="line">&#123;running<span class="emphasis">_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;,</span></span><br><span class="line"><span class="emphasis">&#123;cluster_</span>name,<span class="xml"><span class="tag">&lt;&lt;&quot;<span class="attr">rabbit</span>@<span class="attr">mq1</span>&quot;&gt;</span></span>&gt;&#125;,</span><br><span class="line">&#123;partitions,[]&#125;,</span><br><span class="line">&#123;alarms,[&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</span><br><span class="line"></span><br><span class="line"><span class="section"># 8.登录管理界面,展示如下状态:</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320095613586.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 9.测试集群在node1上,创建队列</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320095743935.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 10.查看node2和node3节点:</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320095827688.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320095843370.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 11.关闭node1节点,执行如下命令,查看node2和node3:</span></span><br><span class="line">rabbitmqctl stop<span class="emphasis">_app</span></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320100000347.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320100010968.png"></p><h4 id="镜像集群"><a href="#镜像集群" class="headerlink" title="镜像集群"></a>镜像集群</h4><blockquote><p>This guide covers mirroring (queue contents replication) of classic queues  –摘自官网<br>By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made <em>mirrored</em> across multiple nodes. –摘自官网</p></blockquote><p><code>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</code></p><h5 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/image-20200320113423235.png"></p><h5 id="配置集群架构"><a href="#配置集群架构" class="headerlink" title="配置集群架构"></a>配置集群架构</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.策略说明</span></span><br><span class="line">rabbitmqctl set<span class="emphasis">_policy [-p <span class="xml"><span class="tag">&lt;<span class="name">vhost</span>&gt;</span></span>] [--priority <span class="xml"><span class="tag">&lt;<span class="name">priority</span>&gt;</span></span>] [--apply-to <span class="xml"><span class="tag">&lt;<span class="name">apply-to</span>&gt;</span></span>] <span class="xml"><span class="tag">&lt;<span class="name">name</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span>  <span class="xml"><span class="tag">&lt;<span class="name">definition</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span></span><br><span class="line"><span class="emphasis">Name: policy的名称</span></span><br><span class="line"><span class="emphasis">Pattern: queue的匹配模式(正则表达式)</span></span><br><span class="line"><span class="emphasis">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span></span><br><span class="line"><span class="emphasis">  ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span></span><br><span class="line"><span class="emphasis">    all：表示在集群中所有的节点上进行镜像</span></span><br><span class="line"><span class="emphasis">    exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span></span><br><span class="line"><span class="emphasis">    nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class="line"><span class="emphasis">  ha-params：ha-mode模式需要用到的参数</span></span><br><span class="line"><span class="emphasis">    ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span></span><br><span class="line"><span class="emphasis">    priority：可选参数，policy的优先级</span></span><br><span class="line"><span class="emphasis">                </span></span><br><span class="line"><span class="emphasis">                </span></span><br><span class="line"><span class="emphasis"># 1.查看当前策略</span></span><br><span class="line"><span class="emphasis">rabbitmqctl list_</span>policies</span><br><span class="line"></span><br><span class="line"><span class="section"># 2.添加策略</span></span><br><span class="line">rabbitmqctl set<span class="emphasis">_policy ha-all &#x27;^hello&#x27; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27; </span></span><br><span class="line"><span class="emphasis">说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"># 3.删除策略</span></span><br><span class="line"><span class="emphasis">rabbitmqctl clear_</span>policy ha-all</span><br><span class="line"></span><br><span class="line"><span class="section"># 4.测试集群</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> amqp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cacheline 伪共享</title>
      <link href="2021/01/08/cacheline-improve/"/>
      <url>2021/01/08/cacheline-improve/</url>
      
        <content type="html"><![CDATA[<h4 id="before"><a href="#before" class="headerlink" title="before"></a>before</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><p><strong>markWord + klass 8字节</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CacheLine </tag>
            
            <tag> JMM </tag>
            
            <tag> 缓存一致性协议(MESI) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 指令快查</title>
      <link href="2021/01/08/docker/"/>
      <url>2021/01/08/docker/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是-Docker？"><a href="#什么是-Docker？" class="headerlink" title="什么是 Docker？"></a>什么是 <a href="https://www.docker.com/">Docker</a>？</h4><p>Docker是一个开源的应用容器引擎，基于Go语言，并遵循Apache2.0协议开源。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>Docker核心概念：<br>1 docker主机（Host）：安装了Docker程序的机器（Docker直接安装在操作系统之上）<br>2 docker客户端（Client）：连接docker主机进行操作<br>3 docker仓库（Registry）：用来保存软件镜像<br>4 docker镜像（Images）：软件打包好的镜像，放在docker仓库中<br>5 docker容器（Container）：镜像启动后的实例称为一个容器，容器是独立运行的一个或一组应用</p><p>理解：<br>1 镜像（Images）就是一个只读的模板，可以用来创建容器（一个镜像可以创建多个容器）<br>镜像与容器的关系，有点类似于面向对象变成中的类（镜像）与对象（容器）。<br>2 容器（Container）是一个或一组独立运行的应用，每个容器相互隔离，保证安全的平台。<br>容器可以看做是一个简易版的Linux环境和运行在其中的应用程序。<br>3 仓库是集中存放镜像文件的场所。<br>仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上存放着多个仓库，每个仓库有包含多个镜像，每个镜像有不同的标签（tag）</p><a id="more"></a><h4 id="安装及启动"><a href="#安装及启动" class="headerlink" title="安装及启动"></a>安装及启动</h4><h5 id="before-CentOS7"><a href="#before-CentOS7" class="headerlink" title="before CentOS7"></a>before CentOS7</h5><p>1 安装相关依赖库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><p>2 安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-io</span><br></pre></td></tr></table></figure><p>3 配置阿里云镜像路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;docker</span><br><span class="line"></span><br><span class="line">替换下面内容为aliyun镜像地址</span><br><span class="line">other_args&#x3D;&quot;--registry-mirror&#x3D;https:&#x2F;&#x2F;rkcuhe1v.mirror.aliyuncs.com&quot;</span><br></pre></td></tr></table></figure><p>4 启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><h5 id="after-CentOS7"><a href="#after-CentOS7" class="headerlink" title="after CentOS7"></a>after CentOS7</h5><p>1 卸载之前版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">      docker-client \</span><br><span class="line">      docker-client-latest \</span><br><span class="line">      docker-common \</span><br><span class="line">      docker-latest \</span><br><span class="line">      docker-latest-logrotate \</span><br><span class="line">      docker-logrotate \</span><br><span class="line">      docker-engine</span><br></pre></td></tr></table></figure><p>2 安装yum工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>3 启用docker源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>4 安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>5 配置镜像加速其器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;rkcuhe1v.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>安装后操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">2 启动后查看</span><br><span class="line">docker -v</span><br><span class="line">3 设置开机启动docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">4 停止docker</span><br><span class="line">systemctl stop docker </span><br></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><h5 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h5><p>1 搜索镜像<br>是从 <a href="https://hub.docker.com/">https://hub.docker.com/</a> 查找的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search [options] 关键字</span><br><span class="line">eg: docker search mysql</span><br></pre></td></tr></table></figure><p>options参数：<br>-s 列出STARS不小于指定值的镜像<br>-no-trunc 显示完整的镜信息（这里简写了DESCRIPTION）<br>-automated 只列出automated build类型的镜像</p><p>2 拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名 [:TAG]</span><br></pre></td></tr></table></figure><p>tag是版本号，不添加时，默认下载的是latest版本<br>如果配置了阿里云镜像，那么会从阿里云镜像地址下载</p><p>3 查看本地镜像列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [options] images</span><br></pre></td></tr></table></figure><p>options参数：<br>-a 列出本地所有镜像（含中间层）<br>-q 只显示镜像的ID<br>–digests 显示镜像摘要信息<br>–no-trunc 显示完整的镜像信息（这里简写ID，原本默认显示12位）</p><p>列表详情：<br>REPOSITORY：镜像仓库源<br>TAG：标签<br>IMAGE ID：镜像ID（默认显示12位）<br>CREATED：创建时间<br>SIZE：镜像大小<br>DIGEST：摘要信息</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/docker%20image.png" alt="镜像信息"></p><p>4 删除本地镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [options] 镜像名&#x2F;ID [:TAG]</span><br></pre></td></tr></table></figure><p>5 镜像commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像</span><br><span class="line">docker commit -m&#x3D;&quot;信息&quot; -a&#x3D;&quot;作者&quot; 容器ID 要创建的镜像名:tag名</span><br></pre></td></tr></table></figure><p><strong>删除本地所有镜像：<code>docker rmi -f $(docker images -qa)</code></strong></p><h5 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h5><p>1 运行镜像并启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run docker run [options] 镜像ID [:TAG]</span><br><span class="line">例：</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">docker run -d -p 8000:8080 tomcat</span><br></pre></td></tr></table></figure><p>options参数：<br>–name= 为容器指定一个名称<br>-d 后台运行容器，以守护式运行容器，返回容器ID<br>-i 以交互式运行容器（通常 -it 同用）<br>-t 为容器重新分配一个伪输入终端（通常 -it 同用）<br>-P 随机端口映射<br>-p 指定端口映射，有四种方式：<br>    ip:hostPort:containerPort<br>    ip::containerPort<br>    hostPort:containerPort<br>    containerPort</p><p>2 查看运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]</span><br></pre></td></tr></table></figure><p>options参数：<br>-a 列出正在运行的容器+历史运行的容器<br>-l 显示最新创建的容器<br>-n 显示最新创建的n个容器<br>-q 静默模式，只显示容器编号<br>–no-trunc 显示完整信息</p><p>3 停止运行中的容器</p><p>3.1 正常关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名&#x2F;ID</span><br></pre></td></tr></table></figure><p>3.2 强制关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器名&#x2F;ID</span><br></pre></td></tr></table></figure><p>3.3 退出容器<br>以 docker run -it 这种交互模式进入的容器，会有退出容器的操作<br>3.3.1 命令exit 停止并退出<br>3.3.2 快捷键ctrl+p+q 不停止退出</p><p>退出后重新回到容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><p>进入容器中运行命令后自动退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -t 容器ID +命令</span><br></pre></td></tr></table></figure><p>4 启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名&#x2F;ID</span><br></pre></td></tr></table></figure><p>5 删除一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure><p><strong>删除本地所有容器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 docker rm -f $(docker ps -qa)</span><br><span class="line">2 docker ps -qa | xargs docker rm ，上一个命令的结果集传递给下一个命令</span><br></pre></td></tr></table></figure><p>6 查看容器日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [options] container-name&#x2F;container-id</span><br></pre></td></tr></table></figure><p>options参数：<br>-t 表示加入时间戳<br>-f 跟随最新的日志打印<br>–tail 数字 显示最后多少条</p><h5 id="常用软件启动"><a href="#常用软件启动" class="headerlink" title="常用软件启动"></a>常用软件启动</h5><p>docker运行mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql</span><br><span class="line">-v &#x2F;yy&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</span><br><span class="line">-v &#x2F;yy&#x2F;mysql&#x2F;logs:&#x2F;logs</span><br><span class="line">-v &#x2F;yy&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">-d mysql:版本号 </span><br></pre></td></tr></table></figure><p>docker运行redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:7379</span><br><span class="line">-v &#x2F;yy&#x2F;myredis&#x2F;data:&#x2F;data</span><br><span class="line">-v &#x2F;yy&#x2F;myredis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">-d redis:版本号 redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">--appendonly yes</span><br></pre></td></tr></table></figure><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><p>查看容器内运行的进程 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><p>查看容器内部细节 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p>重新进入不停止退出ctrl+p+q 的docker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID，重新回到容器</span><br><span class="line">docker exec -t  容器ID 命令，进入容器中运行命令后自动退出</span><br></pre></td></tr></table></figure><p>容器内拷贝文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目标路径</span><br></pre></td></tr></table></figure><h4 id="数据卷容器Volume"><a href="#数据卷容器Volume" class="headerlink" title="数据卷容器Volume"></a>数据卷容器Volume</h4><p>能做什么？<br>1 容器的持久化<br>2 容器间继承+数据共享</p><h5 id="使用命令添加容器数据卷"><a href="#使用命令添加容器数据卷" class="headerlink" title="使用命令添加容器数据卷"></a>使用命令添加容器数据卷</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;host绝对路径目录:&#x2F;容器内目录 镜像名</span><br></pre></td></tr></table></figure><p>这个命令会在宿主机和容器中添加共通的目录，<strong>这两个目录可以进行数据共享和对接，容器停止退出后，主机修改的数据依然可以同步</strong></p><p>可以用命令控制容器内目录的读写权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;myDataVolume:&#x2F;dataVolumeContainer:ro centos</span><br></pre></td></tr></table></figure><p>加了只读权限后，在共享目录中。主机添加的文件，容器内可以查看。但是不能修改，也不能创建文件</p><h5 id="使用DockerFile添加容器数据卷"><a href="#使用DockerFile添加容器数据卷" class="headerlink" title="使用DockerFile添加容器数据卷"></a>使用DockerFile添加容器数据卷</h5><p>考虑到可移植和分享，使用-v命令不太好，建议使用DockerFile<br>DockerFile是Docker image源码级的文件</p><p>例子：通过DockerFile构建自己的centos镜像：<br>1 主机跟目录上新建 mkdir /mydocker 目录<br>2 书写DockerFilter文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer1&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;success&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>3 docker build 将上面DockerFile所在的文件，构建成镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t 起一个新镜像名 目录</span><br><span class="line">eg:</span><br><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t yycentos .</span><br></pre></td></tr></table></figure><p>-f 指文件<br>-t 命名空间</p><p>4 启动<br>docker run -it yycentos<br>启动后可以发现，在容器内会出现 /dataVolumeContainer1和/dataVolumeContainer2 两个文件目录</p><blockquote><p>ps：如果容器内访问共享目录出现：cannot open directory .: Permission denied<br>解决：在docker run 命令最后加 –privileged=true 参数</p></blockquote><h4 id="DockerFile解析"><a href="#DockerFile解析" class="headerlink" title="DockerFile解析"></a>DockerFile解析</h4><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本<br>构建步骤：<br>1 编写DockerFile文件<br>2 docker build<br>3 docker run</p><p>语法规则：<br>1 每条保留字执行都必须大写，后面要跟随至少一个参数<br>2 执行按照从上到下，顺序执行<br>3 #表示注释<br>4 每条指令都会创建一个新的镜像层，并对镜像进行提交</p><p>保留字指令：<br>1 FROM 基础镜像，当前新镜像是基于哪个镜像的<br>2 MAINTAINER 镜像维护者的姓名和邮箱<br>3 RUN 容器构件时需要运行的命令<br>4 EXPOSE 当前容器对外暴露出的端口号<br>5 WORKDIR 指定创建容器后，终端默认登录的工作目录，落脚点<br>6 ENV 用来在构建镜像过程中设置环境变量<br>7 COPY 拷贝，源路径到新一层路径<br>    写法1：COPY src dest — 这种是linux命令形式<br>    写法2：COPY [“src”,”dest”] — 这种是json串形式<br>8 ADD 拷贝并解压，将宿主机目录下的文件拷贝进镜像，且自动处理URL和解压<br>9 VOLUME 容器数据卷，用于数据保存和持久化<br>10 CMD 指定一个容器启动时要运行的命令<br>    DockerFile中可以有多个CMD指令，但是只有最后一个生效，且会被docker run之后的参数替换<br>11 ENTRYPOINT 指定一个容器启动时要运行的命令<br>    ENTRYPOINT的目的和CMD一样，都是指定容器启动程序及参数，但不会被docker run之后的参数替换，而是追加<br>12 ONBUILD 当构建一个被继承的DockerFile时运行命令，父镜像在被子继承后，父镜像的onbuild被触发<br>    在构建子镜像时会显示 # Executing 1 build triggers</p><p>案例：做一个自己的CentOS镜像<br>1 编写DockerFile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER yy&lt;521300259@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local  # 创建一个环境变量，名为MYPATH，代表路径&#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH         # 指定启动后落脚点为 &#x2F;usr&#x2F;local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim     # 给centos安装vim</span><br><span class="line">RUN yum -y install net-tools    # 给centos安装ifconfig</span><br><span class="line"></span><br><span class="line">EXPOSE 80  # 对外暴露80端口</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>2 构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t yycentos2 .</span><br></pre></td></tr></table></figure><p>3 运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run yycentos2 </span><br></pre></td></tr></table></figure><p>4 查看镜像变更历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history 镜像名</span><br></pre></td></tr></table></figure><h4 id="镜像原理"><a href="#镜像原理" class="headerlink" title="镜像原理"></a>镜像原理</h4><p>之后更新</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个简陋的LRU算法</title>
      <link href="2021/01/04/handle-redis-LRU/"/>
      <url>2021/01/04/handle-redis-LRU/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过手写一个简陋的LRU算法实现，达到理解其数据结构和算法的目的。</p><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>LRU：最近最少使用置换算法(Least Recently Used)，也就是首先淘汰最长时间未被使用的页面</p><a id="more"></a><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>在 <code>LinkedHashMap</code> 源码中有这样一行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This kind of map is well-suited to building LRU caches.</span><br></pre></td></tr></table></figure><p>也就是说这是官方推荐的最高效的LRU算法的实现。</p><p>这种方式实现只需要继承 <code>LinkedHashMap</code> ，并重写一下 <code>removeEldestEntry</code> 方法即可。</p><p>您可以查看 <a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/lru/LRULinkedHashMap.java">LRULinkedHashMap.java</a></p><h4 id="散列表-双向链表"><a href="#散列表-双向链表" class="headerlink" title="散列表+双向链表"></a>散列表+双向链表</h4><p>设计思路：<br>1 参考AQS设计Node节点和双向链表<br>2 通过散列表判断和限制链表的长度<br>3 通过双向链表来记录每个节点的热度（例如：热度高的移动至最侧）</p><p>完成的代码实现：</p><p>由于代码篇幅较长，您可以查看 <a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/lru/LRUCustomMap.java">LRUCustomMap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yy.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCustomMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;K, Node&lt;K, V&gt;&gt; lruMap;</span><br><span class="line">    <span class="keyword">private</span> DoubleLinkedList&lt;K, V&gt; lruDoubleLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCustomMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        lruMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        lruDoubleLinkedList = <span class="keyword">new</span> DoubleLinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lruMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;K, V&gt; node = lruMap.get(key);</span><br><span class="line">        lruDoubleLinkedList.popNode(node);</span><br><span class="line">        lruDoubleLinkedList.pushNode(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lruMap.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = lruMap.get(key);</span><br><span class="line">            node.v = value;</span><br><span class="line">            lruMap.put(key, node);</span><br><span class="line">            lruDoubleLinkedList.popNode(node);</span><br><span class="line">            lruDoubleLinkedList.pushNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lruMap.size() == capacity) &#123;</span><br><span class="line">                Node&lt;K, V&gt; lastNode = lruDoubleLinkedList.lastNode();</span><br><span class="line">                lruMap.remove(lastNode.k);</span><br><span class="line">                lruDoubleLinkedList.popNode(lastNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// new</span></span><br><span class="line">            Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">            lruMap.put(key, newNode);</span><br><span class="line">            lruDoubleLinkedList.pushNode(newNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node 节点类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        Node&lt;K, V&gt; prev;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;K, V&gt; prev, Node&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; HEAD;</span><br><span class="line">        Node&lt;K, V&gt; TAIL;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HEAD = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            TAIL = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            HEAD.next = TAIL;</span><br><span class="line">            TAIL.prev = HEAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// head  &lt;=&gt;   tail</span></span><br><span class="line">        <span class="comment">// head  &lt;=&gt;   node   &lt;=&gt;   tail</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushNode</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">            node.prev = HEAD;</span><br><span class="line">            node.next = HEAD.next;</span><br><span class="line">            HEAD.next.prev = node;</span><br><span class="line">            HEAD.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">lastNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TAIL.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popNode</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.prev = <span class="keyword">null</span>;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
            <tag> Reids </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snowflake 雪花算法封装</title>
      <link href="2021/01/04/snowflake-config/"/>
      <url>2021/01/04/snowflake-config/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>基于 <a href="https://www.hutool.cn/">Hutool</a> 工具包 <code>唯一ID工具-IdUtil</code> 封装的一个雪花算法ID生成工具。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法简单介绍下：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Image.png"></p><p>Twitter公司开源的一种生成分布式id的算法。<br>大致满足：<br>1 生产性能高，每秒生成26万个趋势自增的ID<br>2 稳定性高，不依赖其他第三方系统，分布式系统中不会产生ID碰撞<br>3 使用灵活，ID中包含时间戳、工作主机、数据中心等数据，可以自由配置</p><p>缺点：<br>1 依赖机器时钟，如果机器时钟回拨，会产生重复ID<br>2 单机上递增，分布式环境每台机器时钟不可能完全同步，有时候会出现不是全局递增的情况<br>（分布式Id一般只要求趋势递增，所以这个缺点可以忽略）</p><p>其他分布式ID算法：<br>1 百度 UidGenerator<br>2 美团 Leaf<br><strong>上面这两种算法没有时钟回拨问题，有兴趣可以自行了解</strong></p><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1 建议引入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 项目中导入 <code>SFIdGenerator.java</code> </p><p>3 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">SFIdGenerator sfIdGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> id = sfIdGenerator.getId();</span><br></pre></td></tr></table></figure><h4 id="工具地址"><a href="#工具地址" class="headerlink" title="工具地址"></a>工具地址</h4><p>您可以在 <a href="https://github.com/YorickYu/JPP/tree/main/src/main/java/com/yy/snowflake">SFIdGenerator</a> 下载使用这个工具</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> snowflake </tag>
            
            <tag> 雪花算法 </tag>
            
            <tag> hutool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean加载图解</title>
      <link href="2020/12/31/spring-bean-and-c-d/"/>
      <url>2020/12/31/spring-bean-and-c-d/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/spring%20bean.jpg" alt="图解"></p><p>调试过程跟踪Spring项目启动</p><p>你可以在 <a href="https://github.com/YorickYu/JPP">JPP</a> 中的/circularDependency包下查看相关代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Bean 加载 </tag>
            
            <tag> Spring 循环依赖 </tag>
            
            <tag> Spring 三层缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射快查</title>
      <link href="2020/12/30/whatis-reflection-in-java/"/>
      <url>2020/12/30/whatis-reflection-in-java/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>通过Class实例获取class信息的方法称为反射 Reflection</p><h4 id="Class实例"><a href="#Class实例" class="headerlink" title="Class实例"></a>Class实例</h4><p>以String为例：</p><table><thead><tr><th>Class Instance</th></tr></thead><tbody><tr><td>name = “java.lang.String”</td></tr><tr><td>package = “java.lang”</td></tr><tr><td>super = “java.lang.Object”</td></tr><tr><td>interface = CharSequence…</td></tr><tr><td>field = value[],hash,…</td></tr><tr><td>method = indexOf()…</td></tr></tbody></table><a id="more"></a><h5 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h5><ul><li>通过 <code>class</code> 静态变量获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;String[]&gt; aClass = String[].class;</span><br></pre></td></tr></table></figure><ul><li>通过实例的 <code>getClass()</code> 方法获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Class&lt;? extends HashMap&gt; mClass = m.getClass();</span><br></pre></td></tr></table></figure><ul><li>通过完整的 <code>class</code> 类名获取，调用 <code>Class.forName()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; cClass = Class.forName(<span class="string">&quot;java.time.Clock&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">String name = stringClass.getName();</span><br><span class="line">String packageName = stringClass.getPackage().getName();</span><br><span class="line">Field[] fields = stringClass.getFields(); <span class="comment">// getDeclaredFields()</span></span><br><span class="line">Method[] methods = stringClass.getMethods(); <span class="comment">// getDeclaredMethods()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NoSuchFieldException</span></span><br><span class="line">Field hashField = stringClass.getDeclaredField(<span class="string">&quot;hash&quot;</span>); <span class="comment">// getField()</span></span><br><span class="line"><span class="comment">// NoSuchMethodException</span></span><br><span class="line">Method toStringMethod = stringClass.getMethod(<span class="string">&quot;toString&quot;</span>); <span class="comment">// getDeclaredMethod()</span></span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhatisReflection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果（以String为例）：</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: <span class="keyword">false</span></span><br><span class="line">is primitive: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="Jvm动态加载"><a href="#Jvm动态加载" class="headerlink" title="Jvm动态加载"></a>Jvm动态加载</h4><p>第一次用到时才加载，根据这个特性，可以在运行时根据条件加载不同的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>声明对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h5><p>注意属性的访问级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class stdClass = Student.class;</span><br><span class="line"><span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line"><span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">Field grade;</span><br><span class="line">System.out.println(grade = stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br></pre></td></tr></table></figure><p>输出：<br>public int com.yy.reflection.WhatisReflectionField$Student.score<br>public java.lang.String com.yy.reflection.WhatisReflectionField$Person.name<br>private int com.yy.reflection.WhatisReflectionField$Student.grade</p><h5 id="Field常用方法"><a href="#Field常用方法" class="headerlink" title="Field常用方法"></a>Field常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Field grade = stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>);</span><br><span class="line">String name = grade.getName();</span><br><span class="line">Class&lt;?&gt; type = grade.getType();</span><br><span class="line"><span class="comment">// 返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</span></span><br><span class="line"><span class="keyword">int</span> modifiers = grade.getModifiers(); </span><br><span class="line"></span><br><span class="line">Modifier.isFinal(modifiers); <span class="comment">// false</span></span><br><span class="line">Modifier.isPublic(modifiers); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(modifiers); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(modifiers); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(modifiers); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="Field的get、set"><a href="#Field的get、set" class="headerlink" title="Field的get、set"></a>Field的get、set</h5><p>注意属性的访问级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// field.get(o) 获取值</span></span><br><span class="line"><span class="comment">// IllegalAccessException 因为grade是private</span></span><br><span class="line"><span class="comment">// 解决: grade.setAccessible(true); 或者 将grade更改为public</span></span><br><span class="line">grade.setAccessible(<span class="keyword">true</span>); <span class="comment">// 一律允许访问，可能会失败</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line">Object value = (<span class="keyword">int</span>)grade.get(s);</span><br><span class="line">System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">grade.set(s, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;value = &quot;</span> + s.grade);</span><br></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><h5 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = year;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class stdClass = Student.class;</span><br><span class="line"><span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">System.out.println(stdClass.getMethod(<span class="string">&quot;setScore&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line"><span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line"><span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">Method grade;</span><br><span class="line">System.out.println(grade = stdClass.getDeclaredMethod(<span class="string">&quot;setGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br></pre></td></tr></table></figure><p>输出：<br>public int com.yy.reflection.Student.getScore(java.lang.String)<br>public java.lang.String com.yy.reflection.Person.getName()<br>private int com.yy.reflection.Student.getGrade(int)</p><h5 id="Method常用方法"><a href="#Method常用方法" class="headerlink" title="Method常用方法"></a>Method常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Method grade = stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">String methodName = grade.getName();</span><br><span class="line">Class&lt;?&gt; returnType = grade.getReturnType();</span><br><span class="line"><span class="keyword">int</span> parameterCount = grade.getParameterCount();</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = grade.getParameterTypes();</span><br><span class="line"><span class="keyword">int</span> modifiers = grade.getModifiers();</span><br><span class="line">Modifier.isFinal(modifiers);</span><br><span class="line">Modifier.isPublic(modifiers);</span><br><span class="line">Modifier.isProtected(modifiers);</span><br><span class="line">Modifier.isPrivate(modifiers);</span><br><span class="line">Modifier.isStatic(modifiers);</span><br></pre></td></tr></table></figure><h5 id="Method方法调用"><a href="#Method方法调用" class="headerlink" title="Method方法调用"></a>Method方法调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法、私有方法</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">grade.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object invoke = grade.invoke(student, <span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;student.grade = &quot;</span> + student.grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态</span></span><br><span class="line">Method personHelloMethod = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">personHelloMethod.invoke(<span class="keyword">new</span> Student());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Method parseInt = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">Object res = parseInt.invoke(<span class="keyword">null</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;res = &quot;</span> + res);</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用无参数构造方法</span></span><br><span class="line">Person person = Person.class.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用无参数构造方法</span></span><br><span class="line">Person person = Person.class.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数构造方法</span></span><br><span class="line"><span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">System.out.println(n1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">System.out.println(n2);</span><br></pre></td></tr></table></figure><p>你可以在 <a href="https://github.com/YorickYu/JPP">JPP</a> 中的/reflection包下查看相关代码</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> Reflection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 30 串联所有单词的子串</title>
      <link href="2020/12/24/sw-findsubwords/"/>
      <url>2020/12/24/sw-findsubwords/</url>
      
        <content type="html"><![CDATA[<h5 id="LeeCode-30-串联所有单词的子串"><a href="#LeeCode-30-串联所有单词的子串" class="headerlink" title="LeeCode 30 串联所有单词的子串"></a>LeeCode 30 串联所有单词的子串</h5><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p> <br>示例 1：</p><p>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p><p>示例 2：</p><p>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>1 words数组是无序的，所以考虑使用 <code>HashMap</code> 存储，key为word元素，value为出现的次数<br>2 循环次数，因为数组元素是等长的，最开始考虑每次递增 <code>words[0].length()</code> 长度，但是测试用例中有一些需要案例无法通过。所以改为 <code>+=1</code>。这里是主要损耗性能的来源，应该可以想办法优化。<br>3 比对方法，每次取出一个目标子串，然后将子串按单词的长度切分遍历，分别到 <code>HashMap</code> 中查找是否存在。如果存在相应的key，则把对应的value减1。如果key本身的value就是1，那么直接把这个key删除。<br>4 最终判断 <code>HashMap</code> 的 <code>size</code> 是否为 0 即可</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// return list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = words[<span class="number">0</span>].length(); <span class="comment">// word 等长</span></span><br><span class="line">    <span class="keyword">int</span> pin = l * words.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; pin)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        String window = s.substring(loop, pin+loop);</span><br><span class="line">        map.clear();</span><br><span class="line">        <span class="keyword">for</span> (String w:words) &#123; <span class="comment">// words map</span></span><br><span class="line">            map.put(w, map.getOrDefault(w, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; window.length(); i += l) &#123;</span><br><span class="line"></span><br><span class="line">            String fakeWord = window.substring(i, i + l);</span><br><span class="line">            Integer count = map.getOrDefault(fakeWord, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                map.put(fakeWord, --count);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                map.remove(fakeWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == <span class="number">0</span>)</span><br><span class="line">            list.add(loop);</span><br><span class="line">        loop += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (loop &lt; s.length() - pin + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>176 / 176 个通过测试用例<br>执行用时: 291 ms<br>内存消耗: 39.2 MB</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> LeeCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抖音面试题：是否存在无序子串</title>
      <link href="2020/12/23/sw-findsubstring/"/>
      <url>2020/12/23/sw-findsubstring/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>存在一个较长的字符串a，检查a中是否包含一个较短字符串b的所有连续字符。顺序无所谓。<br>如果包含，返回字符串a中的起始下标。如果不包含返回-1。</p><p>eg：<br>输入：s1 = “abcsadefgzxcvb”   s2 = “cas”<br>输出: 2<br>解释: s1字符串中存在子串 “csa”</p><p>思路：滑动窗口<br>1 先记录b字符串字符出现次数，在count数组中<br>2 在长字符串中建立并保持一个窗口（长度与b字符串长度相等）<br>3 每当元素进入窗口时，查看count数组中有没有该元素，如果有，数量减1，如果没有，数量减1的同时，记录一个标志位。因为此时已经不满足题目的需求；元素移出窗口时，count数组中该元素的数量加1。如果数量本身小于0，那么标志位加1。<br>4 滑动过程中，如果出现标志位为0。即说明出现了满足条件的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(String s, String a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || a==<span class="keyword">null</span> || s.length()&lt;a.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] aim = a.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aim.length; i++) &#123; <span class="comment">// 记录 sub 字符串中的字符个数</span></span><br><span class="line">        count[aim[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M = aim.length;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> inValidTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; R &lt; M; R++) &#123; <span class="comment">// 建立窗口</span></span><br><span class="line">        <span class="keyword">if</span> (count[str[R]]-- &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            inValidTimes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; R &lt; str.length; R++) &#123; <span class="comment">// 滑动</span></span><br><span class="line">        <span class="keyword">if</span> (inValidTimes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R - M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count[str[R]]-- &lt;= <span class="number">0</span>) &#123; <span class="comment">// 窗口扩容</span></span><br><span class="line">            inValidTimes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count[str[R-M]]++ &lt; <span class="number">0</span>) &#123; <span class="comment">// 窗口收缩</span></span><br><span class="line">            inValidTimes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inValidTimes == <span class="number">0</span> ? R - M : -<span class="number">1</span>; <span class="comment">// 判断最后一个窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dynamic programming 动态规划</title>
      <link href="2020/12/21/dynamic-programming/"/>
      <url>2020/12/21/dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p>输出中.</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读ThreadLocal源码-Hash冲突、启动/探测式清理、扩容</title>
      <link href="2020/12/13/threadlocal2/"/>
      <url>2020/12/13/threadlocal2/</url>
      
        <content type="html"><![CDATA[<h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4><p>因为ThreadLocalMap中的数据其实是存在Entry[]数组中的，一个纯数组的结构能存储值的数量是非常有限的，几遍在Hash算法中使用了黄金分割，但是不可避免的还是会产生Hash冲突。<br>当插入Entry[]数组时发生Hash冲突时，会进入for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry e = tab[i]; </span><br><span class="line">    e != <span class="keyword">null</span>;</span><br><span class="line">    e = tab[i = nextIndex(i, len)]) &#123;  <span class="comment">// Hash冲突</span></span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前ThreadLocal计算出的下标是5，tab[5]对应的Entry不为null，则说明产生了Hash冲突。<br>进入for循环：<br>1 判断这个Entry的key是否等于传入的ThreadLocal，如果相等，替换并返回<br>2 判断这个Entry的key是否为null（说明key已经过期），开始探测式清理<br>3 循环过程中，数组下标通过 <code>nextIndex(i, len)]</code> 累加，如果发现新下标对应数组位置为空，那么会插入在新的位置</p><a id="more"></a><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>ThreadLocalMap中的set方法，在key值计算的数组下标处元素不为null，且循环过程中遇到key已经过期的元素时会进入这个方法。</p><p>这里涉及到了探测式清除<br>总之最后方法执行的结果是，清除了过期的Entry元素，并且通过多次for循环和hash计算，让之前发生过Hash冲突的元素更靠近正确的位置。达到优化查询效率的目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要明确，方法传入的参数有3个：<br>1 当前线程中创建的一个ThreadLocal对象<br>2 需要存入的value值<br>3 在ThreadLocalMap的set方法中发生Hash冲突时，遍历找到的一个过期的Entry的下标<br><strong>这个下标处的Entry是一个过期的Entry</strong></p><p>我们逐行理解一下源码：<br>1 将传入的第三个参数（过期Entry的下标）记录在 <code>slotToExpunge</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> slotToExpunge = staleSlot;</span><br></pre></td></tr></table></figure><p>2 第一个for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">    (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">    i = prevIndex(i, len)) <span class="comment">// 循环往前</span></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.1 从传入的下标位置，<strong>循环往前</strong> 遍历数组，直到发现Entry为null停止。<br>2.2 在遍历的过程中，如果发现key为null的过期元素，更新 <code>slotToExpunge</code> 的值。<br>2.3 for循环中数组下标的计算是 <code>prevIndex(i, len)</code> 方法，可以看出，如果向前遍历到下标为0时，会更新下标为 <code>len-1</code> 继续循环。停止的唯一条件是找到 <code>Entry==null</code> 才停止。</p><p>3 第二个for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = nextIndex(i, len)) &#123; <span class="comment">// 循环往后</span></span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        e.value = value;</span><br><span class="line"></span><br><span class="line">        tab[i] = tab[staleSlot];</span><br><span class="line">        tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.1 从传入的下标位置，<strong>循环往后</strong> 遍历数组，直到发现 <code>Entry==null</code> 或者 找到一个Entry的key与传入参数的ThreadLocal相同时停止。<br>3.2 如果向后遍历时发现了一个key相同的Entry，那么会先更新这个Entry的value，然后把这个Entry与此次发生Hash冲突的Entry进行交换。<br>3.3 交换完成后开始过期Entry的清理工作，清理从 <code>slotToExpunge</code> 下标开始。<br>如果 <code>slotToExpunge == staleSlot</code>，这说明在之前的两个for循环中都未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的index，即 <code>slotToExpunge = i</code><br>这个方法后面详细讲：<br><code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code></p><p>3.4 如果循环过程中没有找到相同key的Entry，会判断这个Entry是否已经过期（即 <code>k==null</code>），如果过期了，且在上面第一个for循环中没有更新过 <code>slotToExpunge</code>。那么会更新 <code>slotToExpunge</code> 的值。</p><p>4 代码执行到这里，说明在数组中没有找到key相同的Entry。<br>那么就创建一个新的Entry，替换table[stableSlot]的过期Entry。</p><p>5 最后，通过判断 <code>slotToExpunge != staleSlot</code> 可以得知除了 staleSlot 这个传入的下标以外，是否还有其他的过期Entry在数组中。如果有，则执行清理操作<br><strong>清理分为两种：<code>探测式清理</code> 和 <code>启发式清理</code></strong></p><h4 id="探测式清除"><a href="#探测式清除" class="headerlink" title="探测式清除"></a>探测式清除</h4><p>从开始位置 <strong>循环向后</strong> 探测清理过期数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程：<br>1 因为调用方法时传入的 <code>slotToExpunge</code> 就是记录过期元素下标位置的，所以进入方法用 <code>staleSlot</code> 接收这个参数，并直接将对应位置的Entry置空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br></pre></td></tr></table></figure><p>2 接下去 <strong>循环向后</strong> 遍历每一个Entry，遇到 <code>key==null</code> 就置空。如果不为空就 <code>rehash</code> 获取新的数组下标，由于Entry对象插入数组的过程是向后循环找空位，所以rehash的下标肯定在当前下标之前。<br>2.1 从新下标的位置，向后遍历，如果找到空位就插入<br>2.2 如果找不到空位，最坏情况就是插入到原本的位置</p><p>3 这个方法最后会返回一个数组下标，这个下标位置的 <code>Entry</code> 为 <code>null</code>。<strong>可以理解为，数组中从入参 <code>slateSlot</code> 到出参 <code>i</code> 这个区间内的元素都完成了清理和重定位</strong>。</p><p><strong>探测式清理结束后，数组中过期的元素应该会被 <del>全部清理</del> 部分清除，而且之前发生 <code>Hash冲突</code> 的Entry元素的位置应该更接近真实hash出来的位置。提升了查找的效率</strong></p><blockquote><p>这里探测式清理并不能全部清除数组中的过期元素，而是从传入的下标清理到第一个 <code>Entry==null</code> 为止。部分清除。<br>其余的部分，需要通过 <strong>启发式清理</strong></p></blockquote><h4 id="启发式清除"><a href="#启发式清除" class="headerlink" title="启发式清除"></a>启发式清除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启发式清理需要接收两个参数：<br>1 探测式清理后返回的数字下标，这里至少保证了Hash冲突的下标至探测式清理后返回的下标这个区间无过期的Entry。<br>2 数组总长度</p><p>根据源码可以看出，启动式清理会从传入的下标 <code>i</code> 处，向后遍历。<br>如果发现过期的Entry则再次触发探测式清理，并重置 <code>n</code>。这个n是用来控制 <code>do while</code> 循环的跳出条件。<br>如果遍历过程中，连续 <code>m</code> 次没有发现过期的Entry，就可以认为数组中已经没有过期Entry了。<br>这个 <code>m</code> 的计算是 <code>n &gt;&gt;&gt;= 1</code> ，你也可以理解成是数组长度的2的几次幂。<br><strong>例如：数组长度是16，那么2^4^=16，也就是连续4次没有过期Entry，即 <code>m =  logn/log2(n为数组长度)</code></strong></p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>在 ThreadLocalMap 的 <code>set</code> 方法最后，执行完 <code>cleanSomeSlots(i, sz)</code> 启动式清理后，如果没有发现过期元素，那么说明此时数组长度进行了 <code>size++</code>。需要判断是否需要进行数组扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure><p><strong>Entry[] 数组的扩容阈值是 <code>len * 2 / 3</code>，数组长度的三分之二。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以发现，数组扩容之前会进行一次 <strong>全面的清理</strong>，直接用 <code>fori</code> 全部遍历数组中的每一个元素，如果发现过期的Entry就进行探测式清理。</p><p>全面清理结束之后，会进一步判断数组的长度是否满足 <code>size &gt;= threshold - threshold / 4</code>，也就是说，扩容前真正的阈值判断是 <code>len * 2/3 * 3/4</code>，也就是阈值真正的值是 <strong>数组长度的1/2</strong>。是两个步骤计算出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次扩容会将数组长度扩容至原来的2倍，然后遍历老数组，将老数组中的元素重新计算下标，并插入新数组。<br>插入时如果发生Hash冲突，那就向后遍历寻找空位。这个遍历的过程和探测式清理中有点类似。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>阅读过程中发现ThreadLocal的源码远比我想想的要复杂的多得多，关于Hash冲突、数组清理机制、扩容机制的逻辑非常复杂。而且我只是根据源码逐行理解了大概的思路。具体的流程我也没有通过Demo去调试代码。</strong></p><p><strong>不过阅读ThreadLocal的源码的收获还是很大的。原来数组这种数据结构还可以通过这种方式解决Hash冲突的问题。</strong></p><p><strong>也给实际开发中，处理并发安全问题时提供了多一种解决方案。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash冲突 </tag>
            
            <tag> 数组扩容 </tag>
            
            <tag> 启动式清理 </tag>
            
            <tag> 探测式清理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动装箱和拆箱的发生场景</title>
      <link href="2020/12/12/java-boxing-unboxing/"/>
      <url>2020/12/12/java-boxing-unboxing/</url>
      
        <content type="html"><![CDATA[<h3 id="自动装箱拆箱的常见使用场景"><a href="#自动装箱拆箱的常见使用场景" class="headerlink" title="自动装箱拆箱的常见使用场景"></a>自动装箱拆箱的常见使用场景</h3><ul><li>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</li><li>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</li></ul><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 10;  &#x2F;&#x2F;自动装箱</span><br><span class="line">int b &#x3D; a;      &#x2F;&#x2F;自动拆箱</span><br></pre></td></tr></table></figure><p>我在JDK1.8环境下，反编译结果与原代码没有差别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 10;</span><br><span class="line">int b &#x3D; a;</span><br></pre></td></tr></table></figure><p>阿里手册中提到反编译的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a&#x3D;Integer.valueOf(10); </span><br><span class="line">int i&#x3D;a.intValue(); </span><br></pre></td></tr></table></figure><p>说明自动装箱底层实际是 <code>Integer.valueOf()</code> ，自动拆箱底层实际是 <code>a.intVakue()</code></p><a id="more"></a><h4 id="1-将基本数据类型放入集合类"><a href="#1-将基本数据类型放入集合类" class="headerlink" title="1 将基本数据类型放入集合类"></a>1 将基本数据类型放入集合类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(1);</span><br></pre></td></tr></table></figure><p>首先，List中只能接收对象类型。其次，上面代码声明List<Integer>也指定的存储Integer类型。上面代码 <code>list.add(1)</code> </p><h4 id="2-对象类型和基本数据类型比较判断和运算"><a href="#2-对象类型和基本数据类型比较判断和运算" class="headerlink" title="2 对象类型和基本数据类型比较判断和运算"></a>2 对象类型和基本数据类型比较判断和运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D;10;  &#x2F;&#x2F;自动装箱</span><br><span class="line">int b &#x3D; a;      &#x2F;&#x2F;自动拆箱</span><br><span class="line">if (a &gt; 10) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    int c &#x3D; a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-三目运算符的使用"><a href="#3-三目运算符的使用" class="headerlink" title="3 三目运算符的使用"></a>3 三目运算符的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; 0;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">int k &#x3D; flag ? i : j;</span><br></pre></td></tr></table></figure><p>上面这段代码反编译的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; 0;</span><br><span class="line">int j &#x3D; true;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">    i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，程序写到这里，编译器根本无法推断变量 k 的类型。</p><p>但是对原代码稍作修改，就可以准确的推断出 k 是 int类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; 0;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">int k &#x3D; flag ? i : j;</span><br><span class="line">System.out.println(&quot;k &#x3D; &quot; + k);</span><br></pre></td></tr></table></figure><p>上面的代码会将 Integer类型的i自动拆箱为int类型，赋值给k</p><p><strong>三目运算符因为这一特性，有可能会发生空指针异常，稍微修改下上面的代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; null;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">int k &#x3D; flag ? i : j;</span><br><span class="line">System.out.println(&quot;k &#x3D; &quot; + k);</span><br></pre></td></tr></table></figure><p>这里在自动拆箱时会出现NPE</p><blockquote><p>这个问题被收录在阿里开发手册中：<a href="https://www.hollischuang.com/archives/435">自动拆箱导致空指针异常</a></p></blockquote><h4 id="4-函数入参和返回值"><a href="#4-函数入参和返回值" class="headerlink" title="4 函数入参和返回值"></a>4 函数入参和返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自动拆箱</span><br><span class="line">public int unboxing(Integer num) &#123;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;自动装箱</span><br><span class="line">public Integer boxing(int num) &#123;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-自动拆箱时的临界值问题"><a href="#5-自动拆箱时的临界值问题" class="headerlink" title="5 自动拆箱时的临界值问题"></a>5 自动拆箱时的临界值问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 &#x3D; 129; &#x2F;&#x2F; 自动装箱</span><br><span class="line">Integer integer2 &#x3D; 129;</span><br><span class="line"></span><br><span class="line">if (integer1 &#x3D;&#x3D; integer2)</span><br><span class="line">    System.out.println(&quot;integer1 &#x3D;&#x3D; integer2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;integer1 !&#x3D; integer2&quot;);</span><br><span class="line"></span><br><span class="line">if (integer1.equals(integer2))</span><br><span class="line">    System.out.println(&quot;integer1 &#x3D;&#x3D; integer2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;integer1 !&#x3D; integer2&quot;);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">结果：</span><br><span class="line">integer1 !&#x3D; integer2</span><br><span class="line">integer1 &#x3D;&#x3D; integer2</span><br></pre></td></tr></table></figure><p>1 数字赋值给Integer对象时自动装箱<br>2 两值的 <code>==</code> 符号判断会进行自动拆箱<br>同<font color=black> <a href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E5%92%8C%E8%BF%90%E7%AE%97">2.对象类型和基本数据类型比较判断和运算</a> </font></p><blockquote><p>这里涉及到一个 <a href="https://www.hollischuang.com/archives/1174">[译]Java中整型的缓存机制</a> 的知识</p></blockquote><blockquote><p>大概意思就是：<br>如果数字在-128至127之间时，相同数字自动装箱给不同的对象类型会直接使用缓存中的对象，而不是重新创建一个对象。<br>然而上面代码中129超过了这个区间，所以拆箱判断时不等于。<br>Byte, Short, Long有固定范围: -128 到 127。对于Character, 范围是 0 到 127。除了Integer以外，这个范围都不能改变。</p></blockquote><h3 id="需要理清的事情"><a href="#需要理清的事情" class="headerlink" title="需要理清的事情"></a>需要理清的事情</h3><p>自动装箱和拆箱非常好用，但是有底层需要了解的事情不能丢：</p><p>1 基本数据类型存储在栈中，对象类型创建在堆中</p><p>2 因为Java的面向对象特性，所以出现了8大基本数据类型的包装对象类型</p><p>3 自动装箱拆箱是JDK1.5之后引入的</p><p>4 自动拆箱时注意null处理，不然会抛NPE异常</p><p>5 循环中尽量使用基本数据类型，相比大量的拆装箱操作跟节省资源</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> boxing </tag>
            
            <tag> unboxing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CODING EVERYDAY</title>
      <link href="2020/12/11/Ryan-Dahl/"/>
      <url>2020/12/11/Ryan-Dahl/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ryan%20dahl.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读ThreadLocal源码-基础部分</title>
      <link href="2020/12/10/threadlocal/"/>
      <url>2020/12/10/threadlocal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新于：2020-12-14 22:25 内容补充</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>起初了解 <code>ThreadLocal</code> 这个类还是从阿里手册的一篇文章过来的。他的源码中通篇没有一个<code>lock</code>、也没有出现 <code> synchronized</code> 关键字。但是他却利用一些巧妙的方法保证了并发下数据的安全。</p><p>带着下面这几个问题尝试着从 <code>ThreadLocal</code> 的源码中找找答案？</p><p>1 ThreadLocal 和 Thread 有什么联系？<br>2 ThreadLocal 底层的数据结构是什么？<br>3 ThreadLocal 存储数据有没有大小限制？<br>4 什么情况下 ThreadLocal 会发生内存泄漏？<br>5 已知 Entry 继承于 WeakReference，那么GC内存回收时会不会导致存储的内容丢失？<br>6 Entry[] 数组发生Hash冲突如何解决？<br>7 如何清理陈旧的Entry对象？何时清理？<br>8 ThreadLocalMap中数组扩容机制？几个步骤？阈值到底是多少？</p><a id="more"></a><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/threadlocal.png"></p><p>1 每个Thread线程中都有一个threadlocals属性，他的类型是ThreadLocal.ThreadLocalMap<br>2 ThreadLocalMap是ThreadLocal的静态内部类，被ThreadLocal类管理<br>3 ThreadLocalMap底层的数据结构是一个弱引用的数组Entry[]<br>4 Entry继承于WeakReference，在这里可以简单的理解成他是一个key-value的形式</p><blockquote><p>他的‘key’就是ThreadLocal对象，value就是我们需要保存的值<br>但是Entry实际是一个Reference，将‘key’保存在referent引用中</p></blockquote><blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ThreadLocal-entry.png"></p></blockquote><p><strong>此外，在源码调试过程中，我有两个疑问没得到解答：</strong><br>1 为什么我们不能直接像Thread类中那样创建ThreadLocalMap的对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap map &#x3D; null; &#x2F;&#x2F; 编译不通过</span><br></pre></td></tr></table></figure><p>2 程序启动时会默认在主线程的threadlocals中添加几个值？一个Object和两个软引用？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/threadloacl-defaultvalues.png"></p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>简单看下ThreadLocal中的 <code>set</code>，<code>get</code>，<code>remove</code> 方法<br>方法本身也比较简单，思路就是通过ThreadLocal的方法来关联 Thread类 和 ThreadLocalMap类</p><blockquote><p>你也许会问：为什么Thread不自己管理ThreadLocalMap呢？<br>这是一个比较巧妙的设计，上面也讲过 ThreadLocalMap 中的数据结构是 Entry[] 数组，数组中每个Entry可以理解成一个key-value键值对。<br>首先，ThreadLocal将自身this指针作为Entry的key。其次，Entry是一个弱引用对象，这样用户只需要控制ThreadLocal对象就可以回收保存的value值了。（这个说法不严禁，后面再补充）</p></blockquote><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，需要注意的是，ThreadLocalMap是在这个方法中创建的。</p><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释下 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 是做什么的？<br>简单来说就是让编译器忽略 泛型T 产生的警告。告诉编译器这个写法是合法的。<br>可以通过 <a href="https://stackoverflow.com/questions/1129795/what-is-suppresswarnings-unchecked-in-java">What is SuppressWarnings (“unchecked”) in Java?</a> 了解更多</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">if (m !&#x3D; null)</span><br><span class="line">m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="threadLocalHashCode"><a href="#threadLocalHashCode" class="headerlink" title="threadLocalHashCode"></a>threadLocalHashCode</h5><p>因为ThreadLocal将自身作为Entry的key保存<br>这个threadLocalHashCode仅用于在Entry[]数组中计算下标使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final int threadLocalHashCode &#x3D; nextHashCode();</span><br><span class="line"></span><br><span class="line">private static AtomicInteger nextHashCode &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLocalHashCode的产生是由一个 <code>AtomicInteger</code> 对象每次累加一个 <code>HASH_INCREMENT</code> 的值得出。<br>这个值很特殊，它是 <a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><strong>斐波那契数</strong></a> 也叫 黄金分割数。<br>大概的作用就是尽量避免Hash冲突。</p><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>上面也提到过，ThreadLocal主要是用来联系Thread类和管理ThreadLocalMap的。<br>所以关键的代码都是在ThreadLocalMap中</p><h5 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">    &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">    &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">    &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1); &#x2F;&#x2F; 通过ThreadLocal的threadLocalHashCode计算下标</span><br><span class="line"></span><br><span class="line">    for (Entry e &#x3D; tab[i]; </span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;  &#x2F;&#x2F; Hash冲突</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 这个方法的最开始，有一段注释，提到一个 <code>fast path</code> 的概念。<br>大概的意思就是，通常我们定义的 <code>set</code> 方法都类似于：<code>public void setA(int a) &#123;    this.a = a; &#125;</code><br>但是这里的set方法需要传入key和value两个值。<br>我能理解注释的前半段，因为与以往的set方法不同，这里传入的ThreadLocal作为key，需要进行数组下标的计算等等。<br>但是后半段注释中 <code>a fast path would fail more often than not</code> 提到的这种写法失败概率更低我并不是很理解。<br>这个疑惑我也在 <a href="https://github.com/YorickYu/IHAVEAQUESTION">I HAVE A QUESTION</a> 中的第11个问题中指出，希望有大神看到可以发个 <code>Issues</code> 告知一下。感激不尽</p><p>2 通过ThreadLocal的threadLocalHashCode计算下标，使用按位与的方法提升效率</p><p>3 for循环，这个for循环做了几件事：<br>3.1 判断数组中原本要插入的下标位置是否为null，如果不为空则进入循环<br>3.2 循环中通过 Entry的get()方法 获取Entry对象中的key-ThreadLocal 对象，命名为 k<br>3.3 如果这次传入的ThreadLocal与k相等，那么替换value并返回<br>3.4 如果k为null，则调用 <code>replaceStaleEntry(key, value, i);</code> 方法（<strong>这里说明原本存在这个位置的Entry中的key-ThreadLocal已经被系统GC，会触发探测式清理</strong>）<br>3.5 如果这个k即不是传入的ThreadLocal，又不是null，那么会通过 <code>nextIndex(i, len)</code> 方法继续循环寻找下一个下标（<strong>如果遍历过程中，在找到相同的key或者key为null的情况之前，找到Entry[]数组中对应的下标是空的，那么带着新的下标跳出循环，创建一个Entry对象，插入在这里。这里说明发生了Hash冲突</strong>）</p><p>4 如果方法执行到这里，说明Entry[]数组中对应的下标是空的，那么直接创建一个 Entry对象插入即可（这里插入的下标有可能在上面的for循环中发生了改变）</p><p>5 清理 &amp; 扩容，<code>threshold = len * 2 / 3;</code> </p><blockquote><p>这里会先进行 <code>cleanSomeSlots(i, sz) </code> 启发式清理。</p></blockquote><p><strong>上面出现了几个概念：探测式清理、启发式清理和Hash冲突。这些过程较为复杂，放在下一篇详细介绍</strong><br>总之，这个set方法返回时，已经完成了value的插入。</p><h5 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e &#x3D; table[i];</span><br><span class="line">    if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line">    while (e !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        if (k &#x3D;&#x3D; key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k &#x3D;&#x3D; null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">            i &#x3D; nextIndex(i, len);</span><br><span class="line">        e &#x3D; tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Entry不为空，并且Entry对象中的key就是获取的ThreadLocal key，那么就返回。<br>反之，就调用 <code>getEntryAfterMiss(key, i, e);</code> 方法，这个方法中有一个while循环，思路和上面set方法中的for循环差不多。</p><p>当遍历发现数组中的Entry元素有key==null时，进入探测式循环</p><h5 id="Entry中的key为什么会变为null？"><a href="#Entry中的key为什么会变为null？" class="headerlink" title="Entry中的key为什么会变为null？"></a>Entry中的key为什么会变为null？</h5><p>我们都知道，ThreadLocalMap底层的数据结构是Entry[]数组，Entry是弱引用类型的对象。</p><blockquote><p>这里关于Java的对象的引用类型不做展开了，分为 <code>强引用</code>、<code>软引用</code>、<code>弱引用</code>、<code>虚引用</code>。<br>弱引用使用WeakReference修饰，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/threadlocal-weak.png"><br>他们得引用关系如图所示</p><p>这里需要满足2个条件，Entry中的key就会变为null<br>1 在当前线程中失去了对ThreadLocal对象的强引用<br>2 发生了GC内存回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ThreadLocal&lt;&gt;().set(&quot;be GC&quot;);</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8 &#x3D; &#123;ThreadLocal$ThreadLocalMap$Entry@512&#125; </span><br><span class="line">    value &#x3D; &quot;be GC&quot;</span><br><span class="line">    referent &#x3D; null</span><br><span class="line">    queue &#x3D; &#123;ReferenceQueue$Null@515&#125; </span><br><span class="line">    next &#x3D; &#123;ThreadLocal$ThreadLocalMap$Entry@512&#125; </span><br><span class="line">    discovered &#x3D; null</span><br></pre></td></tr></table></figure><p>从上面这个例子可以看出，由于 <code>new ThreadLocal&lt;&gt;().set(&quot;be GC&quot;);</code> 这种创建方式，不会再栈中保存一个ThreadLocal的强引用，所以当系统发生GC时，这个Entry的key就会被回收变成null</p><hr><p>下一篇详细看一下关于ThreadLocal的Hash冲突、探测式清理、启动时清理的源码</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thread </tag>
            
            <tag> WeakReference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的tomcat为什么启不起来？</title>
      <link href="2020/12/09/how-to-checkout-running-port/"/>
      <url>2020/12/09/how-to-checkout-running-port/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在测试服务器的使用过程，由于大家的使用没有非常规范，所以经常会出现服务启动不起来的问题。这类问题的产生经常是因为你配置的服务端口号被其他程序占用了。</p><p>那么如何定位一台服务器中端口的使用情况呢？这里推荐两个非常好用的命令</p><h4 id="查看正在使用的端口"><a href="#查看正在使用的端口" class="headerlink" title="查看正在使用的端口"></a>查看正在使用的端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnlp   </span><br></pre></td></tr></table></figure><blockquote><p>-t : 指明显示TCP端口<br>-u : 指明显示UDP端口<br>-l : 显示监听套接字<br>-p : 显示进程标识符和程序名称，每一个套接字都属于一个程序<br>-n : 不进行DNS轮询，显示IP(可以加速操作)<br>-a : 显示全部（包括ESTABLISHED）</p></blockquote><p>套接字就是socket，表示一对IP/PORT的组合。每个套接字对应一个PID，相当于给一个应用程序赋予了收发通讯协议的能力<br>网关，用于匹配目标IP于掩码的与运算结果，网络层完成，寻找下一跳<br>这里关于套接字和网关的信息不展开，等我完全理解以后可能会整理一篇博客</p><p>这里 <code>-u</code> 不是很常用。</p><p>查询结果以我自己的一台服务器为例：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/netstat.jpg"></p><blockquote><p>上图中本地地址和远端地址的组合对应一个PID，其中本地地址和远端地址的组合就是一个socket。多个socket指向同一个PID，就是多路复用。</p></blockquote><p>上图中本地地址 <code>Local Address</code> 一栏中显示出了目前所有正在监听的端口号。</p><p>以tomcat为例，从最右侧 <code>Program name</code> 为 java 的就是 tomcat。因为它是由 java 开发的一款 servlet 容器。</p><p>通常可以通过 <code>jps</code> 命令查看tomcat的PID。名称为 Bootstrap 。</p><blockquote><p>为什么 tomcat 启动叫 Bootstrap？给大家留个问题，答案在/bin/startup.sh 和 /bin/catalina.sh 中</p></blockquote><p>从上面的图可以看出，我这台机器的tomcat占用了两个端口：8005和8080，前者是用来监听SHUTDOWN指令的。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这篇博客没有太多内容，就是分享一个好用的命令行工具，便于大家查看服务器中已经占用的端口号。这样在配置新服务的过程中可以避免因为端口被占用而浪费时间。</p><p>文章中途有一些发散的知识和问题，都是跟网络编程相关的。等我学习完成后再输出。</p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ps </tag>
            
            <tag> netstat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说我对happens-before原则和as-if-serial语义的理解</title>
      <link href="2020/12/07/whatis-happensbefore/"/>
      <url>2020/12/07/whatis-happensbefore/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于 happens-before原则 和 as-if-serial语义 到底是什么意思？为什么会出现？解决什么问题？简短的说下我自己的理解</p><h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>如果单一线程中操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序</p><p>这个重排序的过程并不会影响程序运行的结果，对程序员来说是无感的。所以叫做 as-if-serial “看上去像是连续的”</p><blockquote><p>证明重排序的存在：<a href="https://yloopdaed.icu/2020/10/19/CPU-Out-of-Order/">CPU 乱序执行反证</a></p></blockquote><h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><p>JMM中定义的 跨线程内存可见性的规则：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果 A happens-before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的</p><blockquote><p>JMM：Java内存模型(Java Memory Model)<br>屏蔽掉不同硬件和操作系统的内存模型差异，以实现让Java程序在各种平台下都能达到一致的内存访问结果。所以对于Java程序员，无需了解底层硬件和操作系统内存模型的知识，只要关注Java自己的内存模型，就能够解决Java语言中的内存可见性问题了</p></blockquote><h4 id="为什么会出现？"><a href="#为什么会出现？" class="headerlink" title="为什么会出现？"></a>为什么会出现？</h4><p>因为 CPU缓存和重排序 可能会在多线程并发时导致程序执行结果与程序员代码的执行语义不符</p><p><strong>所以JMM定义了一套规则，CPU重排序时需要遵守这些规则</strong></p><p><strong>这些规则可以指导程序员写出正确的代码，让程序正确执行</strong></p><h4 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h4><p>共有8项：<br>1 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>2 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>3 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>4 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。<br>5 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。<br>6 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>7 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。<br>8 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>可以理解为：<br>1 as-if-serial，单线程程序是按程序的顺序来执行的（可能发生指令重排序，但是程序员无感知）<br>2 happens-before，**<em>正确同步**</em>的多线程程序是按执行顺序执行的（正确同步的操作需要程序员完成）<br>3 as-if-serial语义和happens-before原则，都是为了在不改变程序执行结果的前提下，尽可能地提高程序的执行效率</p><p>参考：<br><a href="https://blog.csdn.net/ThinkWon/article/details/102074107?utm_medium=distribute.pc_relevant_download.none-task-blog-searchFromBaidu-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-searchFromBaidu-1.nonecas">as-if-serial规则和happens-before规则的区别</a><br><a href="https://segmentfault.com/a/1190000011458941">从Java多线程可见性谈Happens-Before原则</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> happens-before </tag>
            
            <tag> as-if-serial </tag>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread.interrupt() 线程中断</title>
      <link href="2020/11/30/interrupt/"/>
      <url>2020/11/30/interrupt/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。<br>所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p><p>具体来说，当对一个线程，调用 interrupt() 时，<br>① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。<br>② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。</p><p>interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。<br>① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。<br>② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// do more work.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间以后</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure><p>具体到你的问题，Thread.interrupted()清除标志位是为了下次继续检测标志位。<br>如果一个线程被设置中断标志后，选择结束线程那么自然不存在下次的问题<br>如果一个线程被设置中断标识后，进行了一些处理后选择继续进行任务<br>而且这个任务也是需要被中断的，那么当然需要清除标志位了。</p><p>以上内容摘自：<a href="https://www.zhihu.com/question/41048032/answer/89431513">Intopass在知乎的回答</a></p><h4 id="thread-interrupt-thread-isInterrupted-Thread-interrupted-三者区别"><a href="#thread-interrupt-thread-isInterrupted-Thread-interrupted-三者区别" class="headerlink" title="thread.interrupt()\thread.isInterrupted()\Thread.interrupted() 三者区别"></a>thread.interrupt()\thread.isInterrupted()\Thread.interrupted() 三者区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// while 循环</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// false -&gt; true</span></span><br><span class="line">                System.err.println(<span class="string">&quot;线程中断&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(thread.isInterrupted()); <span class="comment">// false</span></span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">thread.interrupt(); <span class="comment">// 中断 thread</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">System.out.println(thread.isInterrupted()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读AQS源码（countdownlatch await）</title>
      <link href="2020/11/30/AQS-countdownlatch/"/>
      <url>2020/11/30/AQS-countdownlatch/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>CountDownLatch 也是 JUC 包中提供的。<br>它的作用是可以让多个线程阻塞。是共享锁的一种体现</p><p>本篇记录一下 CountDownLatch 的源码阅读过程，记录一下，方便以后复习</p><a id="more"></a><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/CountDownLatch-structure.png" alt="CountDownLatch"></p><h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// await() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// countDown() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>创建 CountDownLatch 时需要指定一个大于零的整数，用于计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个传入的正整数会被记录在AQS的state中，保证了多线程并发情况下的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总的来说，CountDownLatch 的构造方法就是为 state 赋值。</strong></p><h5 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h5><p>使当前线程一直等待，直到latch的state减为0。<br><strong>除非其他线程中断了此线程，那么会打断等待，抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://yloopdaed.icu/2020/11/30/interrupt/">thread.interrupt() 线程中断</a></p><p>这个方法被 await() 方法调用<br>首先判断线程是否被其他线程中断，如果中断直接抛出异常并返回<br>其次调用 <code>tryAcquireShared(arg)</code> 方法判断当前state是否为0<br>如果返回0，则结束该方法，程序正常执行。<br>如果返回-1，则说明当前线程需要 <strong>入队并阻塞</strong>。</p><blockquote><p>这里为什么方法名中都有一个shard（共享）？先带着这个问题往下看</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// Thread.interrupted()会重置标志位</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取state的值并判断，如果state为0，则方法返回1，否则返回-1<br><strong>注意：这个方法的入参 <code>int acquires</code> 是没用的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doAcquireSharedInterruptibly(1)这个方法和 reentrantLock.lock() 中的 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> 加锁方法非常相似。</strong></p><p>重要的区别有两处：<br>1 reentrantLock.lock() 不能响应 interrupt() 中断<br>2 假如在自旋的时候锁被释放了，reentrantLock 会判断AQS队列中是否有其他线程等待，而countDownLatch 可以直接返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 判断state是否为0</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 1 </span></span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 入队<br>这个方法会通过当前线程创建一个Node并加入AQS队列<br>具体过程参考 <a href="https://yloopdaed.icu/2020/11/29/AQS-reentrantlock/">尝试阅读AQS源码（ReentrantLock 加锁）</a></p><p><strong>区别在于这里创建的 Node 是 <code>Node.SHARED</code> 共享模式！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 已经初始化，追加 node</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 队列没有初始化，去初始化</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 阻塞线程<br>这里的逻辑都和 <a href="https://yloopdaed.icu/2020/11/29/AQS-reentrantlock/">尝试阅读AQS源码（ReentrantLock 加锁）</a> 相同<br>如果程序运行到这里，那么该线程会阻塞在这里。并且记录该线程的Node会记录在AQS队列中等待唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure><hr><blockquote><p>上面的内容都比较容易理解<br>个人认为 CountDownLatch 源码中比较难得部分是下面 <code>setHeadAndPropagate()</code> 方法。</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-countdownlatch.jpg" alt="流程"></p><p><strong>假如自旋过程中 state 被改为 0，那么会执行 <code>setHeadAndPropagate()</code> 方法。重新设置AQS队列的head并传播。</strong></p><blockquote><p>什么叫传播？<br>因为对于 countDownLatch.await() 的加锁而言。无论当前有多少个线程阻塞，无论AQS队列中有多少个线程等待。一旦 state==0，那么所有的线程都可以返回并继续执行程序。</p><p><strong>之前提到的为什么源码中有很多方法命名中带有 <code>shared</code> 可能就是这个原因。包括上面创建Node入队时，创建的NodeSHARED共享模式的</strong></p></blockquote><p>首先，进入这个方法。说明state已经为0，那么通过 <code>setHead(node)</code> 方法将AQS的Head指向这个node（head = node;），并且将node的thread和prev都置null（node.thread = null;node.prev = null;）。<br>其次，因为state=0，所以传入这个方法的 propagate 参数为1。此时无论当前这个node的下一个节点有没有元素。都会继续执行 <code>doReleaseShared()</code> 这个方法去 <strong>唤起阻塞的线程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// state == 0 时，传入的propagate为1</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果node没有下一个节点，或者node本身是共享模式，那么执行 doReleaseShared()</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的目的就是唤起阻塞的线程，这里也有自旋操作<br>1 假如此时head==tail，那么说明当前线程刚创建node，在自旋时state就被countDown为0了。此时当前线程还没有执行park阻塞。所以直接break返回即可<br>2 假如此时AQS队列中不止一个node，那么就要判断AQS的head的waitStatus。假如等于-1，说明这些node对应的线程已经在阻塞状态，那么调用 <code>unparkSuccessor(h)</code> 循环唤起AQS队列中的每一个线程即可<br><strong>3 假如此时AQS队列中不止一个node，而且AQS的head的waitStatus等于0（或者上面第2点运行完成后，waitStatus也等于0），那么这里会CAS把waitStatus改为-3（Node.PROPAGATE）并退出循环</strong></p><blockquote><p><strong>上面的第3点，我并不是特别清楚最后将AQS的Head节点对应的node中的waitStatus标记成-3是什么用意</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head; <span class="comment">// 获取AQS队列的head节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; </span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; <span class="comment">// 获取head的waitStatus</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 如果ws == -1</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果ws==0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS队列的tail循环向前移动，取出node，释放被阻塞的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在阅读 CountDownLatch 源码之前先看了 ReentrantLock 的源码。对 AQS队列的相关知识有了一些了解<br>本以为可以比较容易的完成阅读，但是 CountDownLatch 中自旋时的操作真的非常复杂和巧妙<br>与 ReentrantLock 不同的是，ReentrantLock 中的锁只能同一时间被一个线程占有。所以只需要查看队列中的排队顺序即可。<br>但是 CountDownLatch 中阻塞的线程会在 state 被置为 0 时同时释放。而且无论如何AQS都在工作。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> AQS </tag>
            
            <tag> countdownlatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读AQS源码（ReentrantLock 加锁）</title>
      <link href="2020/11/29/AQS-reentrantlock/"/>
      <url>2020/11/29/AQS-reentrantlock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新于：2020-12-14 22:47 调整排版，提升阅读感受</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>尝试通过 reentrantLock.Lock() 加锁部分阅读 AQS 源码。</p><p>博客的形式展现源码其实非常苦难：</p><p>1 代码之间很难建立跳转的关系，从而增加阅读的难度。</p><p>2 然后流程图又只能梳理代码运行的大致流程，很难反映代码执行的过程。</p><p>况且我个人对于源码的理解也没有非常深入。只是通过阅读和调试的过程把大概的思路整理一下，分享出来</p><a id="more"></a><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>结构：ReentrantLock中有三个内部类和一个Sync属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/RL-structure.png" alt="structure"></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>ReentrantLock是公平锁还是非公平锁？<br>取决于你如何初始化，默认是非公平锁，可以给构造方法传入true创建公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lock方法"><a href="#Lock方法" class="headerlink" title="Lock方法"></a>Lock方法</h4><h5 id="公平锁流程"><a href="#公平锁流程" class="headerlink" title="公平锁流程"></a>公平锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 公平锁继承于Sync，Sync继承于AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 acquire() 方法在 AbstractQueuedSynchronizer 中<br>首先调用 tryAcquire() 方法尝试获取锁</p><p>3 state值的判断流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果state</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; </span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 判断有无其他线程等待</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-tryAcquire.png" alt="tryAcquire流程"></p><p>根据state是否为0，判断锁是否空闲<br>    1. 如果锁空闲，要继续看AQS队列里有没有其他线程等待<br>        1.1 没有其他线程等待，那么获取锁，修改state值，方法返回 true<br>        1.2 有其他线程等待，方法返回 false<br>    2 如果锁不空闲，要看获取锁的线程是不是当前线程<br>        2.1 如果是，重入，方法返回 true<br>        2.2 如果不是，方法返回 false</p><p><strong>总结：</strong><br>tryAcquire() 方法中有一个state值的判断<br>如果 state == 0，说明目前这个锁处于空闲状态，那么进一步判断AQS队列中是否有前置线程等待，如果没有前置线程，那么当前线程可以成功获取锁<br>如果 state != 0，说明目前这个锁被某线程占中，那么进一步判断占用这个锁的线程是不是当前线程，如果是，<strong>可重入</strong>。如果不是则方法返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断AQS队列中是否有其他线程等待（这个方法先不展开，后面会详细讲）<br>先了解如果没有其他线程等待，返回fasle。那么 tryAcquire() 方法中就可以获得锁<br><code>((s = h.next) == null || s.thread != Thread.currentThread())</code> 后面分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AbstractQueuedSynchronizer 类中对 unsafe 类方法进行了一次封装<br>这里 unsafe.compareAndSwapInt() 方法就是 CAS ，这个方法在汇编层面保证了原子性调用 <code>LOCK_IF_MP(mp) lock cmpxchg </code> 是CPU可以识别的指令，保证了多线程同步执行</p><p>最后，当 tryAcquire() 返回true时，那么当前线程会成功获取锁并继续执行代码<br>如果返回 false，那么说明锁当前被持有，或者仍有其他线程在等待。这两种情况下面会详细分析</p><h5 id="非公平锁流程"><a href="#非公平锁流程" class="headerlink" title="非公平锁流程"></a>非公平锁流程</h5><p>非公平锁就是在上面公平锁流程之前，判断一步当前线程是否空闲，如果空闲则直接抢占。不用管是否有其他线程在AQS队列中等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>截止到这里，我们可以得出一个结论：<br><strong>假如在单线程或者多线程同步执行的情况下，ReentrantLock的执行效率非常高，JDK层面解决。<br>所以在项目中如果你的并发量不高，也可以放心使用 ReentrantLock。</strong></p></blockquote><hr><h5 id="复杂场景加锁流程"><a href="#复杂场景加锁流程" class="headerlink" title="复杂场景加锁流程"></a>复杂场景加锁流程</h5><p>如果现在的情况是多线程并发执行，那么ReentrantLock的执行过程又是怎么的呢？</p><p>根据上面的分析可知，如果是多线程并发执行，那么 tryAquire() 方法的返回值是 false，那么会继续调用<br><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 方法 <strong>入队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中 Node 对象中的关键属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 如果AQS队列 tail 不为空，则追加 node</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// AQS队列 tail 为空，初始化队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过当前线程创建一个新的 Node 并入队。新 Node 的 nextWaiter=Node.EXCLUSIVE=null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 入队</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化队列时会进行自旋操作<br>第一次循环，先创建一个空的 node，让AQS队列的 head 和 tail 都指向他。空node成为AQS队列的第一个元素<br>第二次循环，将先前创建的 node 追加在刚刚创建的 空node 后面，并跳出循环。此时AQS队列中有两个元素排队<br>最后将新创建的 node 返回<br>注意：AQS队列的 head 指向的 Node 中的 thread 永远为 null : <code>compareAndSetHead(new Node())</code></p><h6 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h6><p>尝试拿锁 | 阻塞线程<br>运行到这里时，AQS队列中有两个node元素。第一个node的 thread 为 null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果当前这个node为AQS的head，那么tryAcquire(arg)尝试拿锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 阻塞</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋操作<br>首先，取出传入node的 prev指向的node，判断这个node是否是AQS队列的head<br>如果是，则调用先前讲到的 tryAcquire() 方法尝试拿锁。（因为此时传入的node已经排在AQS队列的第二位，第一位是thread=null）<br>如果不是，则调用 shouldParkAfterFailedAcquire(p, node) 方法阻塞当前线程（这里用到了自旋）</p><p><strong>调用 tryAcquire() 方法尝试拿锁时，如果锁的状态恰好是空闲（state==0）的话，就会涉及到 &lt;判断当前线程的排队情况&gt;, 也就是 hasQueuedPredecessors()方法</strong></p><h6 id="hasQueuedPredecessors流程"><a href="#hasQueuedPredecessors流程" class="headerlink" title="hasQueuedPredecessors流程"></a>hasQueuedPredecessors流程</h6><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-hasQueue.png" alt="hasQueuedPredecessors流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="总结hasQueuedPredecessors流程："><a href="#总结hasQueuedPredecessors流程：" class="headerlink" title="总结hasQueuedPredecessors流程："></a>总结hasQueuedPredecessors流程：</h6><p>hasQueuedPredecessors() 方法返回false的时候，当前线程会成功获取到锁<br>那么会返回false的情况有2个：<br>1 AQS队列中没有其他线程等待，那么当前线程自然可以获取到锁<br><strong>2 当前线程创建的 node 刚刚入队且排在队首位，自旋时锁被释放了。那么当前线程可以获取到锁</strong></p><blockquote><p>解释：<br><code>acquireQueued(addWaiter(Node.EXCLUSIVE)</code> 的执行顺序是先 <code>addWaiter(Node.EXCLUSIVE)</code> 创建Node并入队（如果AQS队列原本为空，会先创建一个空Node，不为空就直接追加）。创建完成Node之后会调用 <code>acquireQueued(node)</code> 方法。<br>在 <code>acquireQueued(node)</code> 方法中，上面有提到：如果传入node的前一个节点恰好是AQS中Head指向的节点，那么说明这个node有资格尝试获取锁，此时调用 <code>tryAcquire()</code> 方法尝试拿锁时假如锁恰好被释放了（state==0），在这种情况下会调用 <code>hasQueuedPredecessors()</code> 方法检查AQS中是否有线程在排队。<br>现在的情况是，假如有一个线程T刚进入AQS队列，创建的Node排在第二位（第一位Node的thread是null）。那么 <code>h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread())</code> 这个判断会返回 fasle，此时虽然线程T刚入队，但是正好获取了锁，就顺理成章拿锁、修改state=1、然后重排AQS队列、GC回收无用Node等等。而不必在让线程T阻塞park()了。</p></blockquote><hr><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-addwriter-acquire.png" alt="手画流程图"></p><hr><h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><p>这里涉及到 Node 类中的 waitStatus 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性的设计非常巧妙，因为假如当前线程阻塞了，那么对于当前线程来说，阻塞线程和标记为阻塞状态是有一个先后顺序的<br>如果先标记状态，那么万一系统发生异常，该线程并没有成功park()，那也会产生bug。<br>但是如果先阻塞，就无法再去标记状态了，因为线程已经停止运行了。<br>所以这里 waitStatus 很巧妙的利用当前node的前一个节点的waitStatus来标记当前这个线程的阻塞状态<br>如果进入这个方法时 waitStatus 不为 -1，那么会自旋将其标记为 -1，然后返回true</p><h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><p>直到 shouldParkAfterFailedAcquire() 方法返回true时，这个方法才会执行。<br>使用LockSupport.park() 方法阻塞当前线程，直到再次被唤醒时返回 Thread.interrupted();  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 由 LockSupport 封装 UNSAFE 类中的 park() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于 Thread.interrupted() 线程中断，这里需要与 lockInterruptibly() 锁一起理解</strong></p><p>这部分等我真正理解后再输出吧。</p><p>我的个人理解是：</p><p>在 Lock() 加锁时，<code>thread.interrupt();</code> 并不能中断阻塞的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 lockInterruptibly() 加锁时，<code>thread.interrupt();</code> 可以通过抛出异常来中断阻塞线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure><p>仅供参考</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> AQS </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点整理|B站面试录播（三太子敖丙）</title>
      <link href="2020/11/27/interview/"/>
      <url>2020/11/27/interview/</url>
      
        <content type="html"><![CDATA[<p>这个视频很早之前就收藏了</p><p>今天从头到尾细看了一遍，收获挺大的。把视频中出现的思维导图补充和整理了一版（并没有涵盖所有的点）</p><p>视频链接在下面 ↓</p><p><a href="https://www.bilibili.com/video/BV1HQ4y1P7hE">Bilibili-程序员面试北大研究生Java岗</a></p><p>由于图片导出实在是太大了，放在OSS非常消耗带宽，如果需要的话可以通过下面链接获取</p><p><a href="https://github.com/YorickYu/Java-abilities-summary">知识点整理</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大化满足你需求的日志系统</title>
      <link href="2020/11/26/simple-log-project/"/>
      <url>2020/11/26/simple-log-project/</url>
      
        <content type="html"><![CDATA[<h1 id="simple-log-project"><a href="#simple-log-project" class="headerlink" title="simple_log_project"></a>simple_log_project</h1><p>最大化满足你需求的日志系统</p><a id="more"></a><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>最大化满足需求的同时尽可能避免代码侵入</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过AOP去切入你自定义的注解，不断维护你的注解类和切面类，最后将这个工具打包成jar包发布到maven仓库。</p><p><strong><em>因为没有一款三方的插件可以完美覆盖你所有的需求，所以最好的方式就是按这个流程不断维护自己的工具。</em></strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>1 导入文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.java</span><br><span class="line">LogAspect.java</span><br></pre></td></tr></table></figure><p>前者定义注解</p><p>后者AOP切入注解，完善功能</p><p>2 在目标方法上添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>.MIDDLE(description = <span class="string">&quot;标记测试方法&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundTest</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 执行结果</p><p><img src="https://upload-images.jianshu.io/upload_images/1260967-96d5ae227bf41496.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result"></p><p>日记会记录使用的切面类型、执行的类和方法、传入参数、执行结果、持续时间等。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>你可以在 <a href="https://github.com/YorickYu/JPP/tree/main/src/main/java/com/yy/annotation">JPP</a> 或者<a href="https://github.com/YorickYu/simple_log_project">simple_log_project</a> 中下载并使用这个小工具</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Annotation </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 最长公共前缀</title>
      <link href="2020/11/18/longest-common-prefix-string/"/>
      <url>2020/11/18/longest-common-prefix-string/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这个题目不难，也没有使用什么特别巧妙的想法。只是单纯的结果让我出乎意料。<br>纪念一下我的第一个0ms吧。</p><p>解法就是暴力for。<br>拿出数组中一个元素，循环与其他元素比较，如果不包含相同前缀就把当前的字符串减去最后一个字符继续遍历。</p><p><del>随后就是两种结果，要么得到一个子串符合条件，那么就继续验证合法性（这也就是为什么要for两次）。要么就是被减成了空串，那就说明没有公共前缀。直接返回即可</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String finalString &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; strs.length ; i++) &#123;</span><br><span class="line">            String x &#x3D; strs[i];</span><br><span class="line">            finalString &#x3D; i &#x3D;&#x3D; 0? x : finalString;</span><br><span class="line">            if (finalString.length() &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 如果目标字符串为空，说明没有公共串</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;else if (i !&#x3D; 0 &amp;&amp; x.indexOf(finalString) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 此元素以目标字符串开头，遍历下一个元素</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                for (int j &#x3D; i+1; j &lt; strs.length; j++) &#123;</span><br><span class="line">                    while (strs[j].indexOf(finalString) !&#x3D; 0) &#123; &#x2F;&#x2F; 如果不是以目标字符串开头，则截掉目标字符串最后一个字符并重试</span><br><span class="line">                        finalString &#x3D; finalString.substring(0, finalString.length()-1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return finalString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><p>昨天写的代码太多余了，因为题目中有 <strong><em>公共</em></strong> 两个字，让我想要多验证一次前缀的合法性。<br>但是也正因为 <strong><em>公共</em></strong> 二个字。其实并不用去验证，因为只要有一个不合法，在while中就削减为空串了。</p><p>下面的代码当然也可以多加一个判断。就是循环的时候判断空串。</p><p>但是我保留Java4行代码0ms难道不好吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String finalString &#x3D; strs.length &gt; 0 ? strs[0] : &quot;&quot;;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; strs.length; j++) &#123;</span><br><span class="line">            while (strs[j].indexOf(finalString) !&#x3D; 0) </span><br><span class="line">                finalString &#x3D; finalString.substring(0, finalString.length()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return finalString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/result-longgestcommonprefix.jpg" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode X 京东 周赛挑战（失败）</title>
      <link href="2020/11/16/min-operations/"/>
      <url>2020/11/16/min-operations/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong><em>Leetcode 将 x 减到 0 的最小操作数</em></strong></p><p>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。</p><p>如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。</p><p>示例 1：</p><p>输入：nums = [1,1,4,2,3], x = 5<br>输出：2<br>解释：最佳解决方案是移除后两个元素，将 x 减到 0 。<br>示例 2：</p><p>输入：nums = [5,6,7,8,9], x = 4<br>输出：-1<br>示例 3：</p><p>输入：nums = [3,2,20,1,1,3], x = 10<br>输出：5<br>解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1 声明两个指针，分别指向数组的第一个和最后一个元素<br>2 多种情况判断数组首尾的值和x的大小关系</p><p>直接看代码吧，卡在最后一个长数组的用例过不去，debug了好久，期望次数是对的，但是结果不对。时间有限，暂时没弄清错在哪里，以后再改。</p><p>代码贴一下，请大神指教：<br>我能想到的就是 <strong>最小</strong> 问题，但是结果不应该有错。不知道哪里出了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int minOperations(int[] nums, int x) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        int p1 &#x3D; 0;</span><br><span class="line">        int p2 &#x3D; nums.length-1;</span><br><span class="line"></span><br><span class="line">        while (p2&gt;p1) &#123;</span><br><span class="line">            if (nums[p1] + nums[p2] &#x3D;&#x3D; x) &#123;</span><br><span class="line">                &#x2F;&#x2F; +2 返回</span><br><span class="line">                count +&#x3D;2;</span><br><span class="line">                x &#x3D; 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if (nums[p1] + nums[p2] &lt; x) &#123;</span><br><span class="line">                &#x2F;&#x2F; 两边都可以移动，选大的移</span><br><span class="line">                x -&#x3D; nums[p1] &gt;&#x3D; nums[p2] ? nums[p1++] : nums[p2--];</span><br><span class="line">                count +&#x3D; 1;</span><br><span class="line">            &#125;else if (nums[p1] + nums[p2] &gt; x) &#123;</span><br><span class="line">                if (nums[p1] &#x3D;&#x3D; x || nums[p2] &#x3D;&#x3D; x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; +1 返回</span><br><span class="line">                    count +&#x3D; 1;</span><br><span class="line">                    x &#x3D; 0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if (nums[p1] &gt; x &amp;&amp; nums[p2] &lt; x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 移动p2</span><br><span class="line">                    x -&#x3D; nums[p2--];</span><br><span class="line">                    count +&#x3D; 1;</span><br><span class="line">                &#125;else if (nums[p2] &gt; x &amp;&amp; nums[p1] &lt; x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 移动p1</span><br><span class="line">                    x -&#x3D; nums[p1++];</span><br><span class="line">                    count +&#x3D; 1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    &#x2F;&#x2F; -1</span><br><span class="line">                    count &#x3D; -1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x &#x3D;&#x3D; 0 ? count: -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 两个数组的交集 II</title>
      <link href="2020/11/16/intersection-of-array/"/>
      <url>2020/11/16/intersection-of-array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>示例 1:</p><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]</p><p>输出：[2,2]</p><p>示例 2:</p><p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</p><p>输出：[4,9] </p><p>说明：</p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。</p><p>进阶：</p><p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1 先将两个数组分别存入HashMap中，key为元素的值，value为元素出现的次数<br>2 选择数组较短的那个HashMap进行遍历<br>3 如果HashMap的key相同，则说明有交集<br>4 Key的value值就是这个元素出现的次数，两个HashMap的value值取最小值，就是这个Key重复的次数。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; array1Map &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; array2Map &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int a: nums1) &#123;</span><br><span class="line">            Integer times &#x3D; 0;</span><br><span class="line">            if (array1Map.get(a) !&#x3D; null)</span><br><span class="line">                times &#x3D; array1Map.get(a);</span><br><span class="line">            array1Map.put(a, ++times);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int b: nums2) &#123;</span><br><span class="line">            Integer times &#x3D; 0;</span><br><span class="line">            if (array2Map.get(b) !&#x3D; null)</span><br><span class="line">                times &#x3D; array2Map.get(b);</span><br><span class="line">            array2Map.put(b, ++times);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; target;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; copy;</span><br><span class="line">        if (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            target &#x3D; array2Map;</span><br><span class="line">            copy &#x3D; array1Map;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            target &#x3D; array1Map;</span><br><span class="line">            copy &#x3D; array2Map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; arrList &#x3D; new ArrayList&lt;Integer&gt;(target.keySet().size());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator &#x3D; target.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Integer targetKey &#x3D; iterator.next();</span><br><span class="line">            Integer targetValue &#x3D; target.get(targetKey);</span><br><span class="line">            Integer copyValue &#x3D; copy.get(targetKey);</span><br><span class="line"></span><br><span class="line">            if (copyValue &#x3D;&#x3D; null)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            int finalValue &#x3D; Math.min(targetValue, copyValue);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; finalValue; i++) &#123;</span><br><span class="line">                arrList.add(targetKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] returnints &#x3D; new int[arrList.size()]; </span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        for (final Integer value: arrList) &#123;</span><br><span class="line">            returnints[index++] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return returnints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码存在的问题：<br>没必要将两个数组都存入HashMap，只存一个，然后遍历另一个数组即可。遍历的过程中取HashMap中get(key)，只要不为null就记录一次。</p><p>大概可以节省1-2次遍历的开销。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>双指针：<br>1 首先将两个数组排序<br>2 声明两个指针变量，分别指向两个数组的第一个元素<br>3 如果两个元素相等，则记录一次，并且两个指针均向后移动一位<br>4 如果不相等，数值小的指针向后移动，直到元素相等，以此类推<br>5 直到任意一个指针指向了数组的末尾结束</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        int f1 &#x3D; 0,f2&#x3D;0;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrl &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while(f1&lt;nums1.length &amp;&amp; f2&lt;nums2.length)&#123;</span><br><span class="line">            if(nums1[f1]&lt;nums2[f2])&#123;</span><br><span class="line">                f1++;</span><br><span class="line">            &#125;else if(nums1[f1]&gt;nums2[f2])&#123;</span><br><span class="line">                f2++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                arrl.add(nums1[f1]);</span><br><span class="line">                f1++;</span><br><span class="line">                f2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] jiao &#x3D; new int[arrl.size()];</span><br><span class="line">        for(int i&#x3D;0; i&lt;arrl.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jiao[i] &#x3D; arrl.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return jiao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式结果如下：<br>6 小时前    通过    2 ms    38.7 MB<br>6 小时前    通过    5 ms    38.4 MB    </p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和挖矿程序拼到底！</title>
      <link href="2020/11/11/centos-attack/"/>
      <url>2020/11/11/centos-attack/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>服务器被挖矿了，CPU占用一直是100%。</p><p>没有过多深入研究，照着网上几个处理方式执行了一些命令。无果</p><p>同事给出的建议就是重装系统，但是我偏不</p><p>我要和他拼到底！</p><p>由于是在太影响使用了，我先写个Shell脚本，每2小时清一次。以后有时间再收拾你！</p><h3 id="Shell思路"><a href="#Shell思路" class="headerlink" title="Shell思路"></a>Shell思路</h3><p>由于太久没写过Shell了，所以很简陋，以后再优化。</p><p>大概思路如下：</p><p>1 获取 [用户名] 的进程号</p><p>2 遍历进程号，获取其对应的CPU信息</p><p>3 判断CPU使用量是否大于85，如果大于，则杀死该进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">向上取整</span></span><br><span class="line">function ceil()&#123;</span><br><span class="line">  floor=`echo &quot;scale=0;$1/1&quot;|bc -l ` # 向下取整</span><br><span class="line">  add=`awk -v num1=$floor -v num2=$1 &#x27;BEGIN&#123;print(num1&lt;num2)?&quot;1&quot;:&quot;0&quot;&#125;&#x27;`</span><br><span class="line">  echo `expr $floor  + $add`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定时清理git用户开辟的进程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">USERNAME=&quot;root&quot;</span><br><span class="line">THRESHOLD=&quot;85&quot;</span><br><span class="line">TIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取git用户的所有进程号</span></span><br><span class="line">PIDS=`ps -ef | grep $USERNAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">循环PID</span></span><br><span class="line">for PID in $PIDS; do</span><br><span class="line"><span class="meta">#</span><span class="bash">statements</span></span><br><span class="line">CPU_DATA=`pgrep java | xargs ps -u --pid $PID | awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">for C in $CPU_DATA; do</span><br><span class="line"><span class="meta">#</span><span class="bash">如果CPU占用大于80%，杀死进程</span></span><br><span class="line">if [[ $C != &#x27;%CPU&#x27; ]]; then</span><br><span class="line">CEIL_C=`ceil $C`</span><br><span class="line">if [[ CEIL_C -gt $THRESHOLD ]]; then</span><br><span class="line">                echo $TIME &gt;&gt; mining.log</span><br><span class="line">echo &quot;git 用户的 $PID 已占用CPU $C&quot; &gt;&gt; touch mining.log</span><br><span class="line">kill -9 $PID</span><br><span class="line">echo &quot;已将 $PID 进程 killed&quot; &gt;&gt; touch mining.log</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖矿 </tag>
            
            <tag> mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIO/NIO/多路复用 原理与区别</title>
      <link href="2020/11/11/about-IO/"/>
      <url>2020/11/11/about-IO/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网络通信中BIO、NIO、多路复用相关的知识点非常多，网络上也有很多相关的技术文章。但是每个人的角度和切入点不同，知识涵盖的内容太多了，很难整理出一条清晰的思路。</p><p>我这两天尝试着脱离代码（因为加入代码Demo之后，篇幅增长，很多API也不是很熟悉，增加阅读的难度），单纯从操作系统网络通信的流程去梳理BIO、NIO，再到多路复用的优缺点。最终达到了解这些技术的联系和发展的目的。</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>此流程基于Java示例代码，代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> /IOTest 类</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/bio.png" alt="BIO"> </p><a id="more"></a><p>主线程：</p><p>1 服务端等待客户端连接，阻塞进程</p><p>2 检测到客户端连接，返回对应的文件描述符fd，并将连接移动到子线程</p><p>3 开始下一次循环，跳回第1步</p><p>子线程：</p><p>1 子线程中服务端等待客户端响应，阻塞进程</p><p>2 接收到客户端响应，子线程处理</p><p>3 开始下一次循环，跳回第1步</p><p>优势：可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。</p><p>问题：</p><p>1 线程的创建和销毁成本很高</p><p>2 线程本身占用较大内存</p><p>3 线程的切换成本是很高的</p><p>4 容易造成锯齿状的系统负载</p><blockquote><p>为了解决BIO的缺点，进入NIO</p></blockquote><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>此流程基于Java示例代码，代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> /NIOTest 类</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nio.png" alt="NIO"> </p><blockquote><p>本文介绍的NIO是操作系统网络通信中的NON-BLOCKING IO，是Java NIO的基础。<br>上图中的两个 <strong>主线程 循环</strong> 指的是没有开辟子线程。意思是服务端接收客户端连接和处理客户端请求都在同一个线程中。</p></blockquote><p>流程：</p><p>1 服务端请求客户端连接，非阻塞。如果没有直接返回null并向下执行</p><p>2 如果有客户端连接，请求消息响应，非阻塞。如果没有响应直接返回null并继续遍历客户端</p><p>3 遍历完所有客户端后，会重新开始循环，跳回第1步</p><p>优势：</p><p>1 规避多线程的问题</p><p>2 单线程解决多任务</p><p>问题：</p><p>客户端循环遍历时，不断进行用户态和内核态的切换，系统调用开销非常大</p><blockquote><p><strong><em>什么是用户态和内核态？</em></strong><br>我的理解就是权限不同。用户态的进程能够访问的资源受操作系统的控制，而运行在内核态的进程才可以访问系统中的硬件设别，例如网卡。</p><p>所以上面客户端循环遍历询问消息响应，会不断进行用户态和内核态的切换。</p><p><strong><em>开销大在哪？</em></strong></p><ul><li>1 保护现场</li><li>2 恢复现场</li><li>3 软中断</li><li>4 寻找中断向量表</li><li>5 找回调函数<br>等</li></ul></blockquote><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在NIO的基础上，通过一次系统调用将连接客户端响应询问移动到内核处理，而不是反复进行用户态和内核态的切换。</p><p>如果把每次系统调用理解成一条通路，那么这种把多次系统调用合并成一次的方式，就叫做**<em>多路复用**</em>。</p><p>例如：<a href="https://tech.meituan.com/2016/11/04/nio.html">美团 Java NIO浅析</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface ChannelHandler&#123;</span><br><span class="line">void channelReadable(Channel channel);</span><br><span class="line">void channelWritable(Channel channel);</span><br><span class="line">&#125;</span><br><span class="line">class Channel&#123;</span><br><span class="line">Socket socket;</span><br><span class="line">Event event;&#x2F;&#x2F;读，写或者连接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IO线程主循环:</span><br><span class="line">class IoThread extends Thread&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">Channel channel;</span><br><span class="line">while(channel&#x3D;Selector.select())&#123;&#x2F;&#x2F;选择就绪的事件和对应的连接</span><br><span class="line">  if(channel.event&#x3D;&#x3D;accept)&#123;</span><br><span class="line">     registerNewChannelHandler(channel);&#x2F;&#x2F;如果是新连接，则注册一个新的读写处理器</span><br><span class="line">  &#125;</span><br><span class="line">if(channel.event&#x3D;&#x3D;write)&#123;</span><br><span class="line">     getChannelHandler(channel).channelWritable(channel);&#x2F;&#x2F;如果可以写，则执行写事件</span><br><span class="line">&#125;</span><br><span class="line">if(channel.event&#x3D;&#x3D;read)&#123;</span><br><span class="line">getChannelHandler(channel).channelReadable(channel);&#x2F;&#x2F;如果可以读，则执行读事件</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Channel，ChannelHandler&gt; handlerMap;&#x2F;&#x2F;所有channel的对应事件处理器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Selector中的select函数会执行系统内核的调用：Linux 2.6之前是select、poll，2.6之后是epoll。</p><p>此流程基于Java示例代码，代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> /NIOEpollTest 类</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/epoll.png" alt="多路复用"> </p><h3 id="多路复用的实现方式"><a href="#多路复用的实现方式" class="headerlink" title="多路复用的实现方式"></a>多路复用的实现方式</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>流程：</p><p>1 客户端建立连接后返回fd</p><p>2 用二进制位表bitmap标记fds对应的位置，并将这个bitmap从用户态拷贝到内核态</p><p>3 收到客户端响应，将对应的bitmap位标记为1</p><p>4 程序处理消息，重新创建bitmap，循环下一次</p><p>缺点：</p><p>1 bitmap默认最大限制1024位</p><p>2 bitmap不可重用，每次循环重新创建</p><p>3 用户态和内核态切换开销</p><p>4 轮询所有的客户端处理消息 O(n)</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>流程：</p><p>与select相似，select中用bitmap标记fds，在poll中自己声明了结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">short</span> events;</span><br><span class="line"><span class="keyword">short</span> revents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传输pollfd数组，解决了select中fds限制1024位的问题</p><p>其次，内核将响应客户端对应的pollfd结构体中的revnets标记为1，说明这个客户端有消息响应</p><p>处理消息时将这个pollfd的revnets重置即可，不用在重新创建数组，所以select中每次循环重新创建bitmap的问题也被解决了</p><p>遗留问题：</p><p>1 由于fds文件描述符存储在用户空间，拷贝到内存空间处理一定会涉及到用户态和内核态的切换。这个系统调用有一定开销</p><p>2 每次内核态返回的信息是全量信息，要轮询处理，时间复杂度是 O(n)，如果连接数过多，也会有很多无意义的开销</p><p><strong><em>这两个问题留给 epoll</em></strong></p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>流程：</p><p>1 建立epoll对象时在内核分配资源，其数据结构是红黑树。添加和检索的时间复杂度 O(lgn)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br></pre></td></tr></table></figure><p>2 建立连接时，在红黑树中存储 epoll_event结构体，其中包含fd和events等信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;  </span><br></pre></td></tr></table></figure><p>3 调用epoll_wait收集响应的连接，放入一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;  </span><br></pre></td></tr></table></figure><p>到此为止，上面提到的多路复用的所有缺点都得以解决。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p><a href="https://github.com/YorickYu/JPP/raw/main/IO_xmind/IO.png">网络通信</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BIO </tag>
            
            <tag> NIO </tag>
            
            <tag> 多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap resize loTail.next=e loTail=e</title>
      <link href="2020/11/06/hashmap-resize-lotail/"/>
      <url>2020/11/06/hashmap-resize-lotail/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap扩容的过程包含了很多巧妙的思考，思想简单易懂，但是代码的实现真的让人折服！</p><p>今天快速浏览resize方法时，被两行代码绕住了：</p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/loTail.next%20%3D%20e.png" style="zoom:50%;" /><p>可能是对于引用类型的理解不够深刻吧，这两行代码真的看了我一天！网上也很少有人分析这两行代码（可能因为太容易了吧）</p><p>最后我自己写了个Demo，算是把这个操作搞清楚了。因为是引用类型的指针指向问题，所以画图也不太好理解，只能自己写个Demo，一点点Debug分析过程。</p><p>相关代码在：<a href="https://github.com/YorickYu/JPP">Jpp</a> /TailInsert类中</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="准备一个简单的链表对象"><a href="#准备一个简单的链表对象" class="headerlink" title="准备一个简单的链表对象"></a>准备一个简单的链表对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(K key, V value, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化过程"><a href="#简化过程" class="headerlink" title="简化过程"></a>简化过程</h2><p>先看下面的代码，理解这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node a &#x3D; null;</span><br><span class="line">Node b &#x3D; null;</span><br><span class="line">Node c &#x3D; new Node(&#39;c&#39;, &#39;c&#39;, null);</span><br><span class="line">b &#x3D; c;</span><br><span class="line">a &#x3D; c;</span><br><span class="line">c &#x3D; new Node(8,8, null);</span><br><span class="line">a.next &#x3D; c;</span><br><span class="line">a &#x3D; c;</span><br></pre></td></tr></table></figure><h3 id="代码1-5行"><a href="#代码1-5行" class="headerlink" title="代码1-5行"></a>代码1-5行</h3><p>声明了a，b两个Node类型的引用，声明c指向一个Node@478对象</p><p>然后把a和b都指向了Node@478对象。如下图所示：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep1.jpg" alt="p1"></p><h3 id="代码-6行"><a href="#代码-6行" class="headerlink" title="代码 6行"></a>代码 6行</h3><p>创建了一个新的Node@479对象，将c引用指向这个对象。如下图所示：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep2.jpg" alt="p1"></p><h3 id="代码-7行"><a href="#代码-7行" class="headerlink" title="代码 7行"></a>代码 7行</h3><p>在Node@478中有一个next属性，a.next = c;表示将Node@478的next指向c引用指向的地址(即Node@479)</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep3.jpg" alt="p1"></p><h3 id="代码-8行"><a href="#代码-8行" class="headerlink" title="代码 8行"></a>代码 8行</h3><p>a = c; 就是将a的引用重新指向c引用指向的地址(即Node@479)</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep4.jpg" alt="p1"></p><p>所以最终的结果就是：</p><p>a，c引用指向相同的Node@479对象</p><p>b指向Node@478对象，其中Node@478的next引用指向Node@479对象</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pend.png"></p><p>理解了上面的过程，下面就非常容易了 ^ ^</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><p>创建链表并插入10个元素（尾插）来模拟HashMap数组中某一个节点的链表。</p><blockquote><p>JDK1.8中，链表长度超过 <strong>变树阈值</strong> 时会将链表变化成红黑树<br>这个变化需要满足两个条件：1 链表长度超过变树阈值 2 HashMap的size大于64</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node tab = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>); <span class="comment">// node链表</span></span><br><span class="line">Node p = tab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Node tail = <span class="keyword">new</span> Node(i, i, <span class="keyword">null</span>); <span class="comment">// 最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = tail;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 尾插</span></span><br><span class="line">        Node e;</span><br><span class="line">        <span class="keyword">while</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = tail;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仿写resize核心代码"><a href="#仿写resize核心代码" class="headerlink" title="仿写resize核心代码"></a>仿写resize核心代码</h3><p>在HashMap扩容时有一个很巧妙的操作，就是数组长度扩容至原先两倍时，重新计算链表节点的插入角标会将原链表随机分布到新数组的两个位置：1 原来角标的位置 2 原角标+原数组长度的位置</p><p>而这个操作在JDK1.7和JDK1.8中的思想是相同的，不过实现方式略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">假设：</span><br><span class="line">现在有两个链表节点</span><br><span class="line">他们的hash值低8位分别是 0110 1011 、1001 1011</span><br><span class="line">扩容前数组长度为16，扩容长度变为32</span><br><span class="line">扩容前他们都在数组角标11的位置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK1.7 e.hash &amp; (length-1)</span><br><span class="line">&#x2F;&#x2F; 第一个节点</span><br><span class="line">0110 1011</span><br><span class="line">0001 1111</span><br><span class="line">&amp; 0000 1011 角标11</span><br><span class="line">&#x2F;&#x2F; 第二个节点</span><br><span class="line">1001 1011</span><br><span class="line">0001 1111</span><br><span class="line">&amp; 0001 1011 角标27</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK1.8 (e.hash &amp; oldCap) &#x3D;&#x3D; 0</span><br><span class="line">&#x2F;&#x2F; 第一个节点</span><br><span class="line">0110 1011</span><br><span class="line">0001 0000</span><br><span class="line">&amp; 0000 0000 结果0，在原数组位置</span><br><span class="line">&#x2F;&#x2F; 第二个节点</span><br><span class="line">1001 1011</span><br><span class="line">0001 0000</span><br><span class="line">&amp; 0001 0000 结果1，在新数组位置</span><br></pre></td></tr></table></figure><p>JDK1.7中，直接通过hash值与新数组长度-1 按位与 得到新角标</p><p>JDK1.8中，通过计算hash值对应的原数组位置是否为0，如果为0则插入tab[j]，否则插入tab[j+oldCap]</p><hr><p>我模拟的Demo中没有设计这么多复杂的数据，所以简化为节点value值的奇偶判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Node loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">Node next;</span><br><span class="line">Node e = tab;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)e.value % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 进入次判断的节点为 0,2,4,6,8</span></span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)e.value % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>以取模结果等于0为例：</p><p>第一次进入，loHead = 0, loTail = 0。loTail和loHead指向相同的内存地址</p><p>第二次进入，loTail.next = 2会移动loHead.next指向 2。随后loTail = 2，即loHead.next和loTail指向相同的内存地址</p><p>第三次进入，loTail.next = 4也就是loHead.next.next指向4。随后loTail = 4，即loHead.next.next和loTail指向相同的内存地址</p><p>以此类推，如下图：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/hashmap%20resize%20%281%29.jpg"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面就是我对 <code>loTail.next = e; loTail = e;</code> 这两行代码的理解。</p><p>进一步思考，为什么HashMap在 JDK1.7 的时候会选择头插法插入元素？</p><p>不考虑JDK1.7中resize时的循环引用问题，我认为头插法无论是从理解的角度，还是从代码实现的角度都更胜一筹。甚至还可能能稍微优化一些查询的速率。</p><p>就拿上面Demo中的尾插生成测试链表为例，我的写法是仿照JDK1.8的，中间要声明很多局部变量，所以你会看到 JDK1.8 的源码中有很多判断中赋值的操作。如果不这么写的话，估计JDK1.8的源码会再多几百行（本身实现了一套红黑树，代码量相较1.7膨胀了几乎一倍）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
            <tag> resize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode reverse-words</title>
      <link href="2020/11/03/reverse-words/"/>
      <url>2020/11/03/reverse-words/</url>
      
        <content type="html"><![CDATA[<p>LeetCode p151 逐个翻转字符串中的每个单词</p><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ReverseWords类中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给定一个字符串，逐个翻转字符串中的每个单词。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 无空格字符构成一个 单词 。 </span><br><span class="line">&#x2F;&#x2F; 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 </span><br><span class="line">&#x2F;&#x2F; 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;the sky is blue&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;blue is sky the&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;  hello world!  &quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;world! hello&quot;</span><br><span class="line">&#x2F;&#x2F;解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;a good   example&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;example good a&quot;</span><br><span class="line">&#x2F;&#x2F;解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 4： </span><br><span class="line">&#x2F;&#x2F; 输入：s &#x3D; &quot;  Bob    Loves  Alice   &quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;Alice Loves Bob&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 5： </span><br><span class="line">&#x2F;&#x2F; 输入：s &#x3D; &quot;Alice does not even like bob&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;bob like even not does Alice&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; s.length &lt;&#x3D; 104 </span><br><span class="line">&#x2F;&#x2F; s 包含英文大小写字母、数字和空格 &#39; &#39; </span><br><span class="line">&#x2F;&#x2F; s 中 至少存在一个 单词 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 进阶：  </span><br><span class="line">&#x2F;&#x2F; 请尝试使用 O(1) 额外空间复杂度的原地解法。 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Related Topics 字符串 </span><br><span class="line">&#x2F;&#x2F; 👍 240 👎 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        String[] strings &#x3D; s.split(&quot;\\s+&quot;);</span><br><span class="line">        HashMap m &#x3D; new HashMap();</span><br><span class="line">        int modCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; strings.length; i++) &#123;</span><br><span class="line">            String innerstring &#x3D; strings[i];</span><br><span class="line">            if (!innerstring.equals(&quot;&quot;)) &#123;</span><br><span class="line">                m.put(modCount++, innerstring);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (;modCount&gt;0;) &#123;</span><br><span class="line">            sb.append(m.get(--modCount));</span><br><span class="line">            if (modCount !&#x3D; 0)</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解题思路就是用Java现有的API配合正则去拆分传入的字符串s，得到一个字符串数组</p><p>然后利用HashMap查找O(1)的特性，将value值按序存入key，并记录key值</p><p>最后倒序key值，取出value即可。</p><blockquote><p>这里其实一次for循环逆序遍历也可以得出答案，时间复杂度不会有太大差别，因为本身字符串数组长度不会很大。<br>我只是单纯的像仿照HashMap源码中modCount的想法记录一下编辑次数，所以for了两次。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String reverseWords(String s) &#123;</span><br><span class="line">    String[] words &#x3D; s.trim().split(&quot;\\s+&quot;);</span><br><span class="line">    int len &#x3D; words.length;</span><br><span class="line">    StringBuilder ans &#x3D; new StringBuilder();</span><br><span class="line">    ans.append(words[len - 1]);</span><br><span class="line">    for (int i &#x3D; len - 2; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">        if (words[i].equals(&quot;&quot;))</span><br><span class="line">            continue;</span><br><span class="line">        ans.append(&quot; &quot; + words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，学了一下网上一些时间复杂度很低的解法，耗时的步骤都来源于数组的 <code>split</code> 方法。</p><p>想要突破的可以自定义一个数组拆分的方法。</p><p>还有，基本可以确定的是，使用 <code>StringBuilder</code> 的API拼接数组比直接使用 String 速度要快。</p><blockquote><p>关于String拼接的性能，阿里手册中有专门收录：<a href="https://developer.aliyun.com/article/756752?spm=a2c6h.12873639.0.0.6fee1e8brXp7fY">为什么不建议在 for 循环中使用“+”进行字符串拼接？</a></p></blockquote><p>for循环中5万次字符串拼接性能差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ cost:5119</span><br><span class="line">StringBuilder cost:3</span><br><span class="line">StringBuffer cost:4</span><br><span class="line">concat cost:3623</span><br><span class="line">StringUtils.join cost:25726</span><br></pre></td></tr></table></figure><p>先后提交了2次，结果如下：</p><p>11 分钟前    通过    10 ms    38.9 MB    Java<br>20 分钟前    通过    12 ms    39.3 MB    Java</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.7 ConcurrentHashMap 两次数组下标计算问题</title>
      <link href="2020/11/03/concurrenthashmap-two-array-index/"/>
      <url>2020/11/03/concurrenthashmap-two-array-index/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ConcurrentHashMap结构如下:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p><p>Segment[]数组的长度在ConcurrentHashMap的构造方法中由并发级别 <code> DEFAULT_CONCURRENCY_LEVEL</code> 计算得出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且初始化完成后，Segment[]数组不会再扩容。</p><p>HashEntry[]数组的长度在ConcurrentHashMap的构造方法中由初始化容量 <code> DEFAULT_INITIAL_CAPACITY</code> 和并发级别 <code> DEFAULT_CONCURRENCY_LEVEL</code> 计算得出，且最小值为2，向上取值时为2的整数幂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">if (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line">int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; &#x2F;&#x2F; 最小值2</span><br><span class="line">while (cap &lt; c) &#x2F;&#x2F; 保证取值是2的整数幂</span><br><span class="line">    cap &lt;&lt;&#x3D; 1;</span><br></pre></td></tr></table></figure><p>初始化完成后，HashEntry[]数组会扩容。而且由自旋锁和volatile保证了线程安全性</p><p>由此可见，ConcurrentHashMap元素插入需要两次计算数组下标，让我们分析一下源码中是如何设计的。</p><a id="more"></a><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用的 <strong><em><a href="http://d0evi1.com/wang-jenkins-hash/">Wang/Jenkins Hash算法</a></em></strong> </p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>segmentShift在构造方法中计算的出：32 - sshift，sshift记录值为Segment[]数组长度值为2的几次幂。</p><p>例：</p><p>并发级别为16，通过构造方法中的while遍历，得到：ssize为32，sshift为5。</p><p>即Segment[]数组的数组长度ssize为32，sshift为5 – $2^5$</p><p>所以，</p><p>上面第4行代码表示让hash值高位(Segment数组长度)决定下标。</p><h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第6行代码表示让hash值的低位(HashEntry数组长度)决定下标。</p><h2 id="他是怎么想到的？"><a href="#他是怎么想到的？" class="headerlink" title="他是怎么想到的？"></a>他是怎么想到的？</h2><p>源码中真的有好多巧妙的设计值得学习和思考，最近总有一个问题萦绕在耳边：”他们到底TM是怎么想出来的？“</p><p>也太秀了！华丽的像是投机取巧～</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> put </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap modCount fast-fail X原子性</title>
      <link href="2020/11/01/hashmap-modCount/"/>
      <url>2020/11/01/hashmap-modCount/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap源码中定义的成员变量并不多，其中我们最不熟悉的应该就是modCount，那么它到底是做什么的呢？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/modcount.jpg"></p><p><font color=red>如果你没时间思考这篇文章，你可以直接跳转到 <a href="#%E7%BB%93%E8%AE%BA">9.结论</a> 处</font></p><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><p>modCount在HashMap中记录的是HashMap对象被修改的次数，这里专业的说法是集合在结构上修改时被会记录在modCount中。</p><blockquote><p>文中源码版本为 JDK1.7，modCount的部分在JDK1.8中作用是相同的。只因为JDK1.7中源码比较简洁，所以本文选用JDK1.7来缩减篇幅。</p></blockquote><p>在源码中记录到的modCount++的方法包括：</p><ul><li>HashMap put方法</li><li>HashMap的remove-&gt;removeEntryForKey方法 通过key移除元素</li><li>HashMap的removeMapping方法，通过object移除元素</li><li>HashMap的clear方法</li></ul><p>从这里可以看出，结构上的修改主要是添加和删除两部分。</p><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>我们都知道在JDK1.7中HashMap是线程不安全的，这个 <strong>不安全</strong> 我是分两方面理解的：</p><p><strong>1 多线程数组扩容时出现循环链表问题</strong></p><p>因为扩容时链表顺序会反转，所以多线程操作时可能会出现循环链表的情况，那么在get方法时就会死循环</p><blockquote><p>JDK1.8中也修复了这个问题</p></blockquote><p><strong>2 多线程读写时造成数据混乱的问题</strong></p><p>HashMap中有引入了一个 <strong>fast-fail</strong> 的概念，目的是避免高并发读写造成的数据错乱的隐患。</p><h2 id="expectedModCount"><a href="#expectedModCount" class="headerlink" title="expectedModCount"></a>expectedModCount</h2><p>expectedModCount这个变量被记录在HashIterator迭代器中。顾名思义，表示期望的修改次数，当期望修改的次数不等于实际修改的次数时，就会触发 <strong>fast-fail</strong> 快速失败的容错处理</p><h2 id="fast-fail"><a href="#fast-fail" class="headerlink" title="fast-fail"></a>fast-fail</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">    if (modCount !&#x3D; expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器调用 next() 方法时会调用 nextEntry() 方法，方法中首先会判断 modCount 与 expectedModCount 是否相等</p><p>如果不相等直接抛出 java.util.ConcurrentModificationException 异常</p><blockquote><p><strong>GeeksForGeeks中的解释为：</strong></p><p>In multi threaded environment, if during the detection of the resource, any method finds that there is a concurrent modification of that object which is not permissible, then this ConcurrentModificationException might be thrown.</p><ol><li>If this exception is detected, then the results of the iteration are undefined.</li><li>Generally, some iterator implementations choose to throw this exception as soon as it is encountered, called fail-fast iterators.</li></ol><p>For example: If we are trying to modify any collection in the code using a thread, but some another thread is already using that collection, then this will not be allowed.</p></blockquote><p>在多线程环境中，如果在检测资源期间，任何方法发现该对象存在并发修改，而这是不允许的，则可能会抛出此ConcurrentModificationException。</p><p>1 如果检测到此异常，则迭代结果不确定。</p><p>2 通常，某些迭代器实现选择将遇到此异常的异常立即抛出，称为快速失败迭代器。</p><p>例如：如果我们试图使用一个线程来修改代码中的一个集合，但是另一个线程已经在使用该集合，这种做法是不被允许的</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ConcurrentModificationExceptionDemo类中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">for (int i &#x3D; 0; i &lt;100 ; i++) &#123;</span><br><span class="line">    m.put(String.valueOf(i), &quot;value&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Iterator iterator &#x3D; m.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String next &#x3D; (String) iterator.next();</span><br><span class="line">            if (Integer.parseInt(next) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;thread 1&quot;);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Iterator iterator  &#x3D; m.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String next &#x3D; (String) iterator.next();</span><br><span class="line">            System.out.println(m.get(next));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这里第一个线程中的 <code>System.out.println(&quot;thread 1&quot;);</code> 的作用是 <strong><em>触发数据和内存同步</em></strong>。</p><blockquote><p>这部分内容和寄存器的 <strong><em>缓存行</em></strong> 知识有关，如果不触发数据和内存同步，第二个线程无法正确获取modCount。</p></blockquote><h2 id="单线程错误案例"><a href="#单线程错误案例" class="headerlink" title="单线程错误案例"></a>单线程错误案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">m.put(&quot;key1&quot;, &quot;value2&quot;);</span><br><span class="line">m.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">for (String key: m.keySet()) &#123;</span><br><span class="line">    if (key.equals(&quot;key2&quot;)) &#123;</span><br><span class="line">        m.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码块也有可能发生 fast-fail</p><p>我们来看一下上面代码块编译后的class文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">m.put(&quot;key1&quot;, &quot;value2&quot;);</span><br><span class="line">m.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">Iterator i$ &#x3D; m.keySet().iterator();</span><br><span class="line">while(i$.hasNext()) &#123;</span><br><span class="line">    Object key &#x3D; i$.next();</span><br><span class="line">    if (key.equals(&quot;key2&quot;)) &#123;</span><br><span class="line">        m.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看应该就很容易理解了，而且这个错误也很容易发生。</p><p>在迭代器遍历的过程中，会将key值为“key2”的元素移除。移除时调用的HashMap的remove方法会对modCount值+1，但是这个方法并不会同步expectedModCount的值。所以在下一次迭代器调用i$.next();方法时，会发生异常。</p><p>expectedModCount // For fast-fail：在以下方法会同步modCount值</p><ul><li>HashIterator的构造方法</li><li>HashIterator的remove方法</li></ul><p>所以将上面移除元素的代码。替换为 <code>i$.remove();</code> 就可以了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于 i++ 计算不是原子性的怀疑：</p><p>HashMap源码记录modCount++这个计算方式在多线程操作时如果不能保证原子性，那么岂不是也有可能触发ConcurrentModificationException异常？</p><p>验证过程：<br>1 因为HashMap的put操作会进行modCount++<br>2 modCount声明时也没有指明<strong>volatile</strong><br>那么多线程put是否会造成modCount的值不准确？</p><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ConcurrentModificationExceptionDemo类中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void atomicTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    HashMap m &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">                m.put(i, String.valueOf(i).hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 10000; i &lt; 20000; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">                m.put(i, String.valueOf(i).hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(5000);</span><br><span class="line">    Iterator iterator &#x3D; m.keySet().iterator();</span><br><span class="line">    iterator.next(); &#x2F;&#x2F; 对比modCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>运行的结果是，如果循环次数不多，最后可以保证modCount的数值正确。但是提升循环插入的次数，会锁住一个线程，导致其他线程的数据没有插入成功，但是modCount的值依然是正确的。</del></p><p><del>具体这个魂循环次数设定的阈值，我也没有过多尝试。至少目前我没有因为++计算不是原子性的原因出现过fast-fail</del></p><p>运行结果有意外收获:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/modcount%2B%2B%2B.jpg"></p><p>从上图可以看出，不仅在多线程写入的时候modCount的值无法保证（从expectedModCount看出），而且HashMap的size也不满足期望（因为多线程put时，两个线程的key不重复）</p><p>为了再次证明我的猜测，可以在多线程中添加 <code>System.out.println(i);</code> 代码，来达到内存同步的目的</p><p>结果不出所料：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/sysmodcount%2B%2B.jpg"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 HashMap多线程读写时可能会抛出ConcurrentModificationException异常，这是fast-fail快速失败机制。</p><p>2 fast-fail实现的原理是判断modCount和expectedModCount是否相等</p><p>3 modCount++在多线程操作时无法保证原子性，甚至HashMap整个put方法都出现了问题</p><blockquote><p>PS：所以在JDK1.7的ConcurrentHashMap中出现大量 <strong><em>UNSAFE</em></strong> 和 <strong><em>volatile</em></strong> 关键字，同时加入了ReentrantLock（在JDK1.8中由于 <code>synchronized</code>的性能得到优化，将锁换成了<code>synchronized</code>）。</p></blockquote><blockquote><p>PS：fast-fail的问题，不仅仅出现在HashMap中，Java中很多集合类型都有这个机制。<br>同时，这个问题也被收录在阿里开发手册中：<a href="https://developer.aliyun.com/article/756753?spm=a2c6h.12873639.0.0.6fee1e8bz6HCIu">为什么阿里巴巴禁止在 foreach 循环里进行元素的 remove/add 操作</a></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上文所有代码片段都是基于JDK1.7，虽然JDK1.8中对HashMap做了较大的改动。但是文章的思路和结论都是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
            <tag> fast-fail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IHAVEAQUESTION - JDK1.7 HashMap 链表头插疑问？</title>
      <link href="2020/10/31/question-of-hashmap-put/"/>
      <url>2020/10/31/question-of-hashmap-put/</url>
      
        <content type="html"><![CDATA[<h2 id="IHAVEAQUESTION"><a href="#IHAVEAQUESTION" class="headerlink" title="IHAVEAQUESTION"></a>IHAVEAQUESTION</h2><p>为什么JDK1.7中HashMap链表插入时要在 <strong>遍历完一遍链表</strong> 后，再采用头插法？</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>HashMap在JDK1.7中采用 数组+链表 的存储结构。</p><p>数组的角标是在key值hashCode()的基础上进行多次高位移动的扰动后尽量保持散列，代码片段如下：</p><p>1 hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h &#x3D; hashSeed;</span><br><span class="line">    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^&#x3D; k.hashCode();</span><br><span class="line">    &#x2F;&#x2F; 多次让高位参与运算，扰动函数</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 % -&gt; &amp;</p><p>采用更搞笑的 &amp;运算。这里length为数组的长度，源码中巧妙的设计数组的长度必须保持2的整数幂。这样设计才能保证length-1计算后得到 <strong>全1</strong> 的的二进制序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组的index确认后，就可以将键值对插入相应位置的链表了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    ... </span><br><span class="line">    int hash &#x3D; hash(key); &#x2F;&#x2F; hash</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length); &#x2F;&#x2F; %</span><br><span class="line">    &#x2F;&#x2F; 判断hashmap中有没有存在相同的key，如果有的话将这个key原来的value覆盖，并返回</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 扩容，头插</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的源码部分只保留了关键部分</p></blockquote><p>我们都知道JDK1.7中链表的插入方式是头插。头插与尾插相比是节省了一次链表全遍历的时间。直接采用下面代码即可完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 链表头插</span><br><span class="line">table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, table[bucketIndex]);</span><br></pre></td></tr></table></figure><p>这部分代码在put方法的addEntry()中，addEntry()方法在链表头插之前做了扩容操作。</p><p>但是奇怪的是，在上面put方法中有一段循环遍历链表的代码，这段代码的目的只是检查要插入的Key值是否已经存在在HashMap中，如果存在就修改，同时将原来的值返回。</p><p><strong><em>这我就很疑惑了，为什么这里明明已经遍历过一遍链表了，为什么不多写一个else，如果没有找到存在的Key值，直接将目标键值对插入在链表尾部呢？都已经遍历完了，插个值咋了？</em></strong></p><p>可能的原因只能是扩容时机不好把握？</p><p>HashMap的扩容机制是键值对size超过阈值后，数组长度扩充至之前的两倍，然后将原本下标的全部链表迁移（这个迁移的过程会倒序链表，也可能分散链表中的数据，以缩短链表的长度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 同一个元素转移后的下标有两种情况。</span><br><span class="line">            &#x2F;&#x2F; 1 与原来相同 2 在原来下标基础上加原数组长度</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这样遍历头插后，链表的顺序与之前相反</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解HashMap源码的朋友可能都知道，这个扩容和迁移的代码在高并发时并不是线程安全的。可能出现循环链表，以至于get时陷入死循环。</p><p>也许正因如此，需要将链表插入和扩容的代码从之前的循环中独立出来。并采用头插的方式，尽量再循环一次链表。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上都是我在阅读HashMap源码后产生疑问，独立思考，自我解答的过程。</p><p>可能是很少有人产生跟我相似的疑问，所以我在网上也没能查找到准确的资料和答案。</p><p>所以以上全是自己的推断和猜测。毕竟HashMap源码不论是在数据结构还是算法思想层面都是非常优雅的。别人这么设计肯定是有原因的。哈哈</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 0/1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象的内存布局</title>
      <link href="2020/10/29/memory-layout-of-java-object/"/>
      <url>2020/10/29/memory-layout-of-java-object/</url>
      
        <content type="html"><![CDATA[<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>对象的存储涉及内存的三部分：<strong>方法栈</strong>（存储指针）、<strong>方法区</strong>（存储类信息、常量、静态变量）、<strong>堆</strong>（存储对象的实例数据）。</p><p>对象在内存中存储的结构由三部分组成：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。</p><h3 id="Java对象在内存中存储布局"><a href="#Java对象在内存中存储布局" class="headerlink" title="Java对象在内存中存储布局"></a>Java对象在内存中存储布局</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg" alt="Java对象在内存中存储布局"></p><a id="more"></a><blockquote><p>注意：下文涉及到的占位大小都是基于64位操作系统</p></blockquote><h4 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h4><p>占用16个字节</p><p>前8个字节是markword，会包含锁信息、GC信息、hashCode</p><p>后面4个字节为class pinter，指针压缩，内存容量超过32G会存8位</p><p>数组对象的对象头占用24个字节，启用压缩之后占用16个字节。</p><h5 id="1-markword结构"><a href="#1-markword结构" class="headerlink" title="1 markword结构"></a>1 markword结构</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/markword.png" alt="存储内容"></p><h5 id="2-Klass-Pointer（类型指针）"><a href="#2-Klass-Pointer（类型指针）" class="headerlink" title="2 Klass Pointer（类型指针）"></a>2 Klass Pointer（类型指针）</h5><p>klass pointer存储的是该对象所属的类在方法区的地址，所以是一个指针，默认Jvm对指针进行了压缩，用4个字节存储，如果不压缩就是8个字节。</p><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，这块占用4个字节。因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>实例数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。也就是说，除去静态变量和常量值放在方法区，非静态变量的值是随着对象存储在堆中的。<br>因为修改静态变量会反映到方法区中class的数据结构中，故而推测对象保存的是静态变量和常量的引用。</p><h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><p>用于确保对象的总长度为8字节的整数倍。<br>HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的。因此需要对齐补充字段确保整个对象的总长度为8的整数倍。</p><h4 id="JOL-java-object-layout-验证"><a href="#JOL-java-object-layout-验证" class="headerlink" title="JOL - java object layout 验证"></a>JOL - java object layout 验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/JolTest类中查看。</p><blockquote><p><a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a> 是一个Java技术分享的平台，欢迎大家加入</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jol.png" alt="JOL"></p><hr><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th>类型名称</th><th>存储大小</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>char</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr></tbody></table><h4 id="引用数据类型（Object）"><a href="#引用数据类型（Object）" class="headerlink" title="引用数据类型（Object）"></a>引用数据类型（Object）</h4><p>在栈中存储一个引用（指针），指向堆中的对象本身。</p><blockquote><p>有看到一种说法：<br>一个普通的引用类型对象，会在内存中消耗24个字节，p指针占8个字节，Object对象占16个字节。</p></blockquote><p>我的理解是引用类型的指针存储在方法栈中，即klass pointer，指向方法区中的类信息，堆中存放的是对象的成员变量。</p><p>这里就引出很多问题，因为时间和能力的关系，没有来得及考证：<br>1 引用类型中声明的基本数据类型到底存放在哪里？<br>2 引用类型中的属性，它的指针是存在哪里？<br>这类问题很绕，就像iOS中的结构体是声明在栈中的，但是结构体中声明一个class类型的属性又是存在在堆中的。</p><p>所以，不过分纠结的话，只要了解一个引用类型的变量会在栈中存储一个指针，指向堆中的对象本身即可。以Object对象为例就是16字节。</p><p>此外，这里还有一个压缩指针的概念（+UseCompressedOops），目的是提高内存的利用率。将原本占位8字节的指针压缩成4字节。</p><h4 id="字段重排序"><a href="#字段重排序" class="headerlink" title="字段重排序"></a>字段重排序</h4><p>为了更高效的使用内存，实例数据字段将会重排序。排序的优先级为：<br>long = double &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class OrderTest&#123;</span><br><span class="line">    byte a;</span><br><span class="line">    int c;</span><br><span class="line">    boolean d;</span><br><span class="line">    long e;</span><br><span class="line">    People f;</span><br><span class="line">&#125;</span><br><span class="line">class People &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>并不是完全符合，但是确实存在字段重排序</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ordertest.png" alt="order"></p><h3 id="对象存储在堆上还是栈上？"><a href="#对象存储在堆上还是栈上？" class="headerlink" title="对象存储在堆上还是栈上？"></a>对象存储在堆上还是栈上？</h3><p>看下面这段代码，循环创建一亿次Object对象，通常理解一个空Object对象创建会在栈中存在一个4字节的指针，指向堆中的对象16字节。<br>循环创建一亿次大概会占用1.6G的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    new Object();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 38ms</p></blockquote><p><strong><em>这是为什么？</em></strong></p><p>这里要提出一个概念<strong>指针逃逸</strong>，new Object() 新建的对象并没有在外部被使用，所以它被优化为在栈上分配，我们知道方法执行完成后该栈帧就会被清空，所以也就不会有GC。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    Object o &#x3D; new Object();</span><br><span class="line">    o.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 8014ms</p></blockquote><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/NewObject类中查看。</p><p>结论: 虚拟机指针逃逸分析是默认开启的，对象不会逃逸的时候优先在栈上分配，否则在堆上分配。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JOL </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tri-colour marking</title>
      <link href="2020/10/21/Tri-colour-marking/"/>
      <url>2020/10/21/Tri-colour-marking/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/gc-1.gif"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU 乱序执行反证</title>
      <link href="2020/10/19/CPU-Out-of-Order/"/>
      <url>2020/10/19/CPU-Out-of-Order/</url>
      
        <content type="html"><![CDATA[<h3 id="循序运行"><a href="#循序运行" class="headerlink" title="循序运行"></a>循序运行</h3><p>主条目：指令周期<br>在早期的处理器中，指令的执行一般在以下的步骤中完成：</p><p>1 指令获取。<br>2 如果输入的运算对象是可以获取的（比如已经存在于寄存器中），这条指令会被发送到合适的功能单元。如果一个或者更多的运算对象在当前的时钟周期中是不可获取的（通常需要从主存获取），处理器会开始等待直到它们是可以获取的。<br>3 指令在合适的功能单元中被执行。<br>4 功能单元将运算结果写回寄存器。</p><h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>这种范式通过以下步骤挑选可执行的指令先运行：</p><p>1 指令获取。<br>2 指令被发送到一个指令序列中（也称执行缓冲区或者保留站）。<br>3 指令将在序列中等待直到它的数据运算对象是可以获取的。然后指令被允许在先进入的、旧的指令之前离开序列缓冲区。<br>4 指令被分配给一个合适的功能单元并由之执行。<br>5 结果被放到一个序列中。<br>6 仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器中。这个过程被称为毕业或者退休周期。</p><p>乱序执行的重要概念是实现了<strong>避免计算机在用于运算的对象不可获取时的大量等待。</strong>在上述文字的要点中，乱序执行处理器避免了在顺序执行处理器处理过程第二步中当指令由于运算数据未到位所造成的等待。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; a * 5</span><br><span class="line">v &#x3D; b++</span><br><span class="line">c &#x3D; a + 3</span><br></pre></td></tr></table></figure><p>由于1与3可并发运行，而2之b无法随即获得，因此可以先计算乘法1与加法3，再运行2。</p><a id="more"></a><h3 id="证明CPU乱序执行存在"><a href="#证明CPU乱序执行存在" class="headerlink" title="证明CPU乱序执行存在"></a>证明CPU乱序执行存在</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class OutOfOrder &#123;</span><br><span class="line">    private static int x &#x3D; 0, y &#x3D; 0;</span><br><span class="line">    private static int a &#x3D; 0, b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int i &#x3D; 0; &#x2F;&#x2F; 记录次数</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x &#x3D; 0; y &#x3D; 0;</span><br><span class="line">            a &#x3D; 0; b &#x3D; 0;</span><br><span class="line">            Thread one &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    a &#x3D; 1;</span><br><span class="line">                    x &#x3D; b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread two &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    b &#x3D; 1;</span><br><span class="line">                    y &#x3D; a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();two.start();</span><br><span class="line">            one.join();two.join();</span><br><span class="line">            if (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D;0) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;次，出现(&quot;+x+&quot;,&quot;+y+&quot;)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常执行期待的结果不会出现x和y同时为0的情况<br>demo中测试的是语句级乱序的现象，语句级乱序的发生说明必定存在指令级乱序<br>如果出现则说明CPU存在乱序执行</p><p>结果：<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/outoforder.png"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/12/hello-world/"/>
      <url>2020/10/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello ~ Here is a personal blog.<br>yloopdaed, the reverse spelling of deadpooly which is my network aka.<br>This blog is serve to my Github project - <a href="https://github.com/YorickYu/JPP">JPP</a> (Java promotion process).<br>you can also check out my jianshu channel - <a href="https://www.jianshu.com/u/9901b7042663">YYYYYY25</a> where stores many iOS articles i wrote before.</p><hr><p>建站的目的是为 <a href="https://github.com/YorickYu/JPP">JPP</a> 开源项目提供文章支持<br>本身自己也有记录和分享的习惯，之前的技术分享集中在简书 <a href="https://www.jianshu.com/u/9901b7042663">YYYYYY25</a><br>技术类的分享可能会在本站和简书同步更新，之前的技术类文章分享会选择性的移至本站</p><p>✨ Love &amp; Peace ❤️</p><hr><p><strong>小朋友，你是否有很多问好？</strong></p><ul><li>😄 <a href="https://github.com/YorickYu/IHAVEAQUESTION">IHAVEAQUESTION</a></li></ul><p><strong>再牛逼的技术也抵不过傻逼似的坚持</strong></p><ul><li>😄 <a href="https://github.com/YorickYu/YYTODOLIST">YYTODOLIST</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sliding window algorithm 滑动窗口</title>
      <link href="2020/10/12/slide-windows/"/>
      <url>2020/10/12/slide-windows/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口本质上来源于单调性，一般可以理解为，随着左端点位置的增加，其最优决策的右端点位置单调不减。</p><p>事实上是利用决策单调性来实现复杂度优化。</p><p>时间复杂度：O(n)</p><p>可以解决的问题有：求最小区间、区间最大值、最小子串等</p><a id="more"></a><blockquote><p>LeetCode 3 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a><br>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>滑动窗口之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    char[] chars &#x3D; s.toCharArray();</span><br><span class="line">    List&lt;Map&gt; maps &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    AtomicInteger InnerMax &#x3D; new AtomicInteger();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">        Character target &#x3D; chars[i];</span><br><span class="line">        Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int innerI &#x3D; i;</span><br><span class="line">        maps.stream().filter(e -&gt; !e.containsKey(&quot;rep&quot;))</span><br><span class="line">                .forEach(e -&gt; &#123;</span><br><span class="line">                    if (e.containsKey(target)) &#123;</span><br><span class="line">                        int length &#x3D; e.size();</span><br><span class="line">                        InnerMax.set(length &gt; InnerMax.get() ? length : InnerMax.get());</span><br><span class="line">                        e.put(&quot;rep&quot;,&quot;-1&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        e.put(target, innerI);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        map.put(target, i);</span><br><span class="line">        maps.add(map);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; maps.size(); j++) &#123;</span><br><span class="line">            Map m &#x3D; maps.get(j);</span><br><span class="line">            if (m.containsKey(&quot;rep&quot;)) &#123;</span><br><span class="line">                maps.remove(j);</span><br><span class="line">                j--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(maps);</span><br><span class="line">    maps.stream().forEach(e-&gt; &#123;</span><br><span class="line">        int length &#x3D; e.size();</span><br><span class="line">        if (e.containsKey(&quot;rep&quot;)) &#123;</span><br><span class="line">            length &#x3D; length - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerMax.set(length &gt; InnerMax.get() ? length : InnerMax.get());</span><br><span class="line">    &#125;);</span><br><span class="line">    return InnerMax.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：398 ms 40.6 MB</p><p>优化版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    char[] chars &#x3D; s.toCharArray();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    Map&lt;Character, Integer&gt; store &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i&lt;chars.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (store.containsKey(chars[i])) &#123;</span><br><span class="line">            max &#x3D; length &gt; max ? length : max;</span><br><span class="line">            length &#x3D; 1;</span><br><span class="line">            i &#x3D; store.get(chars[i])+1;</span><br><span class="line">            store.clear();</span><br><span class="line">            store.put(chars[i],i);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            store.put(chars[i],i);</span><br><span class="line">            length +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return length &gt; max ? length : max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：95 ms    39.5 MB</p><p>滑动窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 记录字符上一次出现的位置</span><br><span class="line">    int[] last &#x3D; new int[128];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 128; i++) &#123;</span><br><span class="line">        last[i] &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line"></span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    int start &#x3D; 0; &#x2F;&#x2F; 窗口开始位置</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int index &#x3D; s.charAt(i);</span><br><span class="line">        start &#x3D; Math.max(start, last[index] + 1);</span><br><span class="line">        res   &#x3D; Math.max(res, i - start + 1);</span><br><span class="line">        last[index] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：2 ms    38.8 MB</p><hr><p>滑动窗口其他题目:</p><p><a href="https://yloopdaed.icu/2020/12/23/sw-findsubstring/">抖音面试题：是否存在无序子串</a></p><ol start="30"><li><p>串联所有单词的子串</p></li><li><p>最小覆盖子串</p></li><li><p>至多包含两个不同字符的最长子串</p></li><li><p>长度最小的子数组</p></li><li><p>滑动窗口最大值  （感觉也可以使用动态规划算法）</p></li><li><p>字符串的排列</p></li><li><p>最小区间</p></li><li><p>最小窗口子序列</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git command</title>
      <link href="2020/10/10/git/"/>
      <url>2020/10/10/git/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然现在常用sourcetree或者直接在IDE中通过图形界面操作，但是开发中难免遇到一些棘手的问题需要使用git命令去管理项目</p><p>这里列出一些常用的命令，方便查询 <a href="#%E6%9C%AC%E5%9C%B0%E6%93%8D%E4%BD%9C">命令集</a></p><p><strong><em>&lt;更新20201114&gt;</em></strong></p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><h3 id="1-撤销本地-暂存区代码"><a href="#1-撤销本地-暂存区代码" class="headerlink" title="1 撤销本地\暂存区代码"></a>1 撤销本地\暂存区代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br><span class="line">git checkout -- &lt;filename&gt;</span><br><span class="line">批量撤销：</span><br><span class="line">git reset HEAD</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h3 id="2-撤销已提交的代码"><a href="#2-撤销已提交的代码" class="headerlink" title="2 撤销已提交的代码"></a>2 撤销已提交的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id 回到上一个提交的节点（清楚本地代码库）</span><br><span class="line">git reset --soft commit_id 回到上一个提交的节点（保留本地代码库）</span><br><span class="line">查看commit_id（查看命令历史）：git reflog </span><br></pre></td></tr></table></figure><h3 id="3-原本版本退回"><a href="#3-原本版本退回" class="headerlink" title="3 原本版本退回"></a>3 原本版本退回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line">git push -f origin master</span><br><span class="line">查看commit_id（查看命令历史）：git log</span><br></pre></td></tr></table></figure><h3 id="4-创建分支并提交到远程"><a href="#4-创建分支并提交到远程" class="headerlink" title="4 创建分支并提交到远程"></a>4 创建分支并提交到远程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git push origin dev</span><br><span class="line">删除远端分支：</span><br><span class="line">git push origin --delete dev</span><br><span class="line">删除本地分支：</span><br><span class="line">git branch -d dev</span><br><span class="line">查看本地、远端分支：</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><p>1 初始化一个仓库: </p><pre><code>git init</code></pre><p>2 添加文件到Git仓库，分两步：</p><pre><code>2.1 git add &lt;fileName&gt; 可以反复多次添加，也可以一次添加多个文件(git add . / git add file1 file2)2.2 git commit -m “message” 提交</code></pre><p>3 git status 随时掌握工作区的状态 git status -s 简短信息查看</p><p>4 git diff <fileName> 查看修改的内容 git diff –cached 查看已缓存 git diff HEAD 查看所有 git diff –stat 只显示摘要</p><p>5 在本地版本间穿梭: </p><pre><code>git reset --hard commit_id (回到上一版本：git reset —hard HEAD^)</code></pre><blockquote><p>ps：在Git中，用HEAD表示当前版本，上一版本就是HEAD^，同理上上版本HEAD^^，如果往上100个版本，可以写成HEAD~100</p></blockquote><p>6 git log 可以查看历史提交记录，以便确定要退回版本的commit_id，简化信息：</p><pre><code>git log --pretty=oneline</code></pre><p>7 查看命令历史:</p><pre><code>git reflog </code></pre><p>8 丢弃工作区的修改：</p><pre><code>git checkout -- &lt;fileName&gt; (这里的 -- 很重要，如果没有--，就编程切换分支的命令)</code></pre><p>9 丢弃暂存区的修改：</p><pre><code>第一步，git reset HEAD &lt;fileName&gt;(HEAD表示当前最新版本)第二步，git checkout -- &lt;fileName&gt;</code></pre><p>10 丢弃版本库的修改：和第5条同理，其实就是切换回先前的分支:</p><pre><code>git reset --hard commit_id</code></pre><p>11 删除文件：</p><pre><code>11.1 方法一：先删除本地rm &lt;file&gt;，然后再git add/rm &lt;file&gt;，git commit -m “message”11.2 方法二：直接git rm &lt;file&gt;，git commit -m “message”ps: 如果是rm &lt;file&gt;，可以直接通过git checkout -- &lt;file&gt;修改回来</code></pre><h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><p>1 在GitHub上创建完远程仓库后，在本地的仓库下运行命令，关联远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure><p>2 下一步，使用命令：，将本地库的所有内容推送到远程库上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><p>ps：第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送命令即可省略，直接用git push origin master</p></blockquote><h2 id="创建、合并分支"><a href="#创建、合并分支" class="headerlink" title="创建、合并分支"></a>创建、合并分支</h2><p>1 查看分支：git branch</p><p>2 创建分支：git branch <name></p><p>3 切换分支：git checkout <name></p><p>4 创建+切换分支：git checkout -b <name></p><p>5 合并某分支到当前分支：git merge <name></p><blockquote><p>ps：合并分支时加入–no-ff参数，表示禁用Fast forward：git merge –no-ff -m “merge with no-ff” <name>这种操作合并后的历史有分支，能看出曾经做过合并，而Fast forward合并就看不出来</p></blockquote><p>6 删除分支：git branch -d <name></p><p>7 查看合并分支图：git log –graph</p><h2 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h2><p>情景：在develop分支开发时，突然报出紧急bug：</p><p>1 在develop分支把工作现场“贮藏”起来：</p><pre><code>git stash</code></pre><p>2 然后确定要在哪个分支上处理bug，假如在master上修复，就从master创建临时分支：</p><pre><code>git checkout master git checkout -b bug001</code></pre><p>3 在bug001分支上处理bug，修复完成后切回master进行合并：</p><pre><code>git merge --no-ff -m “merge with no-ff” bug001</code></pre><p>4 现在bug处理完了，回到develop查看刚刚”贮藏”的代码：</p><pre><code>git stash list</code></pre><p>5 把”贮藏”的代码拿到develop上，继续开发：</p><pre><code>git stash pop(git stash apply + git stash drop)</code></pre><blockquote><p>ps：apply恢复，但stash的内容并不删除，需要再用drop删除；pop恢复的同时也删除了</p></blockquote><h2 id="新特性分支"><a href="#新特性分支" class="headerlink" title="新特性分支"></a>新特性分支</h2><p>情景：开发一个新feature，但是突然说这个功能不做了（在新分支上已经执行add,commit操作）</p><p>丢弃一个没有被合并过的分支，强行删除该分支：</p><pre><code>git branch -D &lt;name&gt;</code></pre><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>1 推送本地分支到远端，如果推送失败，先git pull抓去远程的新提交</p><pre><code>git push origin &lt;name&gt;</code></pre><p>2 拉取远端分支到本地：</p><pre><code>git checkout -b &lt;name&gt; origin/&lt;name&gt;</code></pre><blockquote><p>ps：查看权限：git remote -v</p></blockquote><p>3 建立本地分支和远程分支的关联：</p><pre><code>git branch --set-upstream &lt;name&gt; origin/&lt;name&gt;</code></pre><blockquote><p>ps：如果git pull提示no tracking information，则说明没有创建关联</p></blockquote><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>git rebase操作可以把本地未push的分叉提交历史整理成直线</p><h2 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h2><p>1 创建新标签 git tag <tagname> 默认添加在HEAD上，如果要特定添加在某条记录上可以 </p><pre><code>git tag &lt;tagname&gt; &lt;commit id&gt;例: git tag v1.0 fa=52c662</code></pre><p>2 git tag -a <tagname> -m ‘ababababllal’</p><p>3 git tag 查看所有标签</p><p>4 git tag -d <tagname> 删除标签</p><p>5 推送标签到远程</p><pre><code>git push origin &lt;tagname&gt; </code></pre><p>6 推送所有标签到远程 </p><pre><code>git push origin --tags </code></pre><p>7 删除远程标签，分两步：</p><pre><code>第一步，先删除本地标签 git tag -d v1.0第二部，删除远程，命令也是push，git push origin :refs/tags/v1.0</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财营-学习笔记</title>
      <link href="2020/10/07/money-management/"/>
      <url>2020/10/07/money-management/</url>
      
        <content type="html"><![CDATA[<!-- ## 小白理财营学习笔记 --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国庆期间形成安排比较满，前半段安排了家庭短途自驾旅行，后半段要去外地参加朋友的婚礼。</p><p>没有太多大块的时间可以学习和整理，于是报名参加了一个基础的理财知识的训练营，利用晚上睡前的时间了解一下理财相关的知识、丰富一下自己的知识库。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>课程共12天，所以我也会按每天的内容进行更新。全部学习结束后争取写一写自己的收获和感悟。</p><a id="more"></a><hr><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/1.jpg"></p><p>第1-3天，我们重点讲解投资理财的底层逻辑，建立好对于理财的正确认知</p><p>第4-12天，我会重点带着大家认识市面上常见的各类工具，例如：股票，REITs，指数基金、货币基金、国债逆回购，客观认识到各类工具的风险、作用以及收益情况，学会以后大家就不会被骗了，并且还能掌握几个无风险理财工具的操作</p><p>1️⃣聪明消费，摆脱月光，增加结余<br>2️⃣建立正确的金钱观、理财观，初步形成富人思维，投资不再被骗<br>3️⃣了解各种理财工具的风险和收益情况，并掌握几个无风险理财工具，形成理财的底层逻辑</p><p>学习理财不能帮助你一夜暴富，但是能够帮你梳理财务管理上的漏洞，弄清楚自己的财务状况，增加非工资收入，迈向更好的生活。</p><p>[衰]所以大家有没有发现：</p><p>三十年前，一人工作能养活全家。<br>三十年后，全家工作难养一个孩子。</p><h4 id="四条忠告"><a href="#四条忠告" class="headerlink" title="四条忠告"></a>四条忠告</h4><p>♥️欠债的人应当消除「坏支出」和「坏支出」产生的负债</p><p>♥️如果是能“帮你赚钱”的负债要尽可能的延长偿还时间。</p><p>♥️对于消费贷款，欠债的人应该将不用于生活的钱一半存起来，另一半用于还债。</p><p>♥️对于所有的消费，都要问自己【这真的有必要吗？】，尽可能的减少【不必要的】开支</p><h4 id="思维层次"><a href="#思维层次" class="headerlink" title="思维层次"></a>思维层次</h4><p>1⃣️第一层次：控制不住消费欲望，为了新出的包包、鞋就要花完自己所有的零花钱。</p><p>2⃣️第二层次：建立自己的储蓄罐，为了自己的梦想开始运用自己的优点来赚钱，但是没有自己的鹅。</p><p>3⃣️第三层次：开始养“鹅”</p><p>因为思维决定人的行为，行为成为人的习惯，最后反应在你的财务结果上</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/6.png"></p><p>还是那句，富人思维找办法，穷人思维找理由；富人思维在行动，穷人思维在观望；富人思维想着改变，穷人思维只会哀叹。</p><p>有句话分享给大家，我们常常高估一天内可以做到的事情，却低估了一年里可以做到的事情。🔔</p><p>放在理财上就是，我们常常对一天的收益率抱有过高的期望，却对三年、五年、十年甚至更长的时间里的收益率没有耐心等待。</p><p>【富人关键思维-第一条】</p><p>🔆获得经济独立、财务自由的意义是什么？</p><p>🌹经济独立、财富自由并不是独善其身，它的本质是让自己、家人变的更好的能力。</p><p>【从个人讲】，可以更好的选择自己喜欢的东西、自己喜欢的生活方式、婚姻方式，最终实现踏踏实实靠自己，得来属于自己的精神自由。把经济这个生存的“命脉”交给他人，其实就是把自己选择的权力让给了他人，也把自己生活的主动权让给了他人。</p><p>【从家庭讲】，与爱人共同分担家庭的财务重担，应对老人的医疗花销、孩子的教育花销，让家庭关系因为共同的努力获得财富而更美好，而不是因为钱受到冲击而动摇。</p><p>🌹一句话总结：提升理财技能，实现财务独立，获得更多自主选择的权力，获得给家人更好的生活的能力。</p><h2 id="正篇-1"><a href="#正篇-1" class="headerlink" title="正篇-1"></a>正篇-1</h2><h3 id="1-三大资产"><a href="#1-三大资产" class="headerlink" title="1 三大资产"></a>1 三大资产</h3><p>今天的课程分为 3 个部分：</p><p>1、什么是理财？必须有钱才能理财吗？</p><p>2、三大资产，到底什么东西能帮我们赚钱？哪些东西会让我们亏钱？</p><p>3、穷人和富人之间的差别是什么？</p><h4 id="♠️重点一：【理财】"><a href="#♠️重点一：【理财】" class="headerlink" title="♠️重点一：【理财】"></a>♠️重点一：【理财】</h4><p>投资≠理财，投资只是理财的一部分，理财是很广泛的概念。</p><p>理财包含：制定家庭日常消费计划、投资计划、保险计划、教育金计划、养老金计划等等</p><p>🌟重点，资产真正的内涵是【现金流】</p><h4 id="♠️重点二：【三大资产】"><a href="#♠️重点二：【三大资产】" class="headerlink" title="♠️重点二：【三大资产】"></a>♠️重点二：【三大资产】</h4><p>⭐️生钱资产</p><p>✅生钱资产：持有期间能给自己持续带来净现金流入的东西</p><p>常见的生钱资产有：股息、版税、利息，房屋租金等</p><p>⭐️耗钱资产</p><p>❌耗钱资产：持有期间能给你【持续】带来净现金流出的东西。</p><p>⭐️其他资产</p><p>⭕️其他资产：持有期间产生的净现金流为0的东西。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/7.png"></p><p>例：房子根据情况的不同，可以分为三种不同的资产类型</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/8.jpg"></p><h4 id="♠️重点三：【穷人和富人的区别】"><a href="#♠️重点三：【穷人和富人的区别】" class="headerlink" title="♠️重点三：【穷人和富人的区别】"></a>♠️重点三：【穷人和富人的区别】</h4><p>【关键富人思维-第一条】</p><p>这里的差别从资产结构的角度切入</p><p>1 大部分人包括我自己都属于这个情况。主要的经济来源都是依靠工资，虽然随着工作的年限增长，工资也得到一定的提升。但是同样伴随家庭和个人开销的增加。所以感觉越来越穷，生活的压力也越来越大</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/9.png"></p><p>2 正确的资产结构应该如下，工资收入应该补充到适当的理财产品中，利用少量的工资和大量的理财收益维持生活的支出</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10.jpg"></p><p>【关键富人思维-第二条】</p><p>⭐月光或者积蓄不多的人，为什么不能等有钱再学习理财？</p><p>🌹月光和积蓄不多本质是错误理财思维造成的结果。</p><p>【在花钱上】，很多都是坏支出，一心只想买买买，很多东西在冲动消费之后要么用了几次就放置一边，要么后悔自责又在下次陷入到恶性循环，但对于投资自己成长的好支出，却又思前想后。其关键在于，没有好支出、坏支出的思维意识，被欲望牵着走，没有将有限的资金花在刀刃上。</p><p>【在攒钱上】，单纯靠工资攒钱是最低效最差的方式，如果只靠工资收入来攒钱，很可能到退休了还没有攒够理财的本金。真正聪明的小伙伴会在获得第一笔工资收入时就开始选择合适的理财工具来积累自己的本金和非工资收入了。</p><p>具有富人思维的人，哪怕是现在月光或者积蓄不多，就会从一开始就通过工资和非工资收入两条路径来增加自己的收入。两条腿走路肯定比只靠工资收入一条腿走的更快更远。</p><p>🌹一句话总结：提升财富要靠工资和非工资收入【两条腿】走路，绝对不能独腿前行。</p><p>【关键富人思维-第三条】</p><p>🌹普通或中产家庭为什么不能沉溺在自己的工资收入中，不重视理财？</p><p>因为不安全，看似收入比较稳定，其实抗风险能力很低，因为有房贷车贷要还，小孩要养，大量的耗钱资产占主要，甚至父母的医疗还要大量的开销。</p><p>【孩子还未成人的家庭】<br>孩子没有收入，花销逐年增大，这时候如果夫妻中有一人遇到一段时间不能工作的情况，家庭财务整体情况可能会出现较大落差，进而影响生活质量得不到保障。</p><p>【全职宝妈的家庭】<br>女性负责照顾孩子，没有工资性收入，只有丈夫一人的收入是家庭收入的主要来源，如果丈夫遭遇大裁员等意外情况，家庭很可能立即陷入坐吃山空的财务危机中，或者啃老的尴尬境地。</p><p>所以普通家庭更需要尽早尽快建立自己的【非工资收入体系】，【在没有意外发生的时候】可以为家庭提供一份额外的收入，补贴家用；【在意外发生的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。</p><p>🌹学习并掌握获得非工资收入的能力，是为自己负责，也是为了家人生活安全负责。</p><p> 总结：普通人的【财务安全】来自工资收入和非工资收入的双管齐下，没有充沛的非工资收入的中产家庭，谈不上财务安全健康。</p><h3 id="2-复利"><a href="#2-复利" class="headerlink" title="2 复利"></a>2 复利</h3><p>今晚的课程主要讲三个重点，两个富人关键思维：</p><p>1、复利是什么？</p><p>2、复利的反向作用</p><p>3、复利的头号敌人</p><h4 id="♠️重点一：什么是复利？"><a href="#♠️重点一：什么是复利？" class="headerlink" title="♠️重点一：什么是复利？"></a>♠️重点一：什么是复利？</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/11.png"></p><p>复利本质上是一种让钱高效生钱的思维方式。<br>影响复利的因素是：本金 时间 收益率</p><p>⭐第一个重点要素：本金。本金越多，最终收益越大。<br>⭐第二个重点要素：时间<br>⭐复利的第三个重要因素：【收益率】，影响非常大！非常大！</p><h4 id="♠️重点二：复利的反响作用—通货膨胀"><a href="#♠️重点二：复利的反响作用—通货膨胀" class="headerlink" title="♠️重点二：复利的反响作用—通货膨胀"></a>♠️重点二：复利的反响作用—通货膨胀</h4><p>你的收益率低于10%,你的钱就在贬值，钱会越来越不值钱。</p><h4 id="♠️重点三：复利的头号敌人—亏损"><a href="#♠️重点三：复利的头号敌人—亏损" class="headerlink" title="♠️重点三：复利的头号敌人—亏损"></a>♠️重点三：复利的头号敌人—亏损</h4><p>一定要记住：</p><p>1、不懂的东西不要碰<br>2、只操作在国家交易所交易的工具</p><p>【关键富人思维-第四条】</p><p>⭐为什么说复利三要素中最容易掌控的是收益率？</p><p>🌹复利三要素，本金、时间、收益率。把钱存在保险箱中，复利会发挥反向作用，把钱一口一口吃掉，长期来看1万元每年贬值500元以上。投资开始的越早，时间要素发挥越大，复利的正向作用越早发挥作用。本金大的人，复利作用也比较大，但是投错了地方，本金再大也会亏完。如果本金和时间都不占优势，那么最有效的就是提高年化收益率，而提高年化收益率的关键在于自己的理财能力。</p><p>🌹一句话总结：【时间无法改变，越早开始越好；本金依赖生钱资产；收益率源于理财能力，理财能力才是决定复利终值的关键】</p><p>【富人关键思维–第五条】</p><p>⭐为什么说投资自己的大脑、学会理财技能也是中产升级之法？</p><p>🌹如同经典书籍《富爸爸》中说的，穷人卖时间换钱，其实本质是“卖命”。他们抱怨自己没有钱，其实本质是他们没有认识到投资自己的大脑是最快的脱贫致富之法。</p><p>比如一个专家花费一生写了一部巨著，我们花100元买了他的书回来看，其实某种意义上我们是买到了他一生的生命成果，学到了能获得成千上万的收益，这就叫“站在巨人的肩膀上”，贫穷的矮人站在“巨人的肩膀上”也会达到巨人的视野。</p><p>但很多人心疼这点投资大脑的钱，所以一直什么都不懂，一直贫穷下去。反之，穷人也能通过投资自己的头脑，学习他人成功的方法，买他人花了很多时间转化的成果，变成自己的东西，快速创造财富，这是最快的脱贫之法。</p><p>🌹一句话总结：心疼投资大脑的钱，一直什么都不懂，不是被通货膨胀割韭菜，就是被投资市场割韭菜，一直穷下去。反之学习他人成功的方法，变成自己的技能，是最快的脱贫、升级之法。</p><h3 id="3-理财工具"><a href="#3-理财工具" class="headerlink" title="3 理财工具"></a>3 理财工具</h3><p>今天讲的21种理财工具，我们不用样样精通，但是要抓住重点：</p><p>1、哪些工具好？</p><p>2、哪些工具不能碰？</p><p>3、哪些工具是我们财务自由的核心工具？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/12.png"></p><h4 id="⭕无风险的理财工具"><a href="#⭕无风险的理财工具" class="headerlink" title="⭕无风险的理财工具"></a>⭕无风险的理财工具</h4><p>国债，定期存款，国债逆回购，货币基金，银行理财（保本型）</p><p>我们了解两个就行，【国债逆回购】和【货币基金】</p><p>国债：“国债，又称国家公债，是国家以其信用为基础，按照债券的一般原则，通过向社会筹集资金所形成的债权债务关系。国债是由国家发行的债券，是中央政府为筹集财政资金而发行的一种政府债券，由于国债的发行主体是国家，所以它具有最高的信用度，被公认为是最安全的投资工具。”</p><p>【国债逆回购】： 本质就是一种短期贷款。也就是说，个人通过 国债回购市场 把自己的资金借出去，获得固定的 利息收益 ；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p><p>【货币基金】也称“火鸡”。货币基金家族有个家伙是很出名的，它叫“余额宝”。其他货币基金也和余额宝差不多</p><p>🧧分享个【捡钱小秘密】给大家</p><p>捡钱小秘密由【国债逆回购】和【货币基金】组成。</p><p>我们平时把零钱买货币基金，每年可以获得3%左右的无风险收益。当国债逆回购收益高时，比如大于10%以上，卖掉货币基金直接买入国债逆回购。这样就可以获得几天的高收益。等国债逆回购的钱回来后，再当天买进货币基金。</p><p>👉【场内基金】就是在证券市场内，也就是二级市场买卖基金，需要自己去开立股票账户进行购买的。比如可以在场内买ETF基金、LOF基金、封闭式基金等。场内基金咱们后面重点会学习【指数基金】，有筛选方法和购买标准，收益率在12%以上，风险较低。</p><p>👉【场外基金】则是在证券市场外买卖基金，比如银行、基金公司、第三方平台(如天天基金网、支付宝、微信等)，不需要开股票账户就可以购买。场外基金咱们不会学，因为风险较大，收益也不是很高，小白不懂乱买很容易亏钱。</p><h4 id="⭕低风险的理财工具"><a href="#⭕低风险的理财工具" class="headerlink" title="⭕低风险的理财工具"></a>⭕低风险的理财工具</h4><p>⭐它又分为两类👇<br>一种是【低风险中等收益】，年化收益率一般6%—15%之间，主要包括【分级基金A】、【可转债】、【债券基金】、【股票指数基金】<br>另一种是【低风险高收益】，年化收益率一般在15%—30%之间，主要包括生钱资产类型的【股票】、【REITs】</p><p>决定【投资风险和收益大小的】不是【理财工具】本身，而是投资人的【理财技能】</p><p>🎈股票<br>对于每年【有持续分红】的股票而言，就是【生钱资产】</p><p>买了【不分红的股票】，只能靠预测未来的价格上涨，这是不确定性的，就是【其他资产】</p><p>🎈 REITS，读作 “瑞子”就行<br>这个是重点，REITs是全球配置房产的理财工具</p><p>【生钱资产类型的REITs】就是持续高分红的REITs。其实一般的REITs都是持续高分红的。因为各国法律都规定REITs每年至少要把90%以上的净利润分配给投资者。</p><p>🎈 【股票指数基金】复制股票指数的股票基金。由于股票指数具有永生不死，长期上涨的特点。在合适的价位买入股票指数基金长期持有几乎没有风险。其年化收益率一般在10%—15%。🌹</p><h4 id="⭐中风险的理财工具"><a href="#⭐中风险的理财工具" class="headerlink" title="⭐中风险的理财工具"></a>⭐中风险的理财工具</h4><p>黄金、不保本的银行理财等</p><h4 id="⭐高风险的理财工具"><a href="#⭐高风险的理财工具" class="headerlink" title="⭐高风险的理财工具"></a>⭐高风险的理财工具</h4><p>p2p、私募基金、比特币收藏品、期货等</p><p>实现财务自由的三大核心工具:</p><p>只有当企业、股票、REITs具有生钱资产的属性的时候，才能算成我们的财务自由核心工具</p><p>💰这三大核心工具，只要用好了其中的一个就能【脱贫致富】</p><p>【购买生钱资产】，主要就是购买生钱资产类型的股票和REITS</p><p>代表人物比如巴菲特 罗杰斯</p><p>【创造生钱资产】 ，就是创造企业</p><p>比如马云、马化腾</p><p>而我们普通人，大部分都可以通过购买生钱资产致富</p><p>♥️用好了企业这个核心工具，你会成为企业家</p><p>♥️用好了股票或REITs这两个核心工具，你会成为投资家；</p><p>♥️用好了企业、股票、房地产这三个工具，你会成为资本家</p><p>今天的课程共三个重点：</p><p>【重点一】：短期零钱管理，关注国债逆回购、货币基金。</p><p>【重点二】：低风险投资工具，重点关注生钱资产类型的股票、REITs</p><p>【重点三】：实现财务自由的三大核心工具——股票、REITs、企业</p><p>【关键富人思维—第六条】</p><p>🌟到底什么时候可以开始投资？</p><p>为什么有的人买股票会亏钱，因为只看了几本书，学了几天课就急急忙忙去股市。我们学车考个驾照还要一个月，而理财投资作为一个高度专业化、精细化的领域，不经过系统的学习就去“尝试”，这和训练了两天、看了几本武侠小说就上战场的士兵有什么区别？</p><p>士兵进行系统训练是为了保命，投资者进行系统的理财方法学习是为了保钱的“命”。反之，学半瓶水，一知半解就去投资市场“试试”，只会学到教训和被割韭菜，收获痛苦。那些经过系统投资训练的人会把那些无知而自以为是的人收割的一滴血不剩。在股市里，你赚的钱是别人亏得，你亏的也被别人赚走了。</p><p>⭕【投资的真相】，不系统学习理财技能就想赚快钱，本质是送钱的命，当你打算投资一个目标，要有系统的分析方法，不再为了涨跌而心惊胆战的时候，这才是投资可以真正开始的时候。</p><p>一句话总结：投资第一原则，不懂不要投，懂了安心投，盲目“尝试”无疑送命，系统训练方可真正保住钱“命”</p><p>🎁正确系统的投资技能包括：</p><ul><li>①理财的底层逻辑、富人思维</li><li>②股票的海选</li><li>③精选出好公司</li><li>④财务报表分析</li><li>⑤企业分析</li><li>⑥计算好价格</li><li>⑦制定买进标准</li><li>⑧制定持有标准</li><li>⑨制定卖出标准等</li></ul><h3 id="4-分析财报"><a href="#4-分析财报" class="headerlink" title="4 分析财报"></a>4 分析财报</h3><p>🎤那大家猜猜，在理财中学习【财务报表】最重要的作用是什么呢？</p><p>💎答：最重要的作用是排雷，是证伪，而不是证实。</p><p>一、财务报表到底是什么？有什么用？</p><p>可茫茫股市几千只，光每年分红的股票就有2000多家，怎么精准的判断是不是含金量最高的【股票】呢？</p><p>判断标准之一就是要能读懂【财务报表】<br>后面懂了股票的筛选方法，【REITs】工具得筛选方法同理</p><p>💎学习【财务报表】，老师这里给大家几个学习提示：</p><p>1、从今晚开始课程中有看不懂的是正常现象，小白营的时间有限，大家先掌握思路，就是知道选好公司，好股票，是凭借什么依据什么方向去判断的就可以了<br>具体财报怎么看，是有23个步骤的，在完整的《财富自由实践课》中有详细讲解和实操带领</p><p>2、不要局限在财报的数字和计算中，这并不是重点，财报的关键是看【结构】，看数字谁都会晕，不纠结数字。</p><p>3、思考造成文中，不同家庭财务状况的原因是什么？三类资产和好/坏支出，都是怎么在他们的家庭中起到作用的？</p><p>4、试着写出自己家庭的财报是什么样，三类资产和好/坏支出，负债率等，各是怎样的情况？占比多少？并应该怎样去调整？列在纸上写一写，生活方向就清晰很多了</p><p>⭐应付：【先用货，后给钱】</p><p>⭐预收：【先收钱，后发货】</p><p>🎤那么，应付+预收是不是能证明我企业很有实力，而且，我现金流很大。</p><p>⭐应收：【先发货，收不到钱】</p><p>⭐预付：【先给钱，收不到货】</p><p>【应付+预收】我们占用别人的钱</p><p>【应收+预付】别人占用我们的钱</p><p>通过：一家公司负债项中【应付预收】减去资产项中的【应收预付】来判断公司的竞争力强弱。</p><p>相减得出金额越大，说明公司的竞争力越强。</p><p>相减得出金额越小，说明公司的竞争力越弱。</p><p>那通过什么来判断公司的【安全性】呢？</p><p>我们可以用【资产负债率】来判断公司的偿债风险</p><p>总负债÷总资产*100%=资产负债率。</p><p>👉资产负债率【大于70%】的公司，偿债风险比较大</p><p>👉资产负债率【小于40%】的公司，几乎没有偿债风险</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/13.png"></p><p>【关键富人思维—第七条】</p><p>为什么月光、负债的人应该拿出一部分资金学习理财技能？</p><p>这里的负债主要指的是让自己的财务状况不断恶化的【坏负债】。</p><p>⭐️月光和负债只是不懂理财的结果，没有理财技能才是月光和负债的原因。很多人一方面不懂投资的骗局，一方面又眼红想赚一下，最终都入了骗局的“坑”，如果提前投资自己的大脑，难道还会犯这样的错误吗？还有很多人，本来钱就不多，贷款买了一堆耗钱资产，要么不断的刷信用卡、花呗、借呗，窟窿越来越大，要么生活拮据，每天人前风光，人后遭殃。</p><p>但对于投资自己，提升理财技能的好负债，他们却斤斤计较，错失了复利的好机会，这样的人生活只会越来越难过。</p><p>【成长有顺序，生活致富也有顺序】——先投资大脑，掌握理财的技能，然后再去生钱，月光、负债不学习只会越来越穷</p><p>🌹一句话总结：月光、负债是财务病，病根是缺少理财技能，忽视病因、不治病根，坏支出、坏负债只会越来越严重。</p><p>月光负债只是结果，不会理财是病因</p><p>投资的准则是【不懂不要投，懂了放心投】</p><p>投资的核心是【生钱资产】</p><p>投资的实质是投资【好公司/好项目】</p><p>🌟【正确理财步骤】</p><p>🎈第一步：学习富人思维，增值自己，先投资自己掌握理财技能。</p><p>🎈第二步：有了理财技能，自然就具备精准识别优质生钱资产的能力（选出好股票、好REITs）。</p><p>🎈第三步：每月收入先拿出一部分去投资，购买生钱资产，长期持有积累，利用复利发挥威力获得收益。</p><hr><p>❤️越是没钱的时候越要理财，越要重视投资自己。</p><p>❤️因为投资大脑掌握理财技能是回报最高、变现最快的投资。</p><p>❤️一定要学会让钱为自己工作，支配钱，驾驭钱</p><p>❤️内在拥有，外在呈现；内在没有发生改变，人是永远无法赚到自己认知以外的钱的</p><h3 id="5-反常识股票"><a href="#5-反常识股票" class="headerlink" title="5 反常识股票"></a>5 反常识股票</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/20.jpg"></p><h4 id="⭕️重点1：股票的定义"><a href="#⭕️重点1：股票的定义" class="headerlink" title="⭕️重点1：股票的定义"></a>⭕️重点1：股票的定义</h4><p>🎤股票到底是什么？</p><p>其实【股票】是公司的所有权凭证。</p><p>🎤人们一开始购买股票是希望能够赚到股票的什么钱？</p><p>是分红</p><p>🎤企业为什么要发行股票呢？</p><p>企业发行股票很大一部分是为了融资。</p><p>【重点】企业发行股票的主要目的就是为了融资，出让股份，让大家投钱，你用大家的钱，去干更大的事，赚到了钱，一起分。</p><p>🎤那股市是什么意思？</p><p>股市的存在让买卖股票变得非常的方便</p><p>中国A股市场有两大交易所，分别是上交所和深交所，相当于两个“菜市场”</p><p>A股交易时间是：</p><p>每周一到周五：早上9点30 - 11点30；下午1点 - 3点；节假日休市</p><p>🎤那我们投资【好公司】的股票赚的是什么钱呢？</p><p>①【公司持续的现金分红】<br>②【股票价格上涨带来的价差收益】</p><p>🎤为什么股票的收益率那么高呢？</p><p>因为股票的背后是公司，公司是一个国家创造经济的主体，因此一国的【股市平均收益率】一定是远远大于该国【GDP增长率】的。</p><p>👉中国的GDP增长率在6.5%左右；</p><p>中国股市的年化收益率一定是大于6.5%的。</p><p>为什么会这样呢？因为GDP的组成中，企业是创造价值最多的部门，而股票背后的实质就是企业</p><p>好上市公司的平均收益率&gt;所有上市公司的平均收益率&gt;所有公司的平均收益率&gt;GDP增长率&gt;银行存款收益率</p><p>据统计：</p><p>👉中国的GDP增长率在6.5%左右；</p><p>👉中国所有上市公司的平均年化收益率大于12%以上；</p><p>👉中国【好】上市公司的平均年化收益率大于24%以上。</p><p>买了好公司的股票，就相当于中国甚至世界最优秀的管理团队为自己打工。</p><h4 id="⭕️重点2：什么样的股票算是好股票？"><a href="#⭕️重点2：什么样的股票算是好股票？" class="headerlink" title="⭕️重点2：什么样的股票算是好股票？"></a>⭕️重点2：什么样的股票算是好股票？</h4><p>股票的本质是企业，好企业的股票就是好股票。股价下跌是市场的正常现象，只要公司利润在增长，这个公司就是有好公司的潜质。</p><blockquote><p>小科普：不复权价格是「真实的价格」，后复权则显示的它的「真实价值」，即分红送股转股都加进去。<br>例如你的公司市值（市场价）3元，你要给股民分红，分1元，你不能自己掏腰包垫吧。所以就要从公司市值减1元，你的公司现在就是2元（前复权），其实你的公司值3元（后复权）。</p></blockquote><p>认为买股票有很大风险的同学，想想是不是以前用错了方法？同时也直观的，让大家理解到，好公司长期持有的价值回报是很大的</p><p>所以，在正确投资股票中，建议同学们不要经常看股票行情波动，这对工作、生活、财务自由以及投资没有任何好处，实在忍不住想看看股票价格的走势，那就每年看一两次就够了。</p><blockquote><p>重点强调：正确理财的人，是根本不用花时间关注股价波动的</p></blockquote><p>⭕为什么说好公司股价暴跌反而是赚钱的机会</p><p>只要公司真实利润在增长，股价下跌你反而会更赚。</p><p>股价波动不是风险，不要怕，真正的风险是公司的真实利润在减少。</p><p>股价越跌，它的股价变的更低，你可以拿着【分红的钱】再以低价买入更多股票。</p><p>这时候你得到的股票数量就越多，分红是按照你【持股数量】分的。</p><p>股票越多，分红就越多。</p><p>分红越多，股票就越多。</p><p>一并回答4个问题：</p><ul><li>1、企业为什么发行股票？</li><li>2、股票、股份是什么？</li><li>3、不懂理财的人，是怎么炒股的呢？</li><li>4、正确投资股票的姿势是什么？</li></ul><p>👉1、企业为什么发行股票？</p><p>假设你开了家超市，一共投入10万，超市经营得很好，每年可赚2万，回报率20%。你们掐指一算，按照20%的回报率，如果投入1000万来扩大店面或开连锁，那每年就可以赚200万！</p><p>于是你们想方设法找钱，但终究资源有限，可用于抵押的资产又不多，所以你们从亲戚朋友、银行一共也只借到到了90万，因此最多每年也只能赚20万。那怎么办？还能去哪里去找钱呢？</p><p>这时候你想，既然我能把超市收益经营得这么好，如果在网上发个帖子，告知所有人我的项目，投10万即可赚2万，那肯定很多人都来投资！</p><p>有钱大家一起赚，而你在使用【借力思维】赚钱，这个模式其实就是发行股票，企业发行股票的主要目的就是为了融资！只不过企业的规模大，融资大，这么说大家是不是就更容易明白了</p><p>👉2、股票、股份是什么？</p><p>说白话就是，股票是一个凭证，证明你拥有某一家公司的股份，即股票是股份的凭证。股票的本质是企业。那股份是什么呢？股份就是你对某家公司拥有的所有权。</p><p>👉3、不懂理财的人，是怎么炒股的呢？</p><p>是关注股价的浮动趋势、大盘、K线去预测市场。这种基本都是被割韭菜。</p><p>举例说明：好比 你低价买了一家企业的股票，然后涨了一点就卖了，你赚了。然后我高价买了这家公司股票，也不了解企业实质，光看价格，没等到涨，我就心急卖了，我就赔了。</p><p>这种交易方式完全不看股票背后的公司，只是在预测股价的涨跌，但是没有任何一个人能准确预测市场，像这样赚差价的行为本质是在赌博，长期操作下去，不仅会损失惨重，还很有可能难以承受股价的波动导致，最后精神崩溃。</p><p>这就叫投机，本质是在赌涨跌。</p><p>股票的选择就是这2点</p><p>你只需要用正确的方法，找到最优质的好公司，以【合理的价格】买入和卖出就可以了</p><p>在正确的投资中，根本没有所谓的“长线”“短线”这一说，这都是不懂正确投资人的思维词汇概念。</p><p>正确投资是需要给企业估值的，是跟随企业的价值增长而增值，就不会被短期股价波动吸引注意力了</p><p>⭕正确投资一定是买最优质的好公司，赚钱就是【必然的事情】。</p><p>👉4、正确投资股票的姿势是什么？</p><p>是靠企业的发展带来内在价值的提升，表现形式为净利润的不断提升（分红是利润的一部分），这是正确的投资方式。</p><p>不懂理财的人只看表面，不分析企业实质。</p><p>包括一些只分析，实时新闻政策，去判断行业选股的，都属于不看实质，在投机</p><p>接着昨天很多人说哈，很多人一直听消息，今天国家发一个政策，明天国家发一个政策，天天看这些政策，弄到最后把自己形成一个错误的认知，就是中国是一个政策的股票。</p><p>其实完全不是这样的，因为这个政策到底对这家公司有没有作用，最简单的，你去看这家公司的财务报表就可以了，如果这家公司的这个受到了这个政策的影响，利润上涨，财报会反映出来的，如果说这家公司经营的内部是没有任何的变化，你又何必去关心这个政策呢？<br>第三个重点：选出好公司，要有一套科学的分析体系（财报分析、企业分析）</p><h4 id="⭕️重点3：如何才能分析出好公司呢"><a href="#⭕️重点3：如何才能分析出好公司呢" class="headerlink" title="⭕️重点3：如何才能分析出好公司呢"></a>⭕️重点3：如何才能分析出好公司呢</h4><p>【财报分析】可以看出一个公司的过去和现在。</p><p>【企业分析】可以看出一个公司的现在和未来。</p><p>我们【投资股票正确的方法】可以分为两大步：</p><p>第一步：选出内在价值高的好企业</p><p>第二步：在合理的价格把握时机，及时买入</p><p>【关键富人思维-第八条】</p><p>⭐股票价格大跌能跌出什么？<br>🌹我们【投资股票正确的方法】可以分为两大步：<br>第一步：选出内在价值高的好企业<br>第二步：在好的价格及时买入</p><p>这两步是不能颠倒的。<br>【当股市的价格出现下跌时】，好企业代表的好股票会出现好的买入价格，但是坏企业会跌出让投机者眼红的“陷阱”。如果在选择企业这一步错了，不管是多便宜的价格都徒劳无功，反而损失惨重。</p><p>【理性的投资者】对自己无法预测股票价格有自知之明，因为价格的波动总是难以预测的，因此他们将主要精力放在好企业的选择上，当好价格出现的时候果断出手，而后不管是继续跌还是涨，都是任凭风浪起稳坐钓鱼船。他们一般很少看股票，却获得了很高的收益。</p><p>💎一句话总结：👇<br>股票大跌既有机会也有陷阱，机会的识别需要眼力，机会的把握需要技能，当眼力和技能配不上这个机会的时候，往往会步入陷阱之中。</p><p>【关键富人思维—第九条】</p><p>⭐很多人炒股都亏，就说股票风险高，到底该怎么看待投资股票这件事？</p><p>🌹【投机炒股的人】，不懂就去投，一心想赚一把就走，那么股市就是一个大赌场，都特别想赢钱，但又特别怕输钱，风险自然是非常大</p><p>而且还很容易上当受骗，赚了以为是自己本事，亏了又说运气不好，说到底都是自欺欺人。</p><p>涨了开心要命，跌了悲伤绝望，被价格的波动带着一天悲喜两重天，说到底还是没有技能让自己内心踏实💡</p><p>🌹【真正的投资股票】，是关注股票代表的公司的好坏，是看到股票背后的本质，经过严谨的分析得出的结论。</p><p>这样的投资，即使短时间的价格波动也能心理踏实，最终能够获得复利带来的长期收益💰</p><p>💎一句话总结：👇<br>投资股票的正确姿势是靠分析，能选出好股票风险自然就小。赌徒在股市是把身家性命交给市场，不懂就投，肯定要被懂的人收割的。</p><h3 id="6-企业分析"><a href="#6-企业分析" class="headerlink" title="6 企业分析"></a>6 企业分析</h3><p>企业分析就是从一家公司的使命、愿景、核心价值观、领导团队等方面判断一家公司的未来走势</p><p>再说一下为什么要学【企业分析】？ </p><p>买股票就是买公司，投资要学企业；</p><p>打工族如果学了企业更有助于升职加薪，上班要学企业；</p><p>创业者学了企业能大幅提高成功概率，创业也要学企业。</p><h4 id="⭕️重点1：E-B-S-I，四类人群与企业的关系"><a href="#⭕️重点1：E-B-S-I，四类人群与企业的关系" class="headerlink" title="⭕️重点1：E\B\S\I，四类人群与企业的关系"></a>⭕️重点1：E\B\S\I，四类人群与企业的关系</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/21.png"></p><p>无论你是打工者、企业家还是投资者。你会发现，你越了解企业，你就越富有</p><h4 id="⭕️重点2：企业与个人职业发展、创业"><a href="#⭕️重点2：企业与个人职业发展、创业" class="headerlink" title="⭕️重点2：企业与个人职业发展、创业"></a>⭕️重点2：企业与个人职业发展、创业</h4><p>企业与个人的发展息息相关，企业愿意为员工付出、重视员工，会增加员工的归属感和责任心。在良性的企业文化中学习和成长出来的员工，也会全心全意为企业着想，推动企业的发展。循环共赢</p><p>创业也是一样，创业不仅要有好的项目支撑，更重要的为自己的企业树立良好的企业文化和核心价值观。吸引更多志同道合的人一起奋斗。</p><h4 id="⭕️重点3：企业分析工具——强大企业模型"><a href="#⭕️重点3：企业分析工具——强大企业模型" class="headerlink" title="⭕️重点3：企业分析工具——强大企业模型"></a>⭕️重点3：企业分析工具——强大企业模型</h4><p>企业分析利器——强大企业模型，学习的时候也要注意两点：</p><p>👉2、思考一下：为什么懂企业对工作、创业、投资有一箭三雕的作用？</p><p>🌟强大企业模型，包括9个关键要素。</p><p>领导者、企业文化、治理结构、商业模式、团队、沟通、现金流、系统、法规</p><p>【领导者】是最核心的要素。其他8个关键要素都和领导者有着直接的关系</p><p>强大企业模型可以让普通员工像CEO一样去思考企业的问题。</p><p>强大企业模型不但可以知道我们经营好自己的企业，还可以让我们看明白别人的企业。</p><p>分析清楚一家企业对我们有什么用呢？</p><p>1、跳槽的时候能选出更有潜力的好公司，职业发展上获得超额回报。</p><p>2、做投资的时候能选出好公司，给企业估值，获得年化20%-30%以上的收益率。</p><p>【关键富人思维第十条】</p><p>🌹为什么工作者、投资者都需要通晓企业分析技能？</p><p>⭐并不是创业者 、大老板才需要了解企业。</p><p>【投资中】，股票本质是企业，只有把9大要素都分析清楚，才能分析出好企业，才能给企业估值.</p><p>【工作中】，干工作的时候要有企业经营的思维，这样才更容易升职加薪。</p><p>即便不为升职，干工作的时候也要有企业经营的思维。因为当你站在更高层去看自己的工作内容的时候你才能更好的理解自己的工作内容，这样你可以把工作做成老板真正想要的样子。</p><p>而那些只盯着自己的岗位的“井底之蛙”，有的时候挨了骂都不知道为什么，因为他缺乏跳出自己的框框看企业的技能，这就是他自己工作干不好的原因。</p><p>所以无论投资、工作，都需要通晓企业分析技能。</p><p>💎总结一句话：工作者用企业分析模型看透工作，投资者用企业分析模型看透股票💡</p><hr><h2 id="半程总结"><a href="#半程总结" class="headerlink" title="半程总结"></a>半程总结</h2><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/14.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/15.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/16.jpg"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/17.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/18.png"></p><h2 id="正篇-2"><a href="#正篇-2" class="headerlink" title="正篇-2"></a>正篇-2</h2><h3 id="7-REITs"><a href="#7-REITs" class="headerlink" title="7 REITs"></a>7 REITs</h3><p>REITs：Real Estate Investment Trusts 房地产投资信托基金，REITs是一种依照法律程序成立的，以发行股票或基金单位的方式汇集投资者的资金，由专业机构进行房地产的经营管理，并将90%以上的税后收入净额分配给投资者的一种信托组织。简单来说，REITs 就是代理投资者投资房地产的上市企业。</p><p>特点：</p><ul><li><p>定期强制高分红</p></li><li><p>投资门槛低</p></li><li><p>交易成本低</p></li><li><p>流动性强</p></li><li><p>专业化管理</p></li><li><p>收益率相对较高</p></li></ul><p>通过 REITs 我们可以很容易的投资世界主要国家的房地产。你看中哪个国家的房地产市场，你就买他的 REITs</p><p>房地产作为投资工具的优缺点：</p><ul><li><p>优点：能带来稳定的现金流，保值增值能力强</p></li><li><p>缺点：投资金额大，交易税费高，难变现</p></li></ul><p>正因为房地产作为投资工具有着明显的优缺点，所以 REITs 才被设计出来。对于开发商而言，通过 REITs 可以把开发好的房地产快速变现，提高开发效率；对于投资者来说，几百元就可以投资房地产了，大幅降低了投资门槛；对政府来说，REITs 促进房地产市场更健康的发展，有利于国家经济。</p><p>REITs 和房地产股票区别：<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/22.png"></p><p>我个人的理解，REITs 的本质就是房地产，房地产有的风险，REITs 基本也会有。房价下跌REITs也会下跌。但是房地产市场相比其他市场还是比较稳定的，所以 REITs 给大家提供了一种除了买房或买商铺以外的投资房地产市场的途径。</p><h3 id="8-基金"><a href="#8-基金" class="headerlink" title="8 基金"></a>8 基金</h3><h4 id="⭕️概念：认识一下“基金”"><a href="#⭕️概念：认识一下“基金”" class="headerlink" title="⭕️概念：认识一下“基金”"></a>⭕️概念：认识一下“基金”</h4><p>1 什么是基金？</p><p>把投资者的钱集中起来交给基金公司打理，基金公司赚钱了我们就赚钱了</p><p>2 基金有哪些类型？</p><p>2.1 按照基金的交易场所划分：场内基金、场外基金</p><p>场内基金：直接在证券交易所内投资的基金</p><p>场外基金：证券交易所外可以买卖的基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-2.png"></p><p>2.2 按照基金的投资对象去划分：货币基金、债券基金、混合基金、股票基金</p><p>如果主要把钱主要投资到了股票上，那就是股票基金</p><p>如果铁蛋主要把钱投资到了债券上，那就是债券基金</p><p>如果不限制资金用途，爱投资什么投资什么，那就是混合基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-3.png"></p><p>不同类型基金的年化收益率区别</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-4.png"></p><p>2.3 按照投资方式划分：主动型基金和被动型基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-5.png"></p><p>【主动型基金】，这种基金由基金经理决定买哪些股票，如股票基金、混合基金。</p><p>【被动型基金】就是【指数基金】，只根据指数配置股票，不人为选择股票。</p><h4 id="⭕️重点1：指数基金定投"><a href="#⭕️重点1：指数基金定投" class="headerlink" title="⭕️重点1：指数基金定投"></a>⭕️重点1：指数基金定投</h4><p>推荐的方式是：定期变额定投</p><p>【定期】可以是每月、每季度、每年</p><p>【变额】指投资额度会变化</p><p>【定期】+【变额】，这相当于指数基金的收益率放大器</p><p>这个变化不是随意变的，而是跟随投资工具的【市盈率】而变。</p><p>⭕那什么是【市盈率】呢？专业说法是市价盈利比率，是一个投资回报指标</p><p>市盈率几年就代表几年回本，越低越好。正常来讲市盈率15比较合理</p><p>此外，市盈率也可以作为何时卖出的参考标准</p><blockquote><p>建议每月定投。每月定投日可以设定为发薪日。这样发了工资直接拿出一部分（比如 10%-20%）定投<br>👉市盈率小于12时，每个月定投金额为2X元<br>👉市盈率小于10时，每个月定投金额为4X元</p></blockquote><p>当然也可以设置一个停止买入的市盈率，比如市盈率大于15时暂停买入</p><blockquote><p>友情提示：想投资房子的同学，也可以想想现在的房地产，租金带给你的年化收益率是多少？<br>公式是：【每年的租金÷买房子的总价】，你就知道你房子的年化收益率了</p></blockquote><h4 id="⭕️重点2：长生不老的指数基金"><a href="#⭕️重点2：长生不老的指数基金" class="headerlink" title="⭕️重点2：长生不老的指数基金"></a>⭕️重点2：长生不老的指数基金</h4><p>【指数基金】和主动基金相比，还有一个特别厉害的优点：【永生不死，长期上涨】</p><p>指数基金是会新陈代谢的，会自动淘汰那些不好的股票，加入满足条件的股票</p><h4 id="⭕️重点3：最好的定投是选择好的【股票】和【REITs】"><a href="#⭕️重点3：最好的定投是选择好的【股票】和【REITs】" class="headerlink" title="⭕️重点3：最好的定投是选择好的【股票】和【REITs】"></a>⭕️重点3：最好的定投是选择好的【股票】和【REITs】</h4><p>其实，还有比指数基金更好的理财工具：股票和REITs</p><blockquote><p>通常我们买基金共有4种渠道<br>1、证券公司<br>2、银行<br>3、基金公司<br>4、第三方代销平台，如支付宝、天天基金，蚂蚁聚宝，京东金融等</p></blockquote><p>【关键富人思维——第十三条】</p><p>掌握高收益率投资工具的科学方法是什么？</p><p>❤️【方法一】：很多人刚刚知道有一个高收益的工具，恨不得马上就买，然后就自我憧憬能赚多少。或者选择去市场中盲目的尝试，事实证明，他们自己总结的方法时而有效，时而无效，时而自信找到了暴富出路，时而迷茫否定自己、骂社会，我称之为焦虑的“【烧钱尝试法】”</p><p>其实他们不仅损失了自己的血汗钱，同时在错误尝试的时间里，也错过了正确买入好目标的机会。</p><p>❤️【方法二】：其实最快的方法，绝对不是马上去盲目尝试，磨刀不误砍材工，应该先去学习，在学习中最快的方法是什么，是看书吗？</p><p>如果看书能够实现财务自由，那么很多人早就财务自由了，因为看书最大的弊端就是没有反馈，没有人告诉你学的对还是学的错。</p><p>沉溺在看书中寻求财富自由的人，不能说不努力，但是因为没有有经验的老师指点，很多都成了【无效的努力】，最可怕的不是慢，是选错了方向，走错了路，在错误方向上的努力只是巩固错误。<br>❤️【方法三】：那么最快的学习方法是什么？答案是【巨人同行法】，跟着已经长期成功的投资者学习，巴菲特的老师是投资之神格雷厄姆，我们早读中8岁的投资神童，她的老师是父亲，也是成功的投资家。</p><p>他们都是一边勤奋学习理论，一边在老师的指导下纠正错误，一直走在一条正确的努力之路上。这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。</p><p>这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。你打算选哪条路？</p><p>【给自己找到正确的反馈，别让资金、时间白费。】</p><p>❤️总结一句话：站在巨人的肩膀上成长是最快的，站在巨人的肩膀学习理财技能也是变现最快的。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-1.png"></p><h3 id="9-通货膨胀"><a href="#9-通货膨胀" class="headerlink" title="9 通货膨胀"></a>9 通货膨胀</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/09-1.png"></p><h4 id="⭕️重点1：什么是通货膨胀"><a href="#⭕️重点1：什么是通货膨胀" class="headerlink" title="⭕️重点1：什么是通货膨胀"></a>⭕️重点1：什么是通货膨胀</h4><blockquote><p>【通货膨胀】= 通货 + 膨胀</p></blockquote><p>通货就是通用货币，也叫法币，就是法律规定的必需使用的货币，比如：人民币</p><p>我们来看一下知名的【费雪方程式】</p><pre><code>MV=PT</code></pre><blockquote><p>我们一个一个拆解来看看<br>M ：货币的数量 V ：货币流通速度<br>P ：物价水平 T ：各类商品的交易总量<br><strong>在社会中V和T一般是比较稳定的，所以货币量M决定物价P</strong></p></blockquote><p>即，VT不动，M与P呈现正比例关系</p><p>也就是说， 货币越来越多，物价就会持续上涨</p><p>这就是通货膨胀</p><h4 id="⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？"><a href="#⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？" class="headerlink" title="⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？"></a>⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？</h4><pre><code>⭐实际CPI=M2增长率-GDP增长率⭐</code></pre><blockquote><p>M2增长率反映了一个国家每年钱的增长速度<br>GDP增长率反映了一个国家每年创造的商品和服务的增长速度<br>所以货币增长比商品和服务增长多出来的部分，这就是实际的CPI，也叫实际通货膨胀率⭐</p></blockquote><h4 id="⭕️重点3：如何避免被“割韭菜”？"><a href="#⭕️重点3：如何避免被“割韭菜”？" class="headerlink" title="⭕️重点3：如何避免被“割韭菜”？"></a>⭕️重点3：如何避免被“割韭菜”？</h4><p>既然理财如此重要，怎么才能在主动选择理财中，不被割韭菜呢？</p><h5 id="❌韭菜的特点1："><a href="#❌韭菜的特点1：" class="headerlink" title="❌韭菜的特点1："></a>❌韭菜的特点1：</h5><p>韭菜是【投机者】而不是【投资者】。</p><p>【投资】和【投机】有什么区别？ 👇</p><p>🍣【投资】以赚现金流为主，而且是赚确定性很高的现金流，赚差价为辅。</p><p>💰投资者会选出买入高股息率的好股票、高现金分红率的REITs。</p><p>💰即使价格不涨甚至下跌，每年也有7%—15%的现金分红收益</p><p>投机者典型的心态是：</p><p>生怕错过什么，又害怕被割韭菜，各种理由不愿意花精力去学习理财技能，所以想去市场上【试一试】，可能生活中是有负债，或者没有好支出，想着投资少点，亏了也就亏了，对理财没有正确认知。</p><h5 id="❌韭菜的特点2："><a href="#❌韭菜的特点2：" class="headerlink" title="❌韭菜的特点2："></a>❌韭菜的特点2：</h5><p>追求短期收益，高频交易，而不是长期投资</p><h5 id="❌韭菜的特点3："><a href="#❌韭菜的特点3：" class="headerlink" title="❌韭菜的特点3："></a>❌韭菜的特点3：</h5><p>不学习或不深入学习，盲目乱投资</p><p>【关键富人思维-第十四条】<br>⭐有的投机者说自己也赚钱了，那么选择做投资者到底好在哪？<br>🌹我们投资理财到底是为了什么呢？赚钱，但进一步想，赚钱是不被钱绑架，能有时间做自己想做的事，能和家人快乐的生活。</p><p>【不懂就去投的人】，短期内碰上运气了，也能赚到钱，但是他们是怎么度过的呢，每天把大量时间用来盯着大盘，昼夜想着跌了还是涨了，精神总是高度紧张，甚至睡觉都在想明天股票的情况，因为他们选择了“赌博”。历史证明，绝大多数投机者本来最应该乐观开心的两年，到头来却是在焦虑、闹心中度过的，因为他们没有真正的投资判断依据，这就是投机者的生活。</p><p>【懂得投资的人】，通过一整套分析方法选出优质的投资目标，算出买入好价格，买入，持有，再算出卖出合理价格，卖出。剩下的时间该干什么干什么，价格跌了，心里知道这是表面的波动，不被其迷惑，拿得住；价格涨了，知道什么时候该卖出，不冲动，赚踏实稳当钱。更厉害的，长期持有，被分红的复利滋润着。这是学习科学方法的自然成果，这也是不学习像苍蝇撞大运的投机者，与踏实学习走正道的投资者的最大差别。</p><p>当然，既不投机，也不投资的人都感受不到这些，他们只能感受到钱越来越不值钱，而自己的生活好像越来越紧吧了。</p><p>💎总结一句话：投资者获得的是金钱自由，时间自由，心理自由，投机者就算撞运赚了点，却一直在焦虑与煎熬中。</p><h3 id="10-股票"><a href="#10-股票" class="headerlink" title="10 股票"></a>10 股票</h3><p>以雪球app为例，选一只股票，看财务报表</p><p>几个指标：</p><p>1、行业对比：对比企业在行业中排名</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-1.png"></p><p>2、资产负债率：一般资产负债率超过70%，资产风险大</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-2.png"></p><p>3、ROE：常年收益率3%以下，还不如我拿着钱放货币基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-3.png"></p><p>4、毛利率：100万的售价最后只能赚9万块钱，剩下的都是成本。说明行业竞争激烈，公司没有差异化，没有很高的利润。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-4.png"></p><p>5、净利润和经营现金流：公司表面上赚到了钱，但实际上都是别人欠他不给他，说明公司根本在行业里没地位。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-5.png"></p><p>6、分红：企业有盈利才会分红</p><blockquote><p>从长期来说，一只股票的回报率跟公司的发展是环环相扣的，如果一家公司 40 年来的盈利一直是它资本的 6%（ROE），那在长期持有 40 年后，你的年均收益率不会和 6%有什么区别，即便你当初买的是便宜货。如果该公司在 20-30 年间盈利都是资本的 18%（ROE），即便你当初出价过高，回报依然会令你满意！——查理芒格</p></blockquote><p><strong><em>但是我希望大家记住：投资股票就是投资企业，企业赚钱你就赚钱</em></strong></p><p>【关键富人思维–第十五条】</p><p>我们最贵的东西是什么？<br>钱并不是最重要的东西，那我们最重要的是什么呢？</p><p>财务自由的本质就是时间自由，你如果是个价值投资者，那么你完全可以认为你买到的是——高额的银行存款。在享受生活的同时，不用看大盘，看K线。每年只看1-2次财报，其余的时间收钱，做自己喜欢的工作，享受生活。</p><p>其实，人最宝贵的是【时间精力】，每个人每天的时间都只有24小时，但是每个人能够挥洒精力的时间却远远小于24小时。严格上说，我们一天能够真正专注的时间可能都不超过2小时。</p><p>根据二八定律，你20%的投入决定了80%的成败。而这20%实际就是那每天2小时的精力投入。因此，我们才反反复复强调要站在巨人的肩膀上，前人走过的弯路，我们就不要再走了。</p><p>我们对于这2小时真正的精力投向，决定了我们的一生。人就是自己所有选择的求和结果</p><p>那些独自学习、独自试错的人，他们需要付出四项成本：时间成本、机会成本、金钱成本、试错成本。摸索、搜寻弄懂一个知识点的时间是站在巨人肩膀上学习的数年、数倍。</p><p>当年纪慢慢变大，【精力善用】才逐渐显示出复利的威力，人生的分野就在此开始。</p><p>【总结一句话】：时间和精力才是最宝贵的，尽量用它做正确的事，高效的事，而不是为了试错而试错，为了省钱浪费了最宝贵的时间价值。</p>]]></content>
      
      
      <categories>
          
          <category> management </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dairy </tag>
            
            <tag> self management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0926</title>
      <link href="2020/09/26/0926/"/>
      <url>2020/09/26/0926/</url>
      
        <content type="html"><![CDATA[<p>周五，我和妈妈各自都有些不太舒服，我嗓子疼有点感冒的症状，妈妈说头晕。<br>晚饭后，我坚持让妈妈跟我一起喝点小柴胡，妈妈原本有点拒绝，最后我冲好端到房间去，妈妈还是喝了。</p><p>星期六，昨晚吃过药之后好像身体都有了好转。按往常一样周六的中午全家一起出去吃了饭。<br>饭后到家，我喊了一句：再吃一顿小柴胡吧，巩固一下。妈妈说好，就回房间去了。</p><p>我拿了药，去厨房烧水、冲药。<br>以前我说身体不舒服的时候，都是妈妈来帮我冲药，给我送到房间来叮嘱我喝，我即便说不要紧她也非逼着我喝。</p><p>这时候我才意识到，原来不是我长大了，而是妈妈真的老了。</p>]]></content>
      
      
      <categories>
          
          <category> something </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dairy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悟到</title>
      <link href="2020/09/24/know-something/"/>
      <url>2020/09/24/know-something/</url>
      
        <content type="html"><![CDATA[<p>I always need to anticipate problems instead of just reacting to them.</p>]]></content>
      
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
