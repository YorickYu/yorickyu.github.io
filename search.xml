<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0926</title>
    <url>/2020/09/26/0926/</url>
    <content><![CDATA[<p>周五，我和妈妈各自都有些不太舒服，我嗓子疼有点感冒的症状，妈妈说头晕。<br>晚饭后，我坚持让妈妈跟我一起喝点小柴胡，妈妈原本有点拒绝，最后我冲好端到房间去，妈妈还是喝了。</p>
<p>星期六，昨晚吃过药之后好像身体都有了好转。按往常一样周六的中午全家一起出去吃了饭。<br>饭后到家，我喊了一句：再吃一顿小柴胡吧，巩固一下。妈妈说好，就回房间去了。</p>
<p>我拿了药，去厨房烧水、冲药。<br>以前我说身体不舒服的时候，都是妈妈来帮我冲药，给我送到房间来叮嘱我喝，我即便说不要紧她也非逼着我喝。</p>
<p>这时候我才意识到，原来不是我长大了，而是妈妈真的老了。</p>
]]></content>
      <categories>
        <category>something</category>
      </categories>
      <tags>
        <tag>dairy</tag>
      </tags>
  </entry>
  <entry>
    <title>Tri-colour marking</title>
    <url>/2020/10/21/Tri-colour-marking/</url>
    <content><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/gc-1.gif"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU 乱序执行反证</title>
    <url>/2020/10/19/CPU-Out-of-Order/</url>
    <content><![CDATA[<h3 id="循序运行"><a href="#循序运行" class="headerlink" title="循序运行"></a>循序运行</h3><p>主条目：指令周期<br>在早期的处理器中，指令的执行一般在以下的步骤中完成：</p>
<p>1 指令获取。<br>2 如果输入的运算对象是可以获取的（比如已经存在于寄存器中），这条指令会被发送到合适的功能单元。如果一个或者更多的运算对象在当前的时钟周期中是不可获取的（通常需要从主存获取），处理器会开始等待直到它们是可以获取的。<br>3 指令在合适的功能单元中被执行。<br>4 功能单元将运算结果写回寄存器。</p>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>这种范式通过以下步骤挑选可执行的指令先运行：</p>
<p>1 指令获取。<br>2 指令被发送到一个指令序列中（也称执行缓冲区或者保留站）。<br>3 指令将在序列中等待直到它的数据运算对象是可以获取的。然后指令被允许在先进入的、旧的指令之前离开序列缓冲区。<br>4 指令被分配给一个合适的功能单元并由之执行。<br>5 结果被放到一个序列中。<br>6 仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器中。这个过程被称为毕业或者退休周期。</p>
<p>乱序执行的重要概念是实现了<strong>避免计算机在用于运算的对象不可获取时的大量等待。</strong>在上述文字的要点中，乱序执行处理器避免了在顺序执行处理器处理过程第二步中当指令由于运算数据未到位所造成的等待。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b &#x3D; a * 5</span><br><span class="line">v &#x3D; b++</span><br><span class="line">c &#x3D; a + 3</span><br></pre></td></tr></table></figure>
<p>由于1与3可并发运行，而2之b无法随即获得，因此可以先计算乘法1与加法3，再运行2。</p>
<a id="more"></a>

<h3 id="证明CPU乱序执行存在"><a href="#证明CPU乱序执行存在" class="headerlink" title="证明CPU乱序执行存在"></a>证明CPU乱序执行存在</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OutOfOrder &#123;</span><br><span class="line">    private static int x &#x3D; 0, y &#x3D; 0;</span><br><span class="line">    private static int a &#x3D; 0, b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int i &#x3D; 0; &#x2F;&#x2F; 记录次数</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x &#x3D; 0; y &#x3D; 0;</span><br><span class="line">            a &#x3D; 0; b &#x3D; 0;</span><br><span class="line">            Thread one &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    a &#x3D; 1;</span><br><span class="line">                    x &#x3D; b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread two &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    b &#x3D; 1;</span><br><span class="line">                    y &#x3D; a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();two.start();</span><br><span class="line">            one.join();two.join();</span><br><span class="line">            if (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D;0) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;次，出现(&quot;+x+&quot;,&quot;+y+&quot;)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常执行期待的结果不会出现x和y同时为0的情况<br>demo中测试的是语句级乱序的现象，语句级乱序的发生说明必定存在指令级乱序<br>如果出现则说明CPU存在乱序执行</p>
<p>结果：<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/outoforder.png"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK1.7 ConcurrentHashMap 两次数组下标计算问题</title>
    <url>/2020/11/03/concurrenthashmap-two-array-index/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ConcurrentHashMap结构如下:</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p>
<p>Segment[]数组的长度在ConcurrentHashMap的构造方法中由并发级别 <code> DEFAULT_CONCURRENCY_LEVEL</code> 计算得出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且初始化完成后，Segment[]数组不会再扩容。</p>
<p>HashEntry[]数组的长度在ConcurrentHashMap的构造方法中由初始化容量 <code> DEFAULT_INITIAL_CAPACITY</code> 和并发级别 <code> DEFAULT_CONCURRENCY_LEVEL</code> 计算得出，且最小值为2，向上取值时为2的整数幂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">if (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line">int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; &#x2F;&#x2F; 最小值2</span><br><span class="line">while (cap &lt; c) &#x2F;&#x2F; 保证取值是2的整数幂</span><br><span class="line">    cap &lt;&lt;&#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>初始化完成后，HashEntry[]数组会扩容。而且由自旋锁和volatile保证了线程安全性</p>
<p>由此可见，ConcurrentHashMap元素插入需要两次计算数组下标，让我们分析一下源码中是如何设计的。</p>
<a id="more"></a>

<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里采用的 <strong><em><a href="http://d0evi1.com/wang-jenkins-hash/">Wang/Jenkins Hash算法</a></em></strong> </p>
<h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>segmentShift在构造方法中计算的出：32 - sshift，sshift记录值为Segment[]数组长度值为2的几次幂。</p>
<p>例：</p>
<p>并发级别为16，通过构造方法中的while遍历，得到：ssize为32，sshift为5。</p>
<p>即Segment[]数组的数组长度ssize为32，sshift为5 – $2^5$</p>
<p>所以，</p>
<p>上面第4行代码表示让hash值高位(Segment数组长度)决定下标。</p>
<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里第6行代码表示让hash值的低位(HashEntry数组长度)决定下标。</p>
<h2 id="他是怎么想到的？"><a href="#他是怎么想到的？" class="headerlink" title="他是怎么想到的？"></a>他是怎么想到的？</h2><p>源码中真的有好多巧妙的设计值得学习和思考，最近总有一个问题萦绕在耳边：”他们到底TM是怎么想出来的？“</p>
<p>也太秀了！华丽的像是投机取巧～</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ConcurrentHashMap</tag>
        <tag>put</tag>
      </tags>
  </entry>
  <entry>
    <title>git command</title>
    <url>/2020/10/10/git/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然现在常用sourcetree或者直接在IDE中通过图形界面操作，但是开发中难免遇到一些棘手的问题需要使用git命令去管理项目</p>
<p>这里列出一些常用的命令，方便查询</p>
<a id="more"></a>

<h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><p>1 初始化一个仓库: </p>
<pre><code>git init</code></pre>
<p>2 添加文件到Git仓库，分两步：</p>
<pre><code>2.1 git add &lt;fileName&gt; 可以反复多次添加，也可以一次添加多个文件(git add . / git add file1 file2)

2.2 git commit -m “message” 提交</code></pre>
<p>3 git status 随时掌握工作区的状态 git status -s 简短信息查看</p>
<p>4 git diff <fileName> 查看修改的内容 git diff –cached 查看已缓存 git diff HEAD 查看所有 git diff –stat 只显示摘要</p>
<p>5 在本地版本间穿梭: </p>
<pre><code>git reset --hard commit_id (回到上一版本：git reset —hard HEAD^)</code></pre>
<blockquote>
<p>ps：在Git中，用HEAD表示当前版本，上一版本就是HEAD^，同理上上版本HEAD^^，如果往上100个版本，可以写成HEAD~100</p>
</blockquote>
<p>6 git log 可以查看历史提交记录，以便确定要退回版本的commit_id (简化信息：</p>
<pre><code>git log --pretty=oneline)</code></pre>
<p>7 查看命令历史:</p>
<pre><code>git reflog </code></pre>
<p>8 丢弃工作区的修改：</p>
<pre><code>git checkout -- &lt;fileName&gt; (这里的 -- 很重要，如果没有--，就编程切换分支的命令)</code></pre>
<p>9 丢弃暂存区的修改：</p>
<pre><code>第一步，git reset HEAD &lt;fileName&gt;(HEAD表示当前最新版本)

第二步，git checkout --&lt;fileName&gt;</code></pre>
<p>10 丢弃版本库的修改：和第5条同理，其实就是切换回先前的分支:</p>
<pre><code>git reset --hard commit_id</code></pre>
<p>11 删除文件：</p>
<pre><code>11.1 方法一：先删除本地rm &lt;file&gt;，然后再git add/rm &lt;file&gt;，git commit -m “message”

11.2 方法二：直接git rm &lt;file&gt;，git commit -m “message”
ps: 如果是rm &lt;file&gt;，可以直接通过git checkout -- &lt;file&gt;修改回来</code></pre>
<h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><p>1 在GitHub上创建完远程仓库后，在本地的仓库下运行命令，关联远程库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure>

<p>2 下一步，使用命令：，将本地库的所有内容推送到远程库上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps：第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送命令即可省略，直接用git push origin master</p>
</blockquote>
<h2 id="创建、合并分支"><a href="#创建、合并分支" class="headerlink" title="创建、合并分支"></a>创建、合并分支</h2><p>1 查看分支：git branch</p>
<p>2 创建分支：git branch <name></p>
<p>3 切换分支：git checkout <name></p>
<p>4 创建+切换分支：git checkout -b <name></p>
<p>5 合并某分支到当前分支：git merge <name></p>
<blockquote>
<p>ps：合并分支时加入–no-ff参数，表示禁用Fast forward：git merge –no-ff -m “merge with no-ff” <name>这种操作合并后的历史有分支，能看出曾经做过合并，而Fast forward合并就看不出来</p>
</blockquote>
<p>6 删除分支：git branch -d <name></p>
<p>7 查看合并分支图：git log –graph</p>
<h2 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h2><p>情景：在develop分支开发时，突然报出紧急bug：</p>
<p>1 在develop分支把工作现场“贮藏”起来：</p>
<pre><code>git stash</code></pre>
<p>2 然后确定要在哪个分支上处理bug，假如在master上修复，就从master创建临时分支：</p>
<pre><code>git checkout master 
git checkout -b bug001</code></pre>
<p>3 在bug001分支上处理bug，修复完成后切回master进行合并：</p>
<pre><code>git merge --no-ff -m “merge with no-ff” bug001</code></pre>
<p>4 现在bug处理完了，回到develop查看刚刚”贮藏”的代码：</p>
<pre><code>git stash list</code></pre>
<p>5 把”贮藏”的代码拿到develop上，继续开发：</p>
<pre><code>git stash pop(git stash apply + git stash drop)</code></pre>
<blockquote>
<p>ps：apply恢复，但stash的内容并不删除，需要再用drop删除；pop恢复的同时也删除了</p>
</blockquote>
<h2 id="新特性分支"><a href="#新特性分支" class="headerlink" title="新特性分支"></a>新特性分支</h2><p>情景：开发一个新feature，但是突然说这个功能不做了（在新分支上已经执行add,commit操作）</p>
<p>丢弃一个没有被合并过的分支，强行删除该分支：</p>
<pre><code>git branch -D &lt;name&gt;</code></pre>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>1 推送本地分支到远端，如果推送失败，先git pull抓去远程的新提交</p>
<pre><code>git push origin &lt;name&gt;</code></pre>
<p>2 拉取远端分支到本地：</p>
<pre><code>git checkout -b &lt;name&gt; origin/&lt;name&gt;</code></pre>
<blockquote>
<p>ps：查看权限：git remote -v</p>
</blockquote>
<p>3 建立本地分支和远程分支的关联：</p>
<pre><code>git branch --set-upstream &lt;name&gt; origin/&lt;name&gt;</code></pre>
<blockquote>
<p>ps：如果git pull提示no tracking information，则说明没有创建关联</p>
</blockquote>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>git rebase操作可以把本地未push的分叉提交历史整理成直线</p>
<h2 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h2><p>1 创建新标签 git tag <tagname> 默认添加在HEAD上，如果要特定添加在某条记录上可以 </p>
<pre><code>git tag &lt;tagname&gt; &lt;commit id&gt;

例: git tag v1.0 fa=52c662</code></pre>
<p>2 git tag -a <tagname> -m ‘ababababllal’</p>
<p>3 git tag 查看所有标签</p>
<p>4 git tag -d <tagname> 删除标签</p>
<p>5 推送标签到远程</p>
<pre><code>git push origin &lt;tagname&gt; </code></pre>
<p>6 推送所有标签到远程 </p>
<pre><code>git push origin --tags </code></pre>
<p>7 删除远程标签，分两步：</p>
<pre><code>第一步，先删除本地标签 git tag -d v1.0

第二部，删除远程，命令也是push，git push origin :refs/tags/v1.0</code></pre>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap modCount fast-fail X原子性</title>
    <url>/2020/11/01/hashmap-modCount/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap源码中定义的成员变量并不多，其中我们最不熟悉的应该就是modCount，那么它到底是做什么的呢？</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/modcount.jpg"></p>
<p><font color=red>如果你没时间思考这篇文章，你可以直接跳转到 <a href="#%E7%BB%93%E8%AE%BA">9.结论</a> 处</font></p>
<h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><p>modCount在HashMap中记录的是HashMap对象被修改的次数，这里专业的说法是集合在结构上修改时被会记录在modCount中。</p>
<blockquote>
<p>文中源码版本为 JDK1.7，modCount的部分在JDK1.8中作用是相同的。只因为JDK1.7中源码比较简洁，所以本文选用JDK1.7来缩减篇幅。</p>
</blockquote>
<p>在源码中记录到的modCount++的方法包括：</p>
<ul>
<li>HashMap put方法</li>
<li>HashMap的remove-&gt;removeEntryForKey方法 通过key移除元素</li>
<li>HashMap的removeMapping方法，通过object移除元素</li>
<li>HashMap的clear方法</li>
</ul>
<p>从这里可以看出，结构上的修改主要是添加和删除两部分。</p>
<h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>我们都知道在JDK1.7中HashMap是线程不安全的，这个 <strong>不安全</strong> 我是分两方面理解的：</p>
<p><strong>1 多线程数组扩容时出现循环链表问题</strong></p>
<p>因为扩容时链表顺序会反转，所以多线程操作时可能会出现循环链表的情况，那么在get方法时就会死循环</p>
<blockquote>
<p>JDK1.8中也修复了这个问题</p>
</blockquote>
<p><strong>2 多线程读写时造成数据混乱的问题</strong></p>
<p>HashMap中有引入了一个 <strong>fast-fail</strong> 的概念，目的是避免高并发读写造成的数据错乱的隐患。</p>
<h2 id="expectedModCount"><a href="#expectedModCount" class="headerlink" title="expectedModCount"></a>expectedModCount</h2><p>expectedModCount这个变量被记录在HashIterator迭代器中。顾名思义，表示期望的修改次数，当期望修改的次数不等于实际修改的次数时，就会触发 <strong>fast-fail</strong> 快速失败的容错处理</p>
<h2 id="fast-fail"><a href="#fast-fail" class="headerlink" title="fast-fail"></a>fast-fail</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">    if (modCount !&#x3D; expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器调用 next() 方法时会调用 nextEntry() 方法，方法中首先会判断 modCount 与 expectedModCount 是否相等</p>
<p>如果不相等直接抛出 java.util.ConcurrentModificationException 异常</p>
<blockquote>
<p><strong>GeeksForGeeks中的解释为：</strong></p>
<p>In multi threaded environment, if during the detection of the resource, any method finds that there is a concurrent modification of that object which is not permissible, then this ConcurrentModificationException might be thrown.</p>
<ol>
<li>If this exception is detected, then the results of the iteration are undefined.</li>
<li>Generally, some iterator implementations choose to throw this exception as soon as it is encountered, called fail-fast iterators.</li>
</ol>
<p>For example: If we are trying to modify any collection in the code using a thread, but some another thread is already using that collection, then this will not be allowed.</p>
</blockquote>
<p>在多线程环境中，如果在检测资源期间，任何方法发现该对象存在并发修改，而这是不允许的，则可能会抛出此ConcurrentModificationException。</p>
<p>1 如果检测到此异常，则迭代结果不确定。</p>
<p>2 通常，某些迭代器实现选择将遇到此异常的异常立即抛出，称为快速失败迭代器。</p>
<p>例如：如果我们试图使用一个线程来修改代码中的任何集合，但是另一个线程已经在使用该集合，则将不允许这样做。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ConcurrentModificationExceptionDemo类中查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">for (int i &#x3D; 0; i &lt;100 ; i++) &#123;</span><br><span class="line">    m.put(String.valueOf(i), &quot;value&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Iterator iterator &#x3D; m.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String next &#x3D; (String) iterator.next();</span><br><span class="line">            if (Integer.parseInt(next) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;thread 1&quot;);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Iterator iterator  &#x3D; m.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String next &#x3D; (String) iterator.next();</span><br><span class="line">            System.out.println(m.get(next));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>这里第一个线程中的 <code>System.out.println(&quot;thread 1&quot;);</code> 的作用是 <strong><em>触发数据和内存同步</em></strong>。</p>
<blockquote>
<p>这部分内容和寄存器的 <strong><em>缓存行</em></strong> 知识有关，如果不触发数据和内存同步，第二个线程无法正确获取modCount。</p>
</blockquote>
<h2 id="单线程错误案例"><a href="#单线程错误案例" class="headerlink" title="单线程错误案例"></a>单线程错误案例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">m.put(&quot;key1&quot;, &quot;value2&quot;);</span><br><span class="line">m.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">for (String key: m.keySet()) &#123;</span><br><span class="line">    if (key.equals(&quot;key2&quot;)) &#123;</span><br><span class="line">        m.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码块也有可能发生 fast-fail</p>
<p>我们来看一下上面代码块编译后的class文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">m.put(&quot;key1&quot;, &quot;value2&quot;);</span><br><span class="line">m.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">Iterator i$ &#x3D; m.keySet().iterator();</span><br><span class="line">while(i$.hasNext()) &#123;</span><br><span class="line">    Object key &#x3D; i$.next();</span><br><span class="line">    if (key.equals(&quot;key2&quot;)) &#123;</span><br><span class="line">        m.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么看应该就很容易理解了，而且这个错误也很容易发生。</p>
<p>在迭代器遍历的过程中，会将key值为“key2”的元素移除。移除时调用的HashMap的remove方法会对modCount值+1，但是这个方法并不会同步expectedModCount的值。所以在下一次迭代器调用i$.next();方法时，会发生异常。</p>
<p>expectedModCount // For fast-fail：在以下方法会同步modCount值</p>
<ul>
<li>HashIterator的构造方法</li>
<li>HashIterator的remove方法</li>
</ul>
<p>所以将上面移除元素的代码。替换为 <code>i$.remove();</code> 就可以了。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于 i++ 计算不是原子性的怀疑：</p>
<p>HashMap源码记录modCount++这个计算方式在多线程操作时如果不能保证原子性，那么岂不是也有可能触发ConcurrentModificationException异常？</p>
<p>验证过程：<br>1 因为HashMap的put操作会进行modCount++<br>2 modCount声明时也没有指明<strong>volatile</strong><br>那么多线程put是否会造成modCount的值不准确？</p>
<p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ConcurrentModificationExceptionDemo类中查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void atomicTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    HashMap m &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">                m.put(i, String.valueOf(i).hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 10000; i &lt; 20000; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">                m.put(i, String.valueOf(i).hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(5000);</span><br><span class="line">    Iterator iterator &#x3D; m.keySet().iterator();</span><br><span class="line">    iterator.next(); &#x2F;&#x2F; 对比modCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>运行的结果是，如果循环次数不多，最后可以保证modCount的数值正确。但是提升循环插入的次数，会锁住一个线程，导致其他线程的数据没有插入成功，但是modCount的值依然是正确的。</del></p>
<p><del>具体这个魂循环次数设定的阈值，我也没有过多尝试。至少目前我没有因为++计算不是原子性的原因出现过fast-fail</del></p>
<p>运行结果有意外收获:</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/modcount%2B%2B%2B.jpg"></p>
<p>从上图可以看出，不仅在多线程写入的时候modCount的值无法保证（从expectedModCount看出），而且HashMap的size也不满足期望（因为多线程put时，两个线程的key不重复）</p>
<p>为了再次证明我的猜测，可以在多线程中添加 <code>System.out.println(i);</code> 代码，来达到内存同步的目的</p>
<p>结果不出所料：</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/sysmodcount%2B%2B.jpg"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 HashMap多线程读写时可能会抛出ConcurrentModificationException异常，这是fast-fail快速失败机制。</p>
<p>2 fast-fail实现的原理是判断modCount和expectedModCount是否相等</p>
<p>3 modCount++在多线程操作时无法保证原子性，甚至HashMap整个put方法都出现了问题</p>
<blockquote>
<p>PS：所以在JDK1.7的ConcurrentHashMap中出现大量 <strong><em>UNSAFE</em></strong> 和 <strong><em>volatile</em></strong> 关键字。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上文所有代码片段都是基于JDK1.7，虽然JDK1.8中对HashMap做了较大的改动。但是文章的思路和结论都是相同的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
        <tag>fast-fail</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap resize loTail.next=e loTail=e</title>
    <url>/2020/11/06/hashmap-resize-lotail/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap扩容的过程包含了很多巧妙的思考，思想简单易懂，但是代码的实现真的让人折服！</p>
<p>今天快速浏览resize方法时，被两行代码绕住了：</p>
<img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/loTail.next%20%3D%20e.png" style="zoom:50%;" />

<p>可能是对于引用类型的理解不够深刻吧，这两行代码真的看了我一天！网上也很少有人分析这两行代码（可能因为太容易了吧）</p>
<p>最后我自己写了个Demo，算是把这个操作搞清楚了。因为是引用类型的指针指向问题，所以画图也不太好理解，只能自己写个Demo，一点点Debug分析过程。</p>
<p>相关代码在：<a href="https://github.com/YorickYu/JPP">Jpp</a> /TailInsert类中</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="准备一个简单的链表对象"><a href="#准备一个简单的链表对象" class="headerlink" title="准备一个简单的链表对象"></a>准备一个简单的链表对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(K key, V value, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h2 id="简化过程"><a href="#简化过程" class="headerlink" title="简化过程"></a>简化过程</h2><p>先看下面的代码，理解这个过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node a &#x3D; null;</span><br><span class="line">Node b &#x3D; null;</span><br><span class="line">Node c &#x3D; new Node(&#39;c&#39;, &#39;c&#39;, null);</span><br><span class="line">b &#x3D; c;</span><br><span class="line">a &#x3D; c;</span><br><span class="line">c &#x3D; new Node(8,8, null);</span><br><span class="line">a.next &#x3D; c;</span><br><span class="line">a &#x3D; c;</span><br></pre></td></tr></table></figure>

<h3 id="代码1-5行"><a href="#代码1-5行" class="headerlink" title="代码1-5行"></a>代码1-5行</h3><p>声明了a，b两个Node类型的引用，声明c指向一个Node@478对象</p>
<p>然后把a和b都指向了Node@478对象。如下图所示：</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep1.jpg" alt="p1"></p>
<h3 id="代码-6行"><a href="#代码-6行" class="headerlink" title="代码 6行"></a>代码 6行</h3><p>创建了一个新的Node@479对象，将c引用指向这个对象。如下图所示：</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep2.jpg" alt="p1"></p>
<h3 id="代码-7行"><a href="#代码-7行" class="headerlink" title="代码 7行"></a>代码 7行</h3><p>在Node@478中有一个next属性，a.next = c;表示将Node@478的next指向c引用指向的地址(即Node@479)</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep3.jpg" alt="p1"></p>
<h3 id="代码-8行"><a href="#代码-8行" class="headerlink" title="代码 8行"></a>代码 8行</h3><p>a = c; 就是将a的引用重新指向c引用指向的地址(即Node@479)</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep4.jpg" alt="p1"></p>
<p>所以最终的结果就是：</p>
<p>a，c引用指向相同的Node@479对象</p>
<p>b指向Node@478对象，其中Node@478的next引用指向Node@479对象</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pend.png"></p>
<p>理解了上面的过程，下面就非常容易了 ^ ^</p>
<h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><p>创建链表并插入10个元素（尾插）来模拟HashMap数组中某一个节点的链表。</p>
<blockquote>
<p>JDK1.8中，链表长度超过 <strong>变树阈值</strong> 时会将链表变化成红黑树<br>这个变化需要满足两个条件：1 链表长度超过变树阈值 2 HashMap的size大于64</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node tab = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>); <span class="comment">// node链表</span></span><br><span class="line">Node p = tab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Node tail = <span class="keyword">new</span> Node(i, i, <span class="keyword">null</span>); <span class="comment">// 最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = tail;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 尾插</span></span><br><span class="line">        Node e;</span><br><span class="line">        <span class="keyword">while</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = tail;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仿写resize核心代码"><a href="#仿写resize核心代码" class="headerlink" title="仿写resize核心代码"></a>仿写resize核心代码</h3><p>在HashMap扩容时有一个很巧妙的操作，就是数组长度扩容至原先两倍时，重新计算链表节点的插入角标会将原链表随机分布到新数组的两个位置：1 原来角标的位置 2 原角标+原数组长度的位置</p>
<p>而这个操作在JDK1.7和JDK1.8中的思想是相同的，不过实现方式略有不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设：</span><br><span class="line">现在有两个链表节点</span><br><span class="line">他们的hash值低8位分别是 0110 1011 、1001 1011</span><br><span class="line">扩容前数组长度为16，扩容长度变为32</span><br><span class="line">扩容前他们都在数组角标11的位置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK1.7 e.hash &amp; (length-1)</span><br><span class="line">&#x2F;&#x2F; 第一个节点</span><br><span class="line">	0110 1011</span><br><span class="line">	0001 1111</span><br><span class="line">&amp; 0000 1011 角标11</span><br><span class="line">&#x2F;&#x2F; 第二个节点</span><br><span class="line">	1001 1011</span><br><span class="line">	0001 1111</span><br><span class="line">&amp; 0001 1011 角标27</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK1.8 (e.hash &amp; oldCap) &#x3D;&#x3D; 0</span><br><span class="line">&#x2F;&#x2F; 第一个节点</span><br><span class="line">	0110 1011</span><br><span class="line">	0001 0000</span><br><span class="line">&amp; 0000 0000 结果0，在原数组位置</span><br><span class="line">&#x2F;&#x2F; 第二个节点</span><br><span class="line">	1001 1011</span><br><span class="line">	0001 0000</span><br><span class="line">&amp; 0001 0000 结果1，在新数组位置</span><br></pre></td></tr></table></figure>

<p>JDK1.7中，直接通过hash值与新数组长度-1 按位与 得到新角标</p>
<p>JDK1.8中，通过计算hash值对应的原数组位置是否为0，如果为0则插入tab[j]，否则插入tab[j+oldCap]</p>
<hr>
<p>我模拟的Demo中没有设计这么多复杂的数据，所以简化为节点value值的奇偶判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">Node next;</span><br><span class="line">Node e = tab;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)e.value % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 进入次判断的节点为 0,2,4,6,8</span></span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)e.value % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>以取模结果等于0为例：</p>
<p>第一次进入，loHead = 0, loTail = 0。loTail和loHead指向相同的内存地址</p>
<p>第二次进入，loTail.next = 2会移动loHead.next指向 2。随后loTail = 2，即loHead.next和loTail指向相同的内存地址</p>
<p>第三次进入，loTail.next = 4也就是loHead.next.next指向4。随后loTail = 4，即loHead.next.next和loTail指向相同的内存地址</p>
<p>以此类推，如下图：</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/hashmap%20resize%20%281%29.jpg"></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面就是我对 <code>loTail.next = e; loTail = e;</code> 这两行代码的理解。</p>
<p>进一步思考，为什么HashMap在 JDK1.7 的时候会选择头插法插入元素？</p>
<p>不考虑JDK1.7中resize时的循环引用问题，我认为头插法无论是从理解的角度，还是从代码实现的角度都更胜一筹。甚至还可能能稍微优化一些查询的速率。</p>
<p>就拿上面Demo中的尾插生成测试链表为例，我的写法是仿照JDK1.8的，中间要声明很多局部变量，所以你会看到 JDK1.8 的源码中有很多判断中赋值的操作。如果不这么写的话，估计JDK1.8的源码会再多几百行（本身实现了一套红黑树，代码量相较1.7膨胀了几乎一倍）</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
        <tag>resize</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/12/hello-world/</url>
    <content><![CDATA[<p>Hello ~ Here is a personal blog <a href="http://www.yloopdaed.icu/">www.yloopdaed.icu</a>.<br>yloopdaed which is my network aka is the reverse spelling of deadpooly.<br>This blog is serve to my Github project - <a href="https://github.com/YorickYu/JPP">JPP</a>(Java promotion process).<br>you can also check out my jianshu channel - <a href="https://www.jianshu.com/u/9901b7042663">YYYYYY25</a> where stores many iOS articles i wrote before.</p>
<hr>
<p>建站的目的是为 <a href="https://github.com/YorickYu/JPP">JPP</a> 开源项目提供文章支持<br>本身自己也有记录和分享的习惯，之前的技术分享集中在简书<a href="https://www.jianshu.com/u/9901b7042663">YYYYYY25</a><br>技术类的分享可能会在本站和简书同步更新，之前的技术类文章分享会选择性的移至本站</p>
<p>✨ Love &amp; Peace ❤️</p>
]]></content>
  </entry>
  <entry>
    <title>悟到</title>
    <url>/2020/09/24/know-something/</url>
    <content><![CDATA[<p>I always need to anticipate problems instead of just reacting to them.</p>
]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的内存布局</title>
    <url>/2020/10/29/memory-layout-of-java-object/</url>
    <content><![CDATA[<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>对象的存储涉及内存的三部分：<strong>方法栈</strong>（存储指针）、<strong>方法区</strong>（存储类信息、常量、静态变量）、<strong>堆</strong>（存储对象的实例数据）。</p>
<p>对象在内存中存储的结构由三部分组成：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。</p>
<h3 id="Java对象在内存中存储布局"><a href="#Java对象在内存中存储布局" class="headerlink" title="Java对象在内存中存储布局"></a>Java对象在内存中存储布局</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg" alt="Java对象在内存中存储布局"></p>
<a id="more"></a>

<blockquote>
<p>注意：下文涉及到的占位大小都是基于64位操作系统</p>
</blockquote>
<h4 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h4><p>占用16个字节</p>
<p>前8个字节是markword，会包含锁信息、GC信息、hashCode</p>
<p>后面4个字节为class pinter，指针压缩，内存容量超过32G会存8位</p>
<p>数组对象的对象头占用24个字节，启用压缩之后占用16个字节。</p>
<h5 id="1-markword结构"><a href="#1-markword结构" class="headerlink" title="1 markword结构"></a>1 markword结构</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/markword.png" alt="存储内容"></p>
<h5 id="2-Klass-Pointer（类型指针）"><a href="#2-Klass-Pointer（类型指针）" class="headerlink" title="2 Klass Pointer（类型指针）"></a>2 Klass Pointer（类型指针）</h5><p>klass pointer存储的是该对象所属的类在方法区的地址，所以是一个指针，默认Jvm对指针进行了压缩，用4个字节存储，如果不压缩就是8个字节。</p>
<p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，这块占用4个字节。因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p>
<h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>实例数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。也就是说，除去静态变量和常量值放在方法区，非静态变量的值是随着对象存储在堆中的。<br>因为修改静态变量会反映到方法区中class的数据结构中，故而推测对象保存的是静态变量和常量的引用。</p>
<h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><p>用于确保对象的总长度为8字节的整数倍。<br>HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的。因此需要对齐补充字段确保整个对象的总长度为8的整数倍。</p>
<h4 id="JOL-java-object-layout-验证"><a href="#JOL-java-object-layout-验证" class="headerlink" title="JOL - java object layout 验证"></a>JOL - java object layout 验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/JolTest类中查看。</p>
<blockquote>
<p><a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a> 是一个Java技术分享的平台，欢迎大家加入</p>
</blockquote>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jol.png" alt="JOL"></p>
<hr>
<h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>
<thead>
<tr>
<th>类型名称</th>
<th>存储大小</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="引用数据类型（Object）"><a href="#引用数据类型（Object）" class="headerlink" title="引用数据类型（Object）"></a>引用数据类型（Object）</h3><p>在栈中存储一个引用（指针），指向堆中的对象本身。</p>
<blockquote>
<p>有看到一种说法：<br>一个普通的引用类型对象，会在内存中消耗24个字节，p指针占8个字节，Object对象占16个字节。</p>
</blockquote>
<p>我的理解是引用类型的指针存储在方法栈中，即klass pointer，指向方法区中的类信息，堆中存放的是对象的成员变量。</p>
<p>这里就引出很多问题，因为时间和能力的关系，没有来得及考证：<br>1 引用类型中声明的基本数据类型到底存放在哪里？<br>2 引用类型中的属性，它的指针是存在哪里？<br>这类问题很绕，就像iOS中的结构体是声明在栈中的，但是结构体中声明一个class类型的属性又是存在在堆中的。</p>
<p>所以，不过分纠结的话，只要了解一个引用类型的变量会在栈中存储一个指针，指向堆中的对象本身即可。以Object对象为例就是16字节。</p>
<p>此外，这里还有一个压缩指针的概念（+UseCompressedOops），目的是提高内存的利用率。将原本占位8字节的指针压缩成4字节。</p>
<h3 id="字段重排序"><a href="#字段重排序" class="headerlink" title="字段重排序"></a>字段重排序</h3><p>为了更高效的使用内存，实例数据字段将会重排序。排序的优先级为：<br>long = double &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrderTest&#123;</span><br><span class="line">    byte a;</span><br><span class="line">    int c;</span><br><span class="line">    boolean d;</span><br><span class="line">    long e;</span><br><span class="line">    People f;</span><br><span class="line">&#125;</span><br><span class="line">class People &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br>并不是完全符合，但是确实存在字段重排序</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ordertest.png" alt="order"></p>
<h2 id="对象存储在堆上还是栈上？"><a href="#对象存储在堆上还是栈上？" class="headerlink" title="对象存储在堆上还是栈上？"></a>对象存储在堆上还是栈上？</h2><p>看下面这段代码，循环创建一亿次Object对象，通常理解一个空Object对象创建会在栈中存在一个4字节的指针，指向堆中的对象16字节。<br>循环创建一亿次大概会占用1.6G的空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    new Object();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果：use time: 38ms</p>
</blockquote>
<p><strong><em>这是为什么？</em></strong></p>
<p>这里要提出一个概念<strong>指针逃逸</strong>，new Object() 新建的对象并没有在外部被使用，所以它被优化为在栈上分配，我们知道方法执行完成后该栈帧就会被清空，所以也就不会有GC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    Object o &#x3D; new Object();</span><br><span class="line">    o.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果：use time: 8014ms</p>
</blockquote>
<p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/NewObject类中查看。</p>
<p>结论: 虚拟机指针逃逸分析是默认开启的，对象不会逃逸的时候优先在栈上分配，否则在堆上分配。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JOL</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>IHAVEAQUESTION - JDK1.7 HashMap 链表头插疑问？</title>
    <url>/2020/10/31/question-of-hashmap-put/</url>
    <content><![CDATA[<h2 id="IHAVEAQUESTION"><a href="#IHAVEAQUESTION" class="headerlink" title="IHAVEAQUESTION"></a>IHAVEAQUESTION</h2><p>为什么JDK1.7中HashMap链表插入时要在 <strong>遍历完一遍链表</strong> 后，再采用头插法？</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>HashMap在JDK1.7中采用 数组+链表 的存储结构。</p>
<p>数组的角标是在key值hashCode()的基础上进行多次高位移动的扰动后尽量保持散列，代码片段如下：</p>
<p>1 hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h &#x3D; hashSeed;</span><br><span class="line">    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^&#x3D; k.hashCode();</span><br><span class="line">    &#x2F;&#x2F; 多次让高位参与运算，扰动函数</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 % -&gt; &amp;</p>
<p>采用更搞笑的 &amp;运算。这里length为数组的长度，源码中巧妙的设计数组的长度必须保持2的整数幂。这样设计才能保证length-1计算后得到 <strong>全1</strong> 的的二进制序列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组的index确认后，就可以将键值对插入相应位置的链表了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    ... </span><br><span class="line">    int hash &#x3D; hash(key); &#x2F;&#x2F; hash</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length); &#x2F;&#x2F; %</span><br><span class="line">    &#x2F;&#x2F; 判断hashmap中有没有存在相同的key，如果有的话将这个key原来的value覆盖，并返回</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 扩容，头插</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的源码部分只保留了关键部分</p>
</blockquote>
<p>我们都知道JDK1.7中链表的插入方式是头插。头插与尾插相比是节省了一次链表全遍历的时间。直接采用下面代码即可完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 链表头插</span><br><span class="line">table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, table[bucketIndex]);</span><br></pre></td></tr></table></figure>

<p>这部分代码在put方法的addEntry()中，addEntry()方法在链表头插之前做了扩容操作。</p>
<p>但是奇怪的是，在上面put方法中有一段循环遍历链表的代码，这段代码的目的只是检查要插入的Key值是否已经存在在HashMap中，如果存在就修改，同时将原来的值返回。</p>
<p><strong><em>这我就很疑惑了，为什么这里明明已经遍历过一遍链表了，为什么不多写一个else，如果没有找到存在的Key值，直接将目标键值对插入在链表尾部呢？都已经遍历完了，插个值咋了？</em></strong></p>
<p>可能的原因只能是扩容时机不好把握？</p>
<p>HashMap的扩容机制是键值对size超过阈值后，数组长度扩充至之前的两倍，然后将原本下标的全部链表迁移（这个迁移的过程会倒序链表，也可能分散链表中的数据，以缩短链表的长度）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 同一个元素转移后的下标有两种情况。</span><br><span class="line">            &#x2F;&#x2F; 1 与原来相同 2 在原来下标基础上加原数组长度</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这样遍历头插后，链表的顺序与之前相反</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解HashMap源码的朋友可能都知道，这个扩容和迁移的代码在高并发时并不是线程安全的。可能出现循环链表，以至于get时陷入死循环。</p>
<p>也许正因如此，需要将链表插入和扩容的代码从之前的循环中独立出来。并采用头插的方式，尽量再循环一次链表。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上都是我在阅读HashMap源码后产生疑问，独立思考，自我解答的过程。</p>
<p>可能是很少有人产生跟我相似的疑问，所以我在网上也没能查找到准确的资料和答案。</p>
<p>所以以上全是自己的推断和猜测。毕竟HashMap源码不论是在数据结构还是算法思想层面都是非常优雅的。别人这么设计肯定是有原因的。哈哈</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>0/1</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode reverse-words</title>
    <url>/2020/11/03/reverse-words/</url>
    <content><![CDATA[<p>LeeCode p151 逐个翻转字符串中的每个单词</p>
<p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ReverseWords类中查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 给定一个字符串，逐个翻转字符串中的每个单词。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 无空格字符构成一个 单词 。 </span><br><span class="line">&#x2F;&#x2F; 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 </span><br><span class="line">&#x2F;&#x2F; 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;the sky is blue&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;blue is sky the&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;  hello world!  &quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;world! hello&quot;</span><br><span class="line">&#x2F;&#x2F;解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;a good   example&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;example good a&quot;</span><br><span class="line">&#x2F;&#x2F;解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 4： </span><br><span class="line">&#x2F;&#x2F; 输入：s &#x3D; &quot;  Bob    Loves  Alice   &quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;Alice Loves Bob&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 5： </span><br><span class="line">&#x2F;&#x2F; 输入：s &#x3D; &quot;Alice does not even like bob&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;bob like even not does Alice&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; s.length &lt;&#x3D; 104 </span><br><span class="line">&#x2F;&#x2F; s 包含英文大小写字母、数字和空格 &#39; &#39; </span><br><span class="line">&#x2F;&#x2F; s 中 至少存在一个 单词 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 进阶：  </span><br><span class="line">&#x2F;&#x2F; 请尝试使用 O(1) 额外空间复杂度的原地解法。 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Related Topics 字符串 </span><br><span class="line">&#x2F;&#x2F; 👍 240 👎 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        String[] strings &#x3D; s.split(&quot;\\s+&quot;);</span><br><span class="line">        HashMap m &#x3D; new HashMap();</span><br><span class="line">        int modCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; strings.length; i++) &#123;</span><br><span class="line">            String innerstring &#x3D; strings[i];</span><br><span class="line">            if (!innerstring.equals(&quot;&quot;)) &#123;</span><br><span class="line">                m.put(modCount++, innerstring);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (;modCount&gt;0;) &#123;</span><br><span class="line">            sb.append(m.get(--modCount));</span><br><span class="line">            if (modCount !&#x3D; 0)</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解题思路就是用Java现有的API配合正则去拆分传入的字符串s，得到一个字符串数组</p>
<p>然后利用HashMap查找O(1)的特性，将value值按序存入key，并记录key值</p>
<p>最后倒序key值，取出value即可。</p>
<blockquote>
<p>这里其实一次for循环逆序遍历也可以得出答案，时间复杂度不会有太大差别，因为本身字符串数组长度不会很大。<br>我只是单纯的像仿照HashMap源码中modCount的想法记录一下编辑次数，所以for了两次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String reverseWords(String s) &#123;</span><br><span class="line">    String[] words &#x3D; s.trim().split(&quot;\\s+&quot;);</span><br><span class="line">    int len &#x3D; words.length;</span><br><span class="line">    StringBuilder ans &#x3D; new StringBuilder();</span><br><span class="line">    ans.append(words[len - 1]);</span><br><span class="line">    for (int i &#x3D; len - 2; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">        if (words[i].equals(&quot;&quot;))</span><br><span class="line">            continue;</span><br><span class="line">        ans.append(&quot; &quot; + words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，学了一下网上一些时间复杂度很低的解法，耗时的步骤都来源于数组的 <code>split</code> 方法。</p>
<p>想要突破的可以自定义一个数组拆分的方法。</p>
<p>还有，基本可以确定的是，使用 <code>StringBuilder</code> 的API拼接数组比直接使用 String 速度要快。</p>
<p>先后提交了2次，结果如下：</p>
<p>11 分钟前    通过    10 ms    38.9 MB    Java<br>20 分钟前    通过    12 ms    39.3 MB    Java</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeeCode sliding window algorithm</title>
    <url>/2020/10/12/slide-windows/</url>
    <content><![CDATA[<p>滑动窗口本质上来源于单调性，一般可以理解为，随着左端点位置的增加，其最优决策的右端点位置单调不减。</p>
<p>事实上是利用决策单调性来实现复杂度优化。</p>
<p>时间复杂度：O(n)</p>
<p>可以解决的问题有：求最小区间、区间最大值、最小子串等</p>
<a id="more"></a>

<blockquote>
<p>LeeCode 3 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a><br>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
</blockquote>
<p>滑动窗口之前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    char[] chars &#x3D; s.toCharArray();</span><br><span class="line">    List&lt;Map&gt; maps &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    AtomicInteger InnerMax &#x3D; new AtomicInteger();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">        Character target &#x3D; chars[i];</span><br><span class="line">        Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int innerI &#x3D; i;</span><br><span class="line">        maps.stream().filter(e -&gt; !e.containsKey(&quot;rep&quot;))</span><br><span class="line">                .forEach(e -&gt; &#123;</span><br><span class="line">                    if (e.containsKey(target)) &#123;</span><br><span class="line">                        int length &#x3D; e.size();</span><br><span class="line">                        InnerMax.set(length &gt; InnerMax.get() ? length : InnerMax.get());</span><br><span class="line">                        e.put(&quot;rep&quot;,&quot;-1&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        e.put(target, innerI);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        map.put(target, i);</span><br><span class="line">        maps.add(map);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; maps.size(); j++) &#123;</span><br><span class="line">            Map m &#x3D; maps.get(j);</span><br><span class="line">            if (m.containsKey(&quot;rep&quot;)) &#123;</span><br><span class="line">                maps.remove(j);</span><br><span class="line">                j--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(maps);</span><br><span class="line">    maps.stream().forEach(e-&gt; &#123;</span><br><span class="line">        int length &#x3D; e.size();</span><br><span class="line">        if (e.containsKey(&quot;rep&quot;)) &#123;</span><br><span class="line">            length &#x3D; length - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerMax.set(length &gt; InnerMax.get() ? length : InnerMax.get());</span><br><span class="line">    &#125;);</span><br><span class="line">    return InnerMax.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：398 ms 40.6 MB</p>
<p>优化版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    char[] chars &#x3D; s.toCharArray();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    Map&lt;Character, Integer&gt; store &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i&lt;chars.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (store.containsKey(chars[i])) &#123;</span><br><span class="line">            max &#x3D; length &gt; max ? length : max;</span><br><span class="line">            length &#x3D; 1;</span><br><span class="line">            i &#x3D; store.get(chars[i])+1;</span><br><span class="line">            store.clear();</span><br><span class="line">            store.put(chars[i],i);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            store.put(chars[i],i);</span><br><span class="line">            length +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return length &gt; max ? length : max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：95 ms    39.5 MB</p>
<p>滑动窗口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 记录字符上一次出现的位置</span><br><span class="line">    int[] last &#x3D; new int[128];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 128; i++) &#123;</span><br><span class="line">        last[i] &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line"></span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    int start &#x3D; 0; &#x2F;&#x2F; 窗口开始位置</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int index &#x3D; s.charAt(i);</span><br><span class="line">        start &#x3D; Math.max(start, last[index] + 1);</span><br><span class="line">        res   &#x3D; Math.max(res, i - start + 1);</span><br><span class="line">        last[index] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：2 ms    38.8 MB</p>
<hr>
<p>LeeCode滑动窗口其他题目:</p>
<ol start="30">
<li><p>串联所有单词的子串</p>
</li>
<li><p>最小覆盖子串</p>
</li>
<li><p>至多包含两个不同字符的最长子串</p>
</li>
<li><p>长度最小的子数组</p>
</li>
<li><p>滑动窗口最大值</p>
</li>
<li><p>字符串的排列</p>
</li>
<li><p>最小区间</p>
</li>
<li><p>最小窗口子序列</p>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>LeeCode</tag>
      </tags>
  </entry>
  <entry>
    <title>理财营-学习笔记</title>
    <url>/2020/10/07/money-management/</url>
    <content><![CDATA[<!-- ## 小白理财营学习笔记 -->

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国庆期间形成安排比较满，前半段安排了家庭短途自驾旅行，后半段要去外地参加朋友的婚礼。</p>
<p>没有太多大块的时间可以学习和整理，于是报名参加了一个基础的理财知识的训练营，利用晚上睡前的时间了解一下理财相关的知识、丰富一下自己的知识库。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>课程共12天，所以我也会按每天的内容进行更新。全部学习结束后争取写一写自己的收获和感悟。</p>
<a id="more"></a>

<hr>
<h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/1.jpg"></p>
<p>第1-3天，我们重点讲解投资理财的底层逻辑，建立好对于理财的正确认知</p>
<p>第4-12天，我会重点带着大家认识市面上常见的各类工具，例如：股票，REITs，指数基金、货币基金、国债逆回购，客观认识到各类工具的风险、作用以及收益情况，学会以后大家就不会被骗了，并且还能掌握几个无风险理财工具的操作</p>
<p>1️⃣聪明消费，摆脱月光，增加结余<br>2️⃣建立正确的金钱观、理财观，初步形成富人思维，投资不再被骗<br>3️⃣了解各种理财工具的风险和收益情况，并掌握几个无风险理财工具，形成理财的底层逻辑</p>
<p>学习理财不能帮助你一夜暴富，但是能够帮你梳理财务管理上的漏洞，弄清楚自己的财务状况，增加非工资收入，迈向更好的生活。</p>
<p>[衰]所以大家有没有发现：</p>
<p>三十年前，一人工作能养活全家。<br>三十年后，全家工作难养一个孩子。</p>
<h4 id="四条忠告"><a href="#四条忠告" class="headerlink" title="四条忠告"></a>四条忠告</h4><p>♥️欠债的人应当消除「坏支出」和「坏支出」产生的负债</p>
<p>♥️如果是能“帮你赚钱”的负债要尽可能的延长偿还时间。</p>
<p>♥️对于消费贷款，欠债的人应该将不用于生活的钱一半存起来，另一半用于还债。</p>
<p>♥️对于所有的消费，都要问自己【这真的有必要吗？】，尽可能的减少【不必要的】开支</p>
<h4 id="思维层次"><a href="#思维层次" class="headerlink" title="思维层次"></a>思维层次</h4><p>1⃣️第一层次：控制不住消费欲望，为了新出的包包、鞋就要花完自己所有的零花钱。</p>
<p>2⃣️第二层次：建立自己的储蓄罐，为了自己的梦想开始运用自己的优点来赚钱，但是没有自己的鹅。</p>
<p>3⃣️第三层次：开始养“鹅”</p>
<p>因为思维决定人的行为，行为成为人的习惯，最后反应在你的财务结果上</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/6.png"></p>
<p>还是那句，富人思维找办法，穷人思维找理由；富人思维在行动，穷人思维在观望；富人思维想着改变，穷人思维只会哀叹。</p>
<p>有句话分享给大家，我们常常高估一天内可以做到的事情，却低估了一年里可以做到的事情。🔔</p>
<p>放在理财上就是，我们常常对一天的收益率抱有过高的期望，却对三年、五年、十年甚至更长的时间里的收益率没有耐心等待。</p>
<p>【富人关键思维-第一条】</p>
<p>🔆获得经济独立、财务自由的意义是什么？</p>
<p>🌹经济独立、财富自由并不是独善其身，它的本质是让自己、家人变的更好的能力。</p>
<p>【从个人讲】，可以更好的选择自己喜欢的东西、自己喜欢的生活方式、婚姻方式，最终实现踏踏实实靠自己，得来属于自己的精神自由。把经济这个生存的“命脉”交给他人，其实就是把自己选择的权力让给了他人，也把自己生活的主动权让给了他人。</p>
<p>【从家庭讲】，与爱人共同分担家庭的财务重担，应对老人的医疗花销、孩子的教育花销，让家庭关系因为共同的努力获得财富而更美好，而不是因为钱受到冲击而动摇。</p>
<p>🌹一句话总结：提升理财技能，实现财务独立，获得更多自主选择的权力，获得给家人更好的生活的能力。</p>
<h2 id="正篇-1"><a href="#正篇-1" class="headerlink" title="正篇-1"></a>正篇-1</h2><h3 id="1-三大资产"><a href="#1-三大资产" class="headerlink" title="1 三大资产"></a>1 三大资产</h3><p>今天的课程分为 3 个部分：</p>
<p>1、什么是理财？必须有钱才能理财吗？</p>
<p>2、三大资产，到底什么东西能帮我们赚钱？哪些东西会让我们亏钱？</p>
<p>3、穷人和富人之间的差别是什么？</p>
<h4 id="♠️重点一：【理财】"><a href="#♠️重点一：【理财】" class="headerlink" title="♠️重点一：【理财】"></a>♠️重点一：【理财】</h4><p>投资≠理财，投资只是理财的一部分，理财是很广泛的概念。</p>
<p>理财包含：制定家庭日常消费计划、投资计划、保险计划、教育金计划、养老金计划等等</p>
<p>🌟重点，资产真正的内涵是【现金流】</p>
<h4 id="♠️重点二：【三大资产】"><a href="#♠️重点二：【三大资产】" class="headerlink" title="♠️重点二：【三大资产】"></a>♠️重点二：【三大资产】</h4><p>⭐️生钱资产</p>
<p>✅生钱资产：持有期间能给自己持续带来净现金流入的东西</p>
<p>常见的生钱资产有：股息、版税、利息，房屋租金等</p>
<p>⭐️耗钱资产</p>
<p>❌耗钱资产：持有期间能给你【持续】带来净现金流出的东西。</p>
<p>⭐️其他资产</p>
<p>⭕️其他资产：持有期间产生的净现金流为0的东西。</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/7.png"></p>
<p>例：房子根据情况的不同，可以分为三种不同的资产类型</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/8.jpg"></p>
<h4 id="♠️重点三：【穷人和富人的区别】"><a href="#♠️重点三：【穷人和富人的区别】" class="headerlink" title="♠️重点三：【穷人和富人的区别】"></a>♠️重点三：【穷人和富人的区别】</h4><p>【关键富人思维-第一条】</p>
<p>这里的差别从资产结构的角度切入</p>
<p>1 大部分人包括我自己都属于这个情况。主要的经济来源都是依靠工资，虽然随着工作的年限增长，工资也得到一定的提升。但是同样伴随家庭和个人开销的增加。所以感觉越来越穷，生活的压力也越来越大</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/9.png"></p>
<p>2 正确的资产结构应该如下，工资收入应该补充到适当的理财产品中，利用少量的工资和大量的理财收益维持生活的支出</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10.jpg"></p>
<p>【关键富人思维-第二条】</p>
<p>⭐月光或者积蓄不多的人，为什么不能等有钱再学习理财？</p>
<p>🌹月光和积蓄不多本质是错误理财思维造成的结果。</p>
<p>【在花钱上】，很多都是坏支出，一心只想买买买，很多东西在冲动消费之后要么用了几次就放置一边，要么后悔自责又在下次陷入到恶性循环，但对于投资自己成长的好支出，却又思前想后。其关键在于，没有好支出、坏支出的思维意识，被欲望牵着走，没有将有限的资金花在刀刃上。</p>
<p>【在攒钱上】，单纯靠工资攒钱是最低效最差的方式，如果只靠工资收入来攒钱，很可能到退休了还没有攒够理财的本金。真正聪明的小伙伴会在获得第一笔工资收入时就开始选择合适的理财工具来积累自己的本金和非工资收入了。</p>
<p>具有富人思维的人，哪怕是现在月光或者积蓄不多，就会从一开始就通过工资和非工资收入两条路径来增加自己的收入。两条腿走路肯定比只靠工资收入一条腿走的更快更远。</p>
<p>🌹一句话总结：提升财富要靠工资和非工资收入【两条腿】走路，绝对不能独腿前行。</p>
<p>【关键富人思维-第三条】</p>
<p>🌹普通或中产家庭为什么不能沉溺在自己的工资收入中，不重视理财？</p>
<p>因为不安全，看似收入比较稳定，其实抗风险能力很低，因为有房贷车贷要还，小孩要养，大量的耗钱资产占主要，甚至父母的医疗还要大量的开销。</p>
<p>【孩子还未成人的家庭】<br>孩子没有收入，花销逐年增大，这时候如果夫妻中有一人遇到一段时间不能工作的情况，家庭财务整体情况可能会出现较大落差，进而影响生活质量得不到保障。</p>
<p>【全职宝妈的家庭】<br>女性负责照顾孩子，没有工资性收入，只有丈夫一人的收入是家庭收入的主要来源，如果丈夫遭遇大裁员等意外情况，家庭很可能立即陷入坐吃山空的财务危机中，或者啃老的尴尬境地。</p>
<p>所以普通家庭更需要尽早尽快建立自己的【非工资收入体系】，【在没有意外发生的时候】可以为家庭提供一份额外的收入，补贴家用；【在意外发生的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。</p>
<p>🌹学习并掌握获得非工资收入的能力，是为自己负责，也是为了家人生活安全负责。</p>
<p> 总结：普通人的【财务安全】来自工资收入和非工资收入的双管齐下，没有充沛的非工资收入的中产家庭，谈不上财务安全健康。</p>
<h3 id="2-复利"><a href="#2-复利" class="headerlink" title="2 复利"></a>2 复利</h3><p>今晚的课程主要讲三个重点，两个富人关键思维：</p>
<p>1、复利是什么？</p>
<p>2、复利的反向作用</p>
<p>3、复利的头号敌人</p>
<h4 id="♠️重点一：什么是复利？"><a href="#♠️重点一：什么是复利？" class="headerlink" title="♠️重点一：什么是复利？"></a>♠️重点一：什么是复利？</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/11.png"></p>
<p>复利本质上是一种让钱高效生钱的思维方式。<br>影响复利的因素是：本金 时间 收益率</p>
<p>⭐第一个重点要素：本金。本金越多，最终收益越大。<br>⭐第二个重点要素：时间<br>⭐复利的第三个重要因素：【收益率】，影响非常大！非常大！</p>
<h4 id="♠️重点二：复利的反响作用—通货膨胀"><a href="#♠️重点二：复利的反响作用—通货膨胀" class="headerlink" title="♠️重点二：复利的反响作用—通货膨胀"></a>♠️重点二：复利的反响作用—通货膨胀</h4><p>你的收益率低于10%,你的钱就在贬值，钱会越来越不值钱。</p>
<h4 id="♠️重点三：复利的头号敌人—亏损"><a href="#♠️重点三：复利的头号敌人—亏损" class="headerlink" title="♠️重点三：复利的头号敌人—亏损"></a>♠️重点三：复利的头号敌人—亏损</h4><p>一定要记住：</p>
<p>1、不懂的东西不要碰<br>2、只操作在国家交易所交易的工具</p>
<p>【关键富人思维-第四条】</p>
<p>⭐为什么说复利三要素中最容易掌控的是收益率？</p>
<p>🌹复利三要素，本金、时间、收益率。把钱存在保险箱中，复利会发挥反向作用，把钱一口一口吃掉，长期来看1万元每年贬值500元以上。投资开始的越早，时间要素发挥越大，复利的正向作用越早发挥作用。本金大的人，复利作用也比较大，但是投错了地方，本金再大也会亏完。如果本金和时间都不占优势，那么最有效的就是提高年化收益率，而提高年化收益率的关键在于自己的理财能力。</p>
<p>🌹一句话总结：【时间无法改变，越早开始越好；本金依赖生钱资产；收益率源于理财能力，理财能力才是决定复利终值的关键】</p>
<p>【富人关键思维–第五条】</p>
<p>⭐为什么说投资自己的大脑、学会理财技能也是中产升级之法？</p>
<p>🌹如同经典书籍《富爸爸》中说的，穷人卖时间换钱，其实本质是“卖命”。他们抱怨自己没有钱，其实本质是他们没有认识到投资自己的大脑是最快的脱贫致富之法。</p>
<p>比如一个专家花费一生写了一部巨著，我们花100元买了他的书回来看，其实某种意义上我们是买到了他一生的生命成果，学到了能获得成千上万的收益，这就叫“站在巨人的肩膀上”，贫穷的矮人站在“巨人的肩膀上”也会达到巨人的视野。</p>
<p>但很多人心疼这点投资大脑的钱，所以一直什么都不懂，一直贫穷下去。反之，穷人也能通过投资自己的头脑，学习他人成功的方法，买他人花了很多时间转化的成果，变成自己的东西，快速创造财富，这是最快的脱贫之法。</p>
<p>🌹一句话总结：心疼投资大脑的钱，一直什么都不懂，不是被通货膨胀割韭菜，就是被投资市场割韭菜，一直穷下去。反之学习他人成功的方法，变成自己的技能，是最快的脱贫、升级之法。</p>
<h3 id="3-理财工具"><a href="#3-理财工具" class="headerlink" title="3 理财工具"></a>3 理财工具</h3><p>今天讲的21种理财工具，我们不用样样精通，但是要抓住重点：</p>
<p>1、哪些工具好？</p>
<p>2、哪些工具不能碰？</p>
<p>3、哪些工具是我们财务自由的核心工具？</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/12.png"></p>
<h4 id="⭕无风险的理财工具"><a href="#⭕无风险的理财工具" class="headerlink" title="⭕无风险的理财工具"></a>⭕无风险的理财工具</h4><p>国债，定期存款，国债逆回购，货币基金，银行理财（保本型）</p>
<p>我们了解两个就行，【国债逆回购】和【货币基金】</p>
<p>国债：“国债，又称国家公债，是国家以其信用为基础，按照债券的一般原则，通过向社会筹集资金所形成的债权债务关系。国债是由国家发行的债券，是中央政府为筹集财政资金而发行的一种政府债券，由于国债的发行主体是国家，所以它具有最高的信用度，被公认为是最安全的投资工具。”</p>
<p>【国债逆回购】： 本质就是一种短期贷款。也就是说，个人通过 国债回购市场 把自己的资金借出去，获得固定的 利息收益 ；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p>
<p>【货币基金】也称“火鸡”。货币基金家族有个家伙是很出名的，它叫“余额宝”。其他货币基金也和余额宝差不多</p>
<p>🧧分享个【捡钱小秘密】给大家</p>
<p>捡钱小秘密由【国债逆回购】和【货币基金】组成。</p>
<p>我们平时把零钱买货币基金，每年可以获得3%左右的无风险收益。当国债逆回购收益高时，比如大于10%以上，卖掉货币基金直接买入国债逆回购。这样就可以获得几天的高收益。等国债逆回购的钱回来后，再当天买进货币基金。</p>
<p>👉【场内基金】就是在证券市场内，也就是二级市场买卖基金，需要自己去开立股票账户进行购买的。比如可以在场内买ETF基金、LOF基金、封闭式基金等。场内基金咱们后面重点会学习【指数基金】，有筛选方法和购买标准，收益率在12%以上，风险较低。</p>
<p>👉【场外基金】则是在证券市场外买卖基金，比如银行、基金公司、第三方平台(如天天基金网、支付宝、微信等)，不需要开股票账户就可以购买。场外基金咱们不会学，因为风险较大，收益也不是很高，小白不懂乱买很容易亏钱。</p>
<h4 id="⭕低风险的理财工具"><a href="#⭕低风险的理财工具" class="headerlink" title="⭕低风险的理财工具"></a>⭕低风险的理财工具</h4><p>⭐它又分为两类👇<br>一种是【低风险中等收益】，年化收益率一般6%—15%之间，主要包括【分级基金A】、【可转债】、【债券基金】、【股票指数基金】<br>另一种是【低风险高收益】，年化收益率一般在15%—30%之间，主要包括生钱资产类型的【股票】、【REITs】</p>
<p>决定【投资风险和收益大小的】不是【理财工具】本身，而是投资人的【理财技能】</p>
<p>🎈股票<br>对于每年【有持续分红】的股票而言，就是【生钱资产】</p>
<p>买了【不分红的股票】，只能靠预测未来的价格上涨，这是不确定性的，就是【其他资产】</p>
<p>🎈 REITS，读作 “瑞子”就行<br>这个是重点，REITs是全球配置房产的理财工具</p>
<p>【生钱资产类型的REITs】就是持续高分红的REITs。其实一般的REITs都是持续高分红的。因为各国法律都规定REITs每年至少要把90%以上的净利润分配给投资者。</p>
<p>🎈 【股票指数基金】复制股票指数的股票基金。由于股票指数具有永生不死，长期上涨的特点。在合适的价位买入股票指数基金长期持有几乎没有风险。其年化收益率一般在10%—15%。🌹</p>
<h4 id="⭐中风险的理财工具"><a href="#⭐中风险的理财工具" class="headerlink" title="⭐中风险的理财工具"></a>⭐中风险的理财工具</h4><p>黄金、不保本的银行理财等</p>
<h4 id="⭐高风险的理财工具"><a href="#⭐高风险的理财工具" class="headerlink" title="⭐高风险的理财工具"></a>⭐高风险的理财工具</h4><p>p2p、私募基金、比特币收藏品、期货等</p>
<p>实现财务自由的三大核心工具:</p>
<p>只有当企业、股票、REITs具有生钱资产的属性的时候，才能算成我们的财务自由核心工具</p>
<p>💰这三大核心工具，只要用好了其中的一个就能【脱贫致富】</p>
<p>【购买生钱资产】，主要就是购买生钱资产类型的股票和REITS</p>
<p>代表人物比如巴菲特 罗杰斯</p>
<p>【创造生钱资产】 ，就是创造企业</p>
<p>比如马云、马化腾</p>
<p>而我们普通人，大部分都可以通过购买生钱资产致富</p>
<p>♥️用好了企业这个核心工具，你会成为企业家</p>
<p>♥️用好了股票或REITs这两个核心工具，你会成为投资家；</p>
<p>♥️用好了企业、股票、房地产这三个工具，你会成为资本家</p>
<p>今天的课程共三个重点：</p>
<p>【重点一】：短期零钱管理，关注国债逆回购、货币基金。</p>
<p>【重点二】：低风险投资工具，重点关注生钱资产类型的股票、REITs</p>
<p>【重点三】：实现财务自由的三大核心工具——股票、REITs、企业</p>
<p>【关键富人思维—第六条】</p>
<p>🌟到底什么时候可以开始投资？</p>
<p>为什么有的人买股票会亏钱，因为只看了几本书，学了几天课就急急忙忙去股市。我们学车考个驾照还要一个月，而理财投资作为一个高度专业化、精细化的领域，不经过系统的学习就去“尝试”，这和训练了两天、看了几本武侠小说就上战场的士兵有什么区别？</p>
<p>士兵进行系统训练是为了保命，投资者进行系统的理财方法学习是为了保钱的“命”。反之，学半瓶水，一知半解就去投资市场“试试”，只会学到教训和被割韭菜，收获痛苦。那些经过系统投资训练的人会把那些无知而自以为是的人收割的一滴血不剩。在股市里，你赚的钱是别人亏得，你亏的也被别人赚走了。</p>
<p>⭕【投资的真相】，不系统学习理财技能就想赚快钱，本质是送钱的命，当你打算投资一个目标，要有系统的分析方法，不再为了涨跌而心惊胆战的时候，这才是投资可以真正开始的时候。</p>
<p>一句话总结：投资第一原则，不懂不要投，懂了安心投，盲目“尝试”无疑送命，系统训练方可真正保住钱“命”</p>
<p>🎁正确系统的投资技能包括：</p>
<ul>
<li>①理财的底层逻辑、富人思维</li>
<li>②股票的海选</li>
<li>③精选出好公司</li>
<li>④财务报表分析</li>
<li>⑤企业分析</li>
<li>⑥计算好价格</li>
<li>⑦制定买进标准</li>
<li>⑧制定持有标准</li>
<li>⑨制定卖出标准等</li>
</ul>
<h3 id="4-分析财报"><a href="#4-分析财报" class="headerlink" title="4 分析财报"></a>4 分析财报</h3><p>🎤那大家猜猜，在理财中学习【财务报表】最重要的作用是什么呢？</p>
<p>💎答：最重要的作用是排雷，是证伪，而不是证实。</p>
<p>一、财务报表到底是什么？有什么用？</p>
<p>可茫茫股市几千只，光每年分红的股票就有2000多家，怎么精准的判断是不是含金量最高的【股票】呢？</p>
<p>判断标准之一就是要能读懂【财务报表】<br>后面懂了股票的筛选方法，【REITs】工具得筛选方法同理</p>
<p>💎学习【财务报表】，老师这里给大家几个学习提示：</p>
<p>1、从今晚开始课程中有看不懂的是正常现象，小白营的时间有限，大家先掌握思路，就是知道选好公司，好股票，是凭借什么依据什么方向去判断的就可以了<br>具体财报怎么看，是有23个步骤的，在完整的《财富自由实践课》中有详细讲解和实操带领</p>
<p>2、不要局限在财报的数字和计算中，这并不是重点，财报的关键是看【结构】，看数字谁都会晕，不纠结数字。</p>
<p>3、思考造成文中，不同家庭财务状况的原因是什么？三类资产和好/坏支出，都是怎么在他们的家庭中起到作用的？</p>
<p>4、试着写出自己家庭的财报是什么样，三类资产和好/坏支出，负债率等，各是怎样的情况？占比多少？并应该怎样去调整？列在纸上写一写，生活方向就清晰很多了</p>
<p>⭐应付：【先用货，后给钱】</p>
<p>⭐预收：【先收钱，后发货】</p>
<p>🎤那么，应付+预收是不是能证明我企业很有实力，而且，我现金流很大。</p>
<p>⭐应收：【先发货，收不到钱】</p>
<p>⭐预付：【先给钱，收不到货】</p>
<p>【应付+预收】我们占用别人的钱</p>
<p>【应收+预付】别人占用我们的钱</p>
<p>通过：一家公司负债项中【应付预收】减去资产项中的【应收预付】来判断公司的竞争力强弱。</p>
<p>相减得出金额越大，说明公司的竞争力越强。</p>
<p>相减得出金额越小，说明公司的竞争力越弱。</p>
<p>那通过什么来判断公司的【安全性】呢？</p>
<p>我们可以用【资产负债率】来判断公司的偿债风险</p>
<p>总负债÷总资产*100%=资产负债率。</p>
<p>👉资产负债率【大于70%】的公司，偿债风险比较大</p>
<p>👉资产负债率【小于40%】的公司，几乎没有偿债风险</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/13.png"></p>
<p>【关键富人思维—第七条】</p>
<p>为什么月光、负债的人应该拿出一部分资金学习理财技能？</p>
<p>这里的负债主要指的是让自己的财务状况不断恶化的【坏负债】。</p>
<p>⭐️月光和负债只是不懂理财的结果，没有理财技能才是月光和负债的原因。很多人一方面不懂投资的骗局，一方面又眼红想赚一下，最终都入了骗局的“坑”，如果提前投资自己的大脑，难道还会犯这样的错误吗？还有很多人，本来钱就不多，贷款买了一堆耗钱资产，要么不断的刷信用卡、花呗、借呗，窟窿越来越大，要么生活拮据，每天人前风光，人后遭殃。</p>
<p>但对于投资自己，提升理财技能的好负债，他们却斤斤计较，错失了复利的好机会，这样的人生活只会越来越难过。</p>
<p>【成长有顺序，生活致富也有顺序】——先投资大脑，掌握理财的技能，然后再去生钱，月光、负债不学习只会越来越穷</p>
<p>🌹一句话总结：月光、负债是财务病，病根是缺少理财技能，忽视病因、不治病根，坏支出、坏负债只会越来越严重。</p>
<p>月光负债只是结果，不会理财是病因</p>
<p>投资的准则是【不懂不要投，懂了放心投】</p>
<p>投资的核心是【生钱资产】</p>
<p>投资的实质是投资【好公司/好项目】</p>
<p>🌟【正确理财步骤】</p>
<p>🎈第一步：学习富人思维，增值自己，先投资自己掌握理财技能。</p>
<p>🎈第二步：有了理财技能，自然就具备精准识别优质生钱资产的能力（选出好股票、好REITs）。</p>
<p>🎈第三步：每月收入先拿出一部分去投资，购买生钱资产，长期持有积累，利用复利发挥威力获得收益。</p>
<hr>
<p>❤️越是没钱的时候越要理财，越要重视投资自己。</p>
<p>❤️因为投资大脑掌握理财技能是回报最高、变现最快的投资。</p>
<p>❤️一定要学会让钱为自己工作，支配钱，驾驭钱</p>
<p>❤️内在拥有，外在呈现；内在没有发生改变，人是永远无法赚到自己认知以外的钱的</p>
<h3 id="5-反常识股票"><a href="#5-反常识股票" class="headerlink" title="5 反常识股票"></a>5 反常识股票</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/20.jpg"></p>
<h4 id="⭕️重点1：股票的定义"><a href="#⭕️重点1：股票的定义" class="headerlink" title="⭕️重点1：股票的定义"></a>⭕️重点1：股票的定义</h4><p>🎤股票到底是什么？</p>
<p>其实【股票】是公司的所有权凭证。</p>
<p>🎤人们一开始购买股票是希望能够赚到股票的什么钱？</p>
<p>是分红</p>
<p>🎤企业为什么要发行股票呢？</p>
<p>企业发行股票很大一部分是为了融资。</p>
<p>【重点】企业发行股票的主要目的就是为了融资，出让股份，让大家投钱，你用大家的钱，去干更大的事，赚到了钱，一起分。</p>
<p>🎤那股市是什么意思？</p>
<p>股市的存在让买卖股票变得非常的方便</p>
<p>中国A股市场有两大交易所，分别是上交所和深交所，相当于两个“菜市场”</p>
<p>A股交易时间是：</p>
<p>每周一到周五：早上9点30 - 11点30；下午1点 - 3点；节假日休市</p>
<p>🎤那我们投资【好公司】的股票赚的是什么钱呢？</p>
<p>①【公司持续的现金分红】<br>②【股票价格上涨带来的价差收益】</p>
<p>🎤为什么股票的收益率那么高呢？</p>
<p>因为股票的背后是公司，公司是一个国家创造经济的主体，因此一国的【股市平均收益率】一定是远远大于该国【GDP增长率】的。</p>
<p>👉中国的GDP增长率在6.5%左右；</p>
<p>中国股市的年化收益率一定是大于6.5%的。</p>
<p>为什么会这样呢？因为GDP的组成中，企业是创造价值最多的部门，而股票背后的实质就是企业</p>
<p>好上市公司的平均收益率&gt;所有上市公司的平均收益率&gt;所有公司的平均收益率&gt;GDP增长率&gt;银行存款收益率</p>
<p>据统计：</p>
<p>👉中国的GDP增长率在6.5%左右；</p>
<p>👉中国所有上市公司的平均年化收益率大于12%以上；</p>
<p>👉中国【好】上市公司的平均年化收益率大于24%以上。</p>
<p>买了好公司的股票，就相当于中国甚至世界最优秀的管理团队为自己打工。</p>
<h4 id="⭕️重点2：什么样的股票算是好股票？"><a href="#⭕️重点2：什么样的股票算是好股票？" class="headerlink" title="⭕️重点2：什么样的股票算是好股票？"></a>⭕️重点2：什么样的股票算是好股票？</h4><p>股票的本质是企业，好企业的股票就是好股票。股价下跌是市场的正常现象，只要公司利润在增长，这个公司就是有好公司的潜质。</p>
<blockquote>
<p>小科普：不复权价格是「真实的价格」，后复权则显示的它的「真实价值」，即分红送股转股都加进去。<br>例如你的公司市值（市场价）3元，你要给股民分红，分1元，你不能自己掏腰包垫吧。所以就要从公司市值减1元，你的公司现在就是2元（前复权），其实你的公司值3元（后复权）。</p>
</blockquote>
<p>认为买股票有很大风险的同学，想想是不是以前用错了方法？同时也直观的，让大家理解到，好公司长期持有的价值回报是很大的</p>
<p>所以，在正确投资股票中，建议同学们不要经常看股票行情波动，这对工作、生活、财务自由以及投资没有任何好处，实在忍不住想看看股票价格的走势，那就每年看一两次就够了。</p>
<blockquote>
<p>重点强调：正确理财的人，是根本不用花时间关注股价波动的</p>
</blockquote>
<p>⭕为什么说好公司股价暴跌反而是赚钱的机会</p>
<p>只要公司真实利润在增长，股价下跌你反而会更赚。</p>
<p>股价波动不是风险，不要怕，真正的风险是公司的真实利润在减少。</p>
<p>股价越跌，它的股价变的更低，你可以拿着【分红的钱】再以低价买入更多股票。</p>
<p>这时候你得到的股票数量就越多，分红是按照你【持股数量】分的。</p>
<p>股票越多，分红就越多。</p>
<p>分红越多，股票就越多。</p>
<p>一并回答4个问题：</p>
<ul>
<li>1、企业为什么发行股票？</li>
<li>2、股票、股份是什么？</li>
<li>3、不懂理财的人，是怎么炒股的呢？</li>
<li>4、正确投资股票的姿势是什么？</li>
</ul>
<p>👉1、企业为什么发行股票？</p>
<p>假设你开了家超市，一共投入10万，超市经营得很好，每年可赚2万，回报率20%。你们掐指一算，按照20%的回报率，如果投入1000万来扩大店面或开连锁，那每年就可以赚200万！</p>
<p>于是你们想方设法找钱，但终究资源有限，可用于抵押的资产又不多，所以你们从亲戚朋友、银行一共也只借到到了90万，因此最多每年也只能赚20万。那怎么办？还能去哪里去找钱呢？</p>
<p>这时候你想，既然我能把超市收益经营得这么好，如果在网上发个帖子，告知所有人我的项目，投10万即可赚2万，那肯定很多人都来投资！</p>
<p>有钱大家一起赚，而你在使用【借力思维】赚钱，这个模式其实就是发行股票，企业发行股票的主要目的就是为了融资！只不过企业的规模大，融资大，这么说大家是不是就更容易明白了</p>
<p>👉2、股票、股份是什么？</p>
<p>说白话就是，股票是一个凭证，证明你拥有某一家公司的股份，即股票是股份的凭证。股票的本质是企业。那股份是什么呢？股份就是你对某家公司拥有的所有权。</p>
<p>👉3、不懂理财的人，是怎么炒股的呢？</p>
<p>是关注股价的浮动趋势、大盘、K线去预测市场。这种基本都是被割韭菜。</p>
<p>举例说明：好比 你低价买了一家企业的股票，然后涨了一点就卖了，你赚了。然后我高价买了这家公司股票，也不了解企业实质，光看价格，没等到涨，我就心急卖了，我就赔了。</p>
<p>这种交易方式完全不看股票背后的公司，只是在预测股价的涨跌，但是没有任何一个人能准确预测市场，像这样赚差价的行为本质是在赌博，长期操作下去，不仅会损失惨重，还很有可能难以承受股价的波动导致，最后精神崩溃。</p>
<p>这就叫投机，本质是在赌涨跌。</p>
<p>股票的选择就是这2点</p>
<p>你只需要用正确的方法，找到最优质的好公司，以【合理的价格】买入和卖出就可以了</p>
<p>在正确的投资中，根本没有所谓的“长线”“短线”这一说，这都是不懂正确投资人的思维词汇概念。</p>
<p>正确投资是需要给企业估值的，是跟随企业的价值增长而增值，就不会被短期股价波动吸引注意力了</p>
<p>⭕正确投资一定是买最优质的好公司，赚钱就是【必然的事情】。</p>
<p>👉4、正确投资股票的姿势是什么？</p>
<p>是靠企业的发展带来内在价值的提升，表现形式为净利润的不断提升（分红是利润的一部分），这是正确的投资方式。</p>
<p>不懂理财的人只看表面，不分析企业实质。</p>
<p>包括一些只分析，实时新闻政策，去判断行业选股的，都属于不看实质，在投机</p>
<p>接着昨天很多人说哈，很多人一直听消息，今天国家发一个政策，明天国家发一个政策，天天看这些政策，弄到最后把自己形成一个错误的认知，就是中国是一个政策的股票。</p>
<p>其实完全不是这样的，因为这个政策到底对这家公司有没有作用，最简单的，你去看这家公司的财务报表就可以了，如果这家公司的这个受到了这个政策的影响，利润上涨，财报会反映出来的，如果说这家公司经营的内部是没有任何的变化，你又何必去关心这个政策呢？<br>第三个重点：选出好公司，要有一套科学的分析体系（财报分析、企业分析）</p>
<h4 id="⭕️重点3：如何才能分析出好公司呢"><a href="#⭕️重点3：如何才能分析出好公司呢" class="headerlink" title="⭕️重点3：如何才能分析出好公司呢"></a>⭕️重点3：如何才能分析出好公司呢</h4><p>【财报分析】可以看出一个公司的过去和现在。</p>
<p>【企业分析】可以看出一个公司的现在和未来。</p>
<p>我们【投资股票正确的方法】可以分为两大步：</p>
<p>第一步：选出内在价值高的好企业</p>
<p>第二步：在合理的价格把握时机，及时买入</p>
<p>【关键富人思维-第八条】</p>
<p>⭐股票价格大跌能跌出什么？<br>🌹我们【投资股票正确的方法】可以分为两大步：<br>第一步：选出内在价值高的好企业<br>第二步：在好的价格及时买入</p>
<p>这两步是不能颠倒的。<br>【当股市的价格出现下跌时】，好企业代表的好股票会出现好的买入价格，但是坏企业会跌出让投机者眼红的“陷阱”。如果在选择企业这一步错了，不管是多便宜的价格都徒劳无功，反而损失惨重。</p>
<p>【理性的投资者】对自己无法预测股票价格有自知之明，因为价格的波动总是难以预测的，因此他们将主要精力放在好企业的选择上，当好价格出现的时候果断出手，而后不管是继续跌还是涨，都是任凭风浪起稳坐钓鱼船。他们一般很少看股票，却获得了很高的收益。</p>
<p>💎一句话总结：👇<br>股票大跌既有机会也有陷阱，机会的识别需要眼力，机会的把握需要技能，当眼力和技能配不上这个机会的时候，往往会步入陷阱之中。</p>
<p>【关键富人思维—第九条】</p>
<p>⭐很多人炒股都亏，就说股票风险高，到底该怎么看待投资股票这件事？</p>
<p>🌹【投机炒股的人】，不懂就去投，一心想赚一把就走，那么股市就是一个大赌场，都特别想赢钱，但又特别怕输钱，风险自然是非常大</p>
<p>而且还很容易上当受骗，赚了以为是自己本事，亏了又说运气不好，说到底都是自欺欺人。</p>
<p>涨了开心要命，跌了悲伤绝望，被价格的波动带着一天悲喜两重天，说到底还是没有技能让自己内心踏实💡</p>
<p>🌹【真正的投资股票】，是关注股票代表的公司的好坏，是看到股票背后的本质，经过严谨的分析得出的结论。</p>
<p>这样的投资，即使短时间的价格波动也能心理踏实，最终能够获得复利带来的长期收益💰</p>
<p>💎一句话总结：👇<br>投资股票的正确姿势是靠分析，能选出好股票风险自然就小。赌徒在股市是把身家性命交给市场，不懂就投，肯定要被懂的人收割的。</p>
<h3 id="6-企业分析"><a href="#6-企业分析" class="headerlink" title="6 企业分析"></a>6 企业分析</h3><p>企业分析就是从一家公司的使命、愿景、核心价值观、领导团队等方面判断一家公司的未来走势</p>
<p>再说一下为什么要学【企业分析】？ </p>
<p>买股票就是买公司，投资要学企业；</p>
<p>打工族如果学了企业更有助于升职加薪，上班要学企业；</p>
<p>创业者学了企业能大幅提高成功概率，创业也要学企业。</p>
<h4 id="⭕️重点1：E-B-S-I，四类人群与企业的关系"><a href="#⭕️重点1：E-B-S-I，四类人群与企业的关系" class="headerlink" title="⭕️重点1：E\B\S\I，四类人群与企业的关系"></a>⭕️重点1：E\B\S\I，四类人群与企业的关系</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/21.png"></p>
<p>无论你是打工者、企业家还是投资者。你会发现，你越了解企业，你就越富有</p>
<h4 id="⭕️重点2：企业与个人职业发展、创业"><a href="#⭕️重点2：企业与个人职业发展、创业" class="headerlink" title="⭕️重点2：企业与个人职业发展、创业"></a>⭕️重点2：企业与个人职业发展、创业</h4><p>企业与个人的发展息息相关，企业愿意为员工付出、重视员工，会增加员工的归属感和责任心。在良性的企业文化中学习和成长出来的员工，也会全心全意为企业着想，推动企业的发展。循环共赢</p>
<p>创业也是一样，创业不仅要有好的项目支撑，更重要的为自己的企业树立良好的企业文化和核心价值观。吸引更多志同道合的人一起奋斗。</p>
<h4 id="⭕️重点3：企业分析工具——强大企业模型"><a href="#⭕️重点3：企业分析工具——强大企业模型" class="headerlink" title="⭕️重点3：企业分析工具——强大企业模型"></a>⭕️重点3：企业分析工具——强大企业模型</h4><p>企业分析利器——强大企业模型，学习的时候也要注意两点：</p>
<p>👉2、思考一下：为什么懂企业对工作、创业、投资有一箭三雕的作用？</p>
<p>🌟强大企业模型，包括9个关键要素。</p>
<p>领导者、企业文化、治理结构、商业模式、团队、沟通、现金流、系统、法规</p>
<p>【领导者】是最核心的要素。其他8个关键要素都和领导者有着直接的关系</p>
<p>强大企业模型可以让普通员工像CEO一样去思考企业的问题。</p>
<p>强大企业模型不但可以知道我们经营好自己的企业，还可以让我们看明白别人的企业。</p>
<p>分析清楚一家企业对我们有什么用呢？</p>
<p>1、跳槽的时候能选出更有潜力的好公司，职业发展上获得超额回报。</p>
<p>2、做投资的时候能选出好公司，给企业估值，获得年化20%-30%以上的收益率。</p>
<p>【关键富人思维第十条】</p>
<p>🌹为什么工作者、投资者都需要通晓企业分析技能？</p>
<p>⭐并不是创业者 、大老板才需要了解企业。</p>
<p>【投资中】，股票本质是企业，只有把9大要素都分析清楚，才能分析出好企业，才能给企业估值.</p>
<p>【工作中】，干工作的时候要有企业经营的思维，这样才更容易升职加薪。</p>
<p>即便不为升职，干工作的时候也要有企业经营的思维。因为当你站在更高层去看自己的工作内容的时候你才能更好的理解自己的工作内容，这样你可以把工作做成老板真正想要的样子。</p>
<p>而那些只盯着自己的岗位的“井底之蛙”，有的时候挨了骂都不知道为什么，因为他缺乏跳出自己的框框看企业的技能，这就是他自己工作干不好的原因。</p>
<p>所以无论投资、工作，都需要通晓企业分析技能。</p>
<p>💎总结一句话：工作者用企业分析模型看透工作，投资者用企业分析模型看透股票💡</p>
<hr>
<h2 id="半程总结"><a href="#半程总结" class="headerlink" title="半程总结"></a>半程总结</h2><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/14.png"></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/15.png"></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/16.jpg"></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/17.png"></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/18.png"></p>
<h2 id="正篇-2"><a href="#正篇-2" class="headerlink" title="正篇-2"></a>正篇-2</h2><h3 id="7-REITs"><a href="#7-REITs" class="headerlink" title="7 REITs"></a>7 REITs</h3><p>REITs：Real Estate Investment Trusts 房地产投资信托基金，REITs是一种依照法律程序成立的，以发行股票或基金单位的方式汇集投资者的资金，由专业机构进行房地产的经营管理，并将90%以上的税后收入净额分配给投资者的一种信托组织。简单来说，REITs 就是代理投资者投资房地产的上市企业。</p>
<p>特点：</p>
<ul>
<li><p>定期强制高分红</p>
</li>
<li><p>投资门槛低</p>
</li>
<li><p>交易成本低</p>
</li>
<li><p>流动性强</p>
</li>
<li><p>专业化管理</p>
</li>
<li><p>收益率相对较高</p>
</li>
</ul>
<p>通过 REITs 我们可以很容易的投资世界主要国家的房地产。你看中哪个国家的房地产市场，你就买他的 REITs</p>
<p>房地产作为投资工具的优缺点：</p>
<ul>
<li><p>优点：能带来稳定的现金流，保值增值能力强</p>
</li>
<li><p>缺点：投资金额大，交易税费高，难变现</p>
</li>
</ul>
<p>正因为房地产作为投资工具有着明显的优缺点，所以 REITs 才被设计出来。对于开发商而言，通过 REITs 可以把开发好的房地产快速变现，提高开发效率；对于投资者来说，几百元就可以投资房地产了，大幅降低了投资门槛；对政府来说，REITs 促进房地产市场更健康的发展，有利于国家经济。</p>
<p>REITs 和房地产股票区别：<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/22.png"></p>
<p>我个人的理解，REITs 的本质就是房地产，房地产有的风险，REITs 基本也会有。房价下跌REITs也会下跌。但是房地产市场相比其他市场还是比较稳定的，所以 REITs 给大家提供了一种除了买房或买商铺以外的投资房地产市场的途径。</p>
<h3 id="8-基金"><a href="#8-基金" class="headerlink" title="8 基金"></a>8 基金</h3><h4 id="⭕️概念：认识一下“基金”"><a href="#⭕️概念：认识一下“基金”" class="headerlink" title="⭕️概念：认识一下“基金”"></a>⭕️概念：认识一下“基金”</h4><p>1 什么是基金？</p>
<p>把投资者的钱集中起来交给基金公司打理，基金公司赚钱了我们就赚钱了</p>
<p>2 基金有哪些类型？</p>
<p>2.1 按照基金的交易场所划分：场内基金、场外基金</p>
<p>场内基金：直接在证券交易所内投资的基金</p>
<p>场外基金：证券交易所外可以买卖的基金</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-2.png"></p>
<p>2.2 按照基金的投资对象去划分：货币基金、债券基金、混合基金、股票基金</p>
<p>如果主要把钱主要投资到了股票上，那就是股票基金</p>
<p>如果铁蛋主要把钱投资到了债券上，那就是债券基金</p>
<p>如果不限制资金用途，爱投资什么投资什么，那就是混合基金</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-3.png"></p>
<p>不同类型基金的年化收益率区别</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-4.png"></p>
<p>2.3 按照投资方式划分：主动型基金和被动型基金</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-5.png"></p>
<p>【主动型基金】，这种基金由基金经理决定买哪些股票，如股票基金、混合基金。</p>
<p>【被动型基金】就是【指数基金】，只根据指数配置股票，不人为选择股票。</p>
<h4 id="⭕️重点1：指数基金定投"><a href="#⭕️重点1：指数基金定投" class="headerlink" title="⭕️重点1：指数基金定投"></a>⭕️重点1：指数基金定投</h4><p>推荐的方式是：定期变额定投</p>
<p>【定期】可以是每月、每季度、每年</p>
<p>【变额】指投资额度会变化</p>
<p>【定期】+【变额】，这相当于指数基金的收益率放大器</p>
<p>这个变化不是随意变的，而是跟随投资工具的【市盈率】而变。</p>
<p>⭕那什么是【市盈率】呢？专业说法是市价盈利比率，是一个投资回报指标</p>
<p>市盈率几年就代表几年回本，越低越好。正常来讲市盈率15比较合理</p>
<p>此外，市盈率也可以作为何时卖出的参考标准</p>
<blockquote>
<p>建议每月定投。每月定投日可以设定为发薪日。这样发了工资直接拿出一部分（比如 10%-20%）定投<br>👉市盈率小于12时，每个月定投金额为2X元<br>👉市盈率小于10时，每个月定投金额为4X元</p>
</blockquote>
<p>当然也可以设置一个停止买入的市盈率，比如市盈率大于15时暂停买入</p>
<blockquote>
<p>友情提示：想投资房子的同学，也可以想想现在的房地产，租金带给你的年化收益率是多少？<br>公式是：【每年的租金÷买房子的总价】，你就知道你房子的年化收益率了</p>
</blockquote>
<h4 id="⭕️重点2：长生不老的指数基金"><a href="#⭕️重点2：长生不老的指数基金" class="headerlink" title="⭕️重点2：长生不老的指数基金"></a>⭕️重点2：长生不老的指数基金</h4><p>【指数基金】和主动基金相比，还有一个特别厉害的优点：【永生不死，长期上涨】</p>
<p>指数基金是会新陈代谢的，会自动淘汰那些不好的股票，加入满足条件的股票</p>
<h4 id="⭕️重点3：最好的定投是选择好的【股票】和【REITs】"><a href="#⭕️重点3：最好的定投是选择好的【股票】和【REITs】" class="headerlink" title="⭕️重点3：最好的定投是选择好的【股票】和【REITs】"></a>⭕️重点3：最好的定投是选择好的【股票】和【REITs】</h4><p>其实，还有比指数基金更好的理财工具：股票和REITs</p>
<blockquote>
<p>通常我们买基金共有4种渠道<br>1、证券公司<br>2、银行<br>3、基金公司<br>4、第三方代销平台，如支付宝、天天基金，蚂蚁聚宝，京东金融等</p>
</blockquote>
<p>【关键富人思维——第十三条】</p>
<p>掌握高收益率投资工具的科学方法是什么？</p>
<p>❤️【方法一】：很多人刚刚知道有一个高收益的工具，恨不得马上就买，然后就自我憧憬能赚多少。或者选择去市场中盲目的尝试，事实证明，他们自己总结的方法时而有效，时而无效，时而自信找到了暴富出路，时而迷茫否定自己、骂社会，我称之为焦虑的“【烧钱尝试法】”</p>
<p>其实他们不仅损失了自己的血汗钱，同时在错误尝试的时间里，也错过了正确买入好目标的机会。</p>
<p>❤️【方法二】：其实最快的方法，绝对不是马上去盲目尝试，磨刀不误砍材工，应该先去学习，在学习中最快的方法是什么，是看书吗？</p>
<p>如果看书能够实现财务自由，那么很多人早就财务自由了，因为看书最大的弊端就是没有反馈，没有人告诉你学的对还是学的错。</p>
<p>沉溺在看书中寻求财富自由的人，不能说不努力，但是因为没有有经验的老师指点，很多都成了【无效的努力】，最可怕的不是慢，是选错了方向，走错了路，在错误方向上的努力只是巩固错误。<br>❤️【方法三】：那么最快的学习方法是什么？答案是【巨人同行法】，跟着已经长期成功的投资者学习，巴菲特的老师是投资之神格雷厄姆，我们早读中8岁的投资神童，她的老师是父亲，也是成功的投资家。</p>
<p>他们都是一边勤奋学习理论，一边在老师的指导下纠正错误，一直走在一条正确的努力之路上。这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。</p>
<p>这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。你打算选哪条路？</p>
<p>【给自己找到正确的反馈，别让资金、时间白费。】</p>
<p>❤️总结一句话：站在巨人的肩膀上成长是最快的，站在巨人的肩膀学习理财技能也是变现最快的。</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-1.png"></p>
<h3 id="9-通货膨胀"><a href="#9-通货膨胀" class="headerlink" title="9 通货膨胀"></a>9 通货膨胀</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/09-1.png"></p>
<h4 id="⭕️重点1：什么是通货膨胀"><a href="#⭕️重点1：什么是通货膨胀" class="headerlink" title="⭕️重点1：什么是通货膨胀"></a>⭕️重点1：什么是通货膨胀</h4><blockquote>
<p>【通货膨胀】= 通货 + 膨胀</p>
</blockquote>
<p>通货就是通用货币，也叫法币，就是法律规定的必需使用的货币，比如：人民币</p>
<p>我们来看一下知名的【费雪方程式】</p>
<pre><code>MV=PT</code></pre>
<blockquote>
<p>我们一个一个拆解来看看<br>M ：货币的数量 V ：货币流通速度<br>P ：物价水平 T ：各类商品的交易总量<br><strong>在社会中V和T一般是比较稳定的，所以货币量M决定物价P</strong></p>
</blockquote>
<p>即，VT不动，M与P呈现正比例关系</p>
<p>也就是说， 货币越来越多，物价就会持续上涨</p>
<p>这就是通货膨胀</p>
<h4 id="⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？"><a href="#⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？" class="headerlink" title="⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？"></a>⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？</h4><pre><code>⭐实际CPI=M2增长率-GDP增长率⭐</code></pre>
<blockquote>
<p>M2增长率反映了一个国家每年钱的增长速度<br>GDP增长率反映了一个国家每年创造的商品和服务的增长速度<br>所以货币增长比商品和服务增长多出来的部分，这就是实际的CPI，也叫实际通货膨胀率⭐</p>
</blockquote>
<h4 id="⭕️重点3：如何避免被“割韭菜”？"><a href="#⭕️重点3：如何避免被“割韭菜”？" class="headerlink" title="⭕️重点3：如何避免被“割韭菜”？"></a>⭕️重点3：如何避免被“割韭菜”？</h4><p>既然理财如此重要，怎么才能在主动选择理财中，不被割韭菜呢？</p>
<h5 id="❌韭菜的特点1："><a href="#❌韭菜的特点1：" class="headerlink" title="❌韭菜的特点1："></a>❌韭菜的特点1：</h5><p>韭菜是【投机者】而不是【投资者】。</p>
<p>【投资】和【投机】有什么区别？ 👇</p>
<p>🍣【投资】以赚现金流为主，而且是赚确定性很高的现金流，赚差价为辅。</p>
<p>💰投资者会选出买入高股息率的好股票、高现金分红率的REITs。</p>
<p>💰即使价格不涨甚至下跌，每年也有7%—15%的现金分红收益</p>
<p>投机者典型的心态是：</p>
<p>生怕错过什么，又害怕被割韭菜，各种理由不愿意花精力去学习理财技能，所以想去市场上【试一试】，可能生活中是有负债，或者没有好支出，想着投资少点，亏了也就亏了，对理财没有正确认知。</p>
<h5 id="❌韭菜的特点2："><a href="#❌韭菜的特点2：" class="headerlink" title="❌韭菜的特点2："></a>❌韭菜的特点2：</h5><p>追求短期收益，高频交易，而不是长期投资</p>
<h5 id="❌韭菜的特点3："><a href="#❌韭菜的特点3：" class="headerlink" title="❌韭菜的特点3："></a>❌韭菜的特点3：</h5><p>不学习或不深入学习，盲目乱投资</p>
<p>【关键富人思维-第十四条】<br>⭐有的投机者说自己也赚钱了，那么选择做投资者到底好在哪？<br>🌹我们投资理财到底是为了什么呢？赚钱，但进一步想，赚钱是不被钱绑架，能有时间做自己想做的事，能和家人快乐的生活。</p>
<p>【不懂就去投的人】，短期内碰上运气了，也能赚到钱，但是他们是怎么度过的呢，每天把大量时间用来盯着大盘，昼夜想着跌了还是涨了，精神总是高度紧张，甚至睡觉都在想明天股票的情况，因为他们选择了“赌博”。历史证明，绝大多数投机者本来最应该乐观开心的两年，到头来却是在焦虑、闹心中度过的，因为他们没有真正的投资判断依据，这就是投机者的生活。</p>
<p>【懂得投资的人】，通过一整套分析方法选出优质的投资目标，算出买入好价格，买入，持有，再算出卖出合理价格，卖出。剩下的时间该干什么干什么，价格跌了，心里知道这是表面的波动，不被其迷惑，拿得住；价格涨了，知道什么时候该卖出，不冲动，赚踏实稳当钱。更厉害的，长期持有，被分红的复利滋润着。这是学习科学方法的自然成果，这也是不学习像苍蝇撞大运的投机者，与踏实学习走正道的投资者的最大差别。</p>
<p>当然，既不投机，也不投资的人都感受不到这些，他们只能感受到钱越来越不值钱，而自己的生活好像越来越紧吧了。</p>
<p>💎总结一句话：投资者获得的是金钱自由，时间自由，心理自由，投机者就算撞运赚了点，却一直在焦虑与煎熬中。</p>
<h3 id="10-股票"><a href="#10-股票" class="headerlink" title="10 股票"></a>10 股票</h3><p>以雪球app为例，选一只股票，看财务报表</p>
<p>几个指标：</p>
<p>1、行业对比：对比企业在行业中排名</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-1.png"></p>
<p>2、资产负债率：一般资产负债率超过70%，资产风险大</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-2.png"></p>
<p>3、ROE：常年收益率3%以下，还不如我拿着钱放货币基金</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-3.png"></p>
<p>4、毛利率：100万的售价最后只能赚9万块钱，剩下的都是成本。说明行业竞争激烈，公司没有差异化，没有很高的利润。</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-4.png"></p>
<p>5、净利润和经营现金流：公司表面上赚到了钱，但实际上都是别人欠他不给他，说明公司根本在行业里没地位。</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-5.png"></p>
<p>6、分红：企业有盈利才会分红</p>
<blockquote>
<p>从长期来说，一只股票的回报率跟公司的发展是环环相扣的，如果一家公司 40 年来的盈利一直是它资本的 6%（ROE），那在长期持有 40 年后，你的年均收益率不会和 6%有什么区别，即便你当初买的是便宜货。如果该公司在 20-30 年间盈利都是资本的 18%（ROE），即便你当初出价过高，回报依然会令你满意！——查理芒格</p>
</blockquote>
<p><strong><em>但是我希望大家记住：投资股票就是投资企业，企业赚钱你就赚钱</em></strong></p>
<p>【关键富人思维–第十五条】</p>
<p>我们最贵的东西是什么？<br>钱并不是最重要的东西，那我们最重要的是什么呢？</p>
<p>财务自由的本质就是时间自由，你如果是个价值投资者，那么你完全可以认为你买到的是——高额的银行存款。在享受生活的同时，不用看大盘，看K线。每年只看1-2次财报，其余的时间收钱，做自己喜欢的工作，享受生活。</p>
<p>其实，人最宝贵的是【时间精力】，每个人每天的时间都只有24小时，但是每个人能够挥洒精力的时间却远远小于24小时。严格上说，我们一天能够真正专注的时间可能都不超过2小时。</p>
<p>根据二八定律，你20%的投入决定了80%的成败。而这20%实际就是那每天2小时的精力投入。因此，我们才反反复复强调要站在巨人的肩膀上，前人走过的弯路，我们就不要再走了。</p>
<p>我们对于这2小时真正的精力投向，决定了我们的一生。人就是自己所有选择的求和结果</p>
<p>那些独自学习、独自试错的人，他们需要付出四项成本：时间成本、机会成本、金钱成本、试错成本。摸索、搜寻弄懂一个知识点的时间是站在巨人肩膀上学习的数年、数倍。</p>
<p>当年纪慢慢变大，【精力善用】才逐渐显示出复利的威力，人生的分野就在此开始。</p>
<p>【总结一句话】：时间和精力才是最宝贵的，尽量用它做正确的事，高效的事，而不是为了试错而试错，为了省钱浪费了最宝贵的时间价值。</p>
]]></content>
      <categories>
        <category>management</category>
      </categories>
      <tags>
        <tag>dairy</tag>
        <tag>self management</tag>
      </tags>
  </entry>
</search>
