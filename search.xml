<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Guava 实用篇（持续更新）</title>
      <link href="2021/02/01/guava-usable/"/>
      <url>2021/02/01/guava-usable/</url>
      
        <content type="html"><![CDATA[<h4 id="字符串-amp-集合处理-Splitter-Joiner"><a href="#字符串-amp-集合处理-Splitter-Joiner" class="headerlink" title="字符串&amp;集合处理 Splitter Joiner"></a>字符串&amp;集合处理 <code>Splitter</code> <code>Joiner</code></h4><p>最近在对接JD商城，商品详情的和分类的对应关系是一个字符串（包含3级分类，用分号分隔），Guava中提供了一个比较简单的处理方式</p><h5 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将string分解成list</span></span><br><span class="line">Iterable&lt;String&gt; split = Splitter.on(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        .trimResults()</span><br><span class="line">        .omitEmptyStrings()</span><br><span class="line">        .split(<span class="string">&quot;170;1238 ; ;   2218&quot;</span>);</span><br><span class="line">split.forEach(item -&gt; &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将list连接成string</span></span><br><span class="line">String join = Joiner.on(<span class="string">&quot;;&quot;</span>).skipNulls().join(split);</span><br><span class="line">System.out.println(<span class="string">&quot;join = &quot;</span> + join);</span><br></pre></td></tr></table></figure><p>分析一下 <code>Joiner</code> 的源码，<code>Splitter</code>类似。</p><p>Joiner类中主要包含 <strong>构造方法</strong>、<strong>appendTo方法</strong>、<strong>join方法</strong>。以及一系列他们的方法重载。</p><p>就以 <code>Joiner.on(&quot;;&quot;).skipNulls().join(split)</code> 这段代码为例：</p><h6 id="on"><a href="#on" class="headerlink" title="on()"></a>on()</h6><p>创建Joiner对象，并记录分隔用的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Joiner <span class="title">on</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Joiner(separator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Joiner</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.separator = checkNotNull(separator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的就是 <code>checkNotNull()</code> 方法。这是Guava提供的 <code>null</code> 值过滤的方法。这个方法在Guava官方手册的第一章节介绍。</p><h6 id="skipNulls"><a href="#skipNulls" class="headerlink" title="skipNulls()"></a>skipNulls()</h6><p>之前提到过Joiner类中主要包含的执行逻辑的方法：appendTo方法。</p><p>Guava通过链式编程的思想，在skipNulls()方法中返回了一个匿名内部类，在匿名内部类中重写了处理逻辑的appendTo方法，提供了过滤集合null值的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Joiner <span class="title">skipNulls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Joiner(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;A extends Appendable&gt; <span class="function">A <span class="title">appendTo</span><span class="params">(A appendable, Iterator&lt;?&gt; parts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            checkNotNull(appendable, <span class="string">&quot;appendable&quot;</span>);</span><br><span class="line">            checkNotNull(parts, <span class="string">&quot;parts&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (parts.hasNext()) &#123;</span><br><span class="line">                Object part = parts.next();</span><br><span class="line">                <span class="keyword">if</span> (part != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    appendable.append(Joiner.<span class="keyword">this</span>.toString(part));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (parts.hasNext()) &#123;</span><br><span class="line">            Object part = parts.next();</span><br><span class="line">                <span class="keyword">if</span> (part != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    appendable.append(separator);</span><br><span class="line">                    appendable.append(Joiner.<span class="keyword">this</span>.toString(part));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> appendable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Joiner <span class="title">useForNull</span><span class="params">(String nullText)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;already specified skipNulls&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MapJoiner <span class="title">withKeyValueSeparator</span><span class="params">(String kvs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;can&#x27;t use .skipNulls() with maps&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名内部类中重写了 <code>appendTo</code> 方法，加入了两处 <code>null</code> 值的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (part != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>这个方法接收传入的集合，然后内部调用 <code>appendTo</code> 方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">join</span><span class="params">(Iterator&lt;?&gt; parts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendTo(<span class="keyword">new</span> StringBuilder(), parts).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里接收的参数类型是 <code>Iterator&lt;?&gt;</code> 接口。</p><p>涵盖了我们日常使用的所有集合类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* @see     Set</span><br><span class="line">* @see     List</span><br><span class="line">* @see     Map</span><br><span class="line">* @see     SortedSet</span><br><span class="line">* @see     SortedMap</span><br><span class="line">* @see     HashSet</span><br><span class="line">* @see     TreeSet</span><br><span class="line">* @see     ArrayList</span><br><span class="line">* @see     LinkedList</span><br><span class="line">* @see     Vector</span><br><span class="line">* @see     Collections</span><br><span class="line">* @see     Arrays</span><br><span class="line">* @see     AbstractCollection</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="缓存-CacheLoader"><a href="#缓存-CacheLoader" class="headerlink" title="缓存 CacheLoader"></a>缓存 <code>CacheLoader</code></h4><p>Guava 提供了一个缓存方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (CacheLoader) (key) -&gt; &#123;&#125;</span></span><br><span class="line">    <span class="keyword">private</span> CacheLoader cacheLoader = <span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 如果找不到元素，会调用这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到 = &quot;</span> + key);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 模拟：去数据库查询/远程调用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String value = getValue();</span><br><span class="line">            loadingCache.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, String&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(<span class="number">1000</span>) <span class="comment">// 容量</span></span><br><span class="line">        .expireAfterWrite(<span class="number">3</span>, TimeUnit.SECONDS) <span class="comment">// 过期时间</span></span><br><span class="line">        .removalListener(<span class="keyword">new</span> MyRemovalListener()) <span class="comment">// 失效监听器</span></span><br><span class="line">        .build(cacheLoader);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRemovalListener</span> <span class="keyword">implements</span> <span class="title">RemovalListener</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;String, String&gt; notification)</span> </span>&#123;</span><br><span class="line">        String reason = String.format(<span class="string">&quot;key=%s,value=%s,reason=%s&quot;</span>, notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(<span class="string">&quot;reason:&quot;</span> + reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在LoadCache类中维护了一个AtomicReferenceArray&lt;ReferenceEntry&lt;K, V&gt;&gt; table</p><p>具体的源码我还没有仔细看。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> String </tag>
            
            <tag> Cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>feign GET 异常</title>
      <link href="2021/01/29/feign-GET/"/>
      <url>2021/01/29/feign-GET/</url>
      
        <content type="html"><![CDATA[<p>只要参数是复杂对象，即使指定了是GET方法，feign依然会以POST方法进行发送请求；</p><p>如果不加默认的注解，Feign则会对参数默认加上@RequestBody注解，而RequestBody一定是包含在请求体中的，GET方式无法包含</p><p>所以会发生 <code>method GET must not have a request body</code> 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Request.<span class="function">Builder <span class="title">method</span><span class="params">(String method, <span class="meta">@Nullable</span> RequestBody body)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;method == null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method.length() == 0&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body != <span class="keyword">null</span> &amp;&amp; !HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method &quot;</span> + method + <span class="string">&quot; must not have a request body.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (body == <span class="keyword">null</span> &amp;&amp; HttpMethod.requiresRequestBody(method)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method &quot;</span> + method + <span class="string">&quot; must have a request body.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：<br>GET请求传递封装好的对象时，使用 <code>@RequestParam</code> 修饰 <code>Map&lt;String, Object&gt; </code>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Clound </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 三级缓存中 SingletonFactories 作用？</title>
      <link href="2021/01/27/spring-cache-singletonfactories/"/>
      <url>2021/01/27/spring-cache-singletonfactories/</url>
      
        <content type="html"><![CDATA[<p>Spring 为什么要设计三级缓存？<br>其中SingletonFactories工厂的作用是什么？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/singletonFactories.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 三级缓存 </tag>
            
            <tag> SingletonFactories </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式在源码中的应用</title>
      <link href="2021/01/22/patterns/"/>
      <url>2021/01/22/patterns/</url>
      
        <content type="html"><![CDATA[<p>举例一下常用设计模式在源码中的使用，帮助学习。</p><p><strong>静态工厂方法</strong><br>Calendar.getInstance()<br>java.text.NumberFormat.getInstance()<br>java.util.ResourceBundle.getBundle()</p><p><strong>工厂方法（获取实际对象）</strong><br>java.net.URLStreamHandlerFactory<br>javax.xml.bind.JAXBContext.createMarshaller</p><p><strong>抽象工厂模式（先获取工厂、再获取实际对象）</strong><br>java.sql.Connection<br>java.sql.Driver</p><p><strong>建造者模式</strong><br>Spring源码中应用<br>org.springframework.web.servlet.mvc.method.RequestMappingInfo<br>org.springframework.beans.factory.support.BeanDefinitionBuilder</p><p><strong>原型模式（hashtable、继承Cloneable）</strong><br>java.util.Arrays<br>org.springframework.beans.factory.support.AbstractBeanDefinition</p><p><strong>享元模式（hashmap）</strong><br>String\Integer\Long..<br>com.sun.org.apache.bcel.internal.generic.InstructionContstants</p><p><strong>门面模式、外观模式</strong><br>org.apache.catalina.connector.RequestFacade</p><p><strong>观察者模式</strong><br>java.util.Observable<br>org.springframework.context.ApplicationListener</p><p><strong>适配器模式</strong><br>Arrays#adList()\Collections#list()<br>org.springframework.context.event.GenericApplicationListenerAdapter</p><p><strong>装饰者模式</strong><br>javax.servlet.http.HttpServletRequestWrapper<br>javax.servlet.http.HttpServletResponseWrapper</p><p><strong>策略模式</strong><br>java.util.Comparator<br>org.springframework.beans.factory.support.InstantiationStrategy</p><p><strong>模板方法模式</strong><br>javax.servlet.http.HttpServlet<br>org.springframework.web.servlet.mvc.AbstractController</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 你没见过的单例写法</title>
      <link href="2021/01/20/nsingleton/"/>
      <url>2021/01/20/nsingleton/</url>
      
        <content type="html"><![CDATA[<p><strong>分享两种新鲜的单例写法</strong></p><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> * JVM保证单例、懒加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元素枚举类"><a href="#单元素枚举类" class="headerlink" title="单元素枚举类"></a>单元素枚举类</h4><p>出自 <a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual">Effective-Java</a> 书籍中的 <code>Chapter 2 Item 3: Enforce the singleton property with a private constructor or an enum type</code></p><p>这里给大家分享这本书的在线汉化版本，非常建议花时间学习一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式创建的单例不仅可以解决 <strong>线程同步问题</strong>，还可以 <strong>防止反序列化</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
            <tag> 静态内部类 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象存储和指针逃逸</title>
      <link href="2021/01/20/new-Object/"/>
      <url>2021/01/20/new-Object/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在 <a href="https://yloopdaed.icu/2020/10/29/memory-layout-of-java-object/">Java对象的内存布局</a> 文章的末尾提到了对象的存储位置，现在扩展一下之前的内容。</p><h3 id="对象存储在堆上还是栈上？"><a href="#对象存储在堆上还是栈上？" class="headerlink" title="对象存储在堆上还是栈上？"></a>对象存储在堆上还是栈上？</h3><p>看下面这段代码，循环创建一亿次Object对象，通常理解一个空Object对象创建会在栈中存在一个4字节的指针，指向堆中的对象16字节。<br>循环创建一亿次大概会占用1.6G的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    new Object();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 38ms</p></blockquote><p><strong><em>这是为什么？</em></strong></p><h3 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h3><p>判断对象是否在堆中进行分配有一个前提：<strong>判断逃逸状态</strong></p><h4 id="全局逃逸（GlobalEscape）"><a href="#全局逃逸（GlobalEscape）" class="headerlink" title="全局逃逸（GlobalEscape）"></a>全局逃逸（GlobalEscape）</h4><p>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：</p><p>1 对象是一个静态变量</p><p>2 对象是一个已经发生逃逸的对象</p><p>3 对象作为当前方法的返回值</p><h4 id="参数逃逸（ArgEscape）"><a href="#参数逃逸（ArgEscape）" class="headerlink" title="参数逃逸（ArgEscape）"></a>参数逃逸（ArgEscape）</h4><p>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</p><h4 id="没有逃逸"><a href="#没有逃逸" class="headerlink" title="没有逃逸"></a>没有逃逸</h4><p>即方法中的对象没有发生逃逸</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>JVM默认会开启逃逸分析 <code>-XX:+DoEscapeAnalysis</code></p><p>开启逃逸分析后，如果JVM分析得到对象 <strong>没有发生逃逸</strong> 的话，那么 <code>new Object()</code> 新建的对象并没有在外部被使用，所以它被优化为在栈上分配，我们知道方法执行完成后该栈帧就会被清空，所以也就不会有GC。</p><p><strong>反之：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    Object o &#x3D; new Object();</span><br><span class="line">    o.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 8014ms</p></blockquote><p>会使对象发生逃逸的常见方式：</p><p>1 对象被赋值给堆中对象的字段和类的静态变量</p><p>2 对象被传进了不确定的代码中去运行</p><h3 id="基于逃逸分析的优化"><a href="#基于逃逸分析的优化" class="headerlink" title="基于逃逸分析的优化"></a>基于逃逸分析的优化</h3><p>也就是基于JVM逃逸分析机制对代码进行一些优化，提升代码的性能。</p><p>这部分内容可以参考：<a href="https://zhuanlan.zhihu.com/p/59215831">JVM之逃逸分析</a></p><hr><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/NewObject类中查看。</p><p>结论: JVM虚拟机逃逸分析是默认开启的，对象不会逃逸的时候优先在栈上分配，否则在堆上分配。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆、栈 </tag>
            
            <tag> 指针逃逸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个线程池封装背后</title>
      <link href="2021/01/19/custom-thread-pool/"/>
      <url>2021/01/19/custom-thread-pool/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要自定义线程池"><a href="#为什么要自定义线程池" class="headerlink" title="为什么要自定义线程池"></a>为什么要自定义线程池</h4><p>Java <code>Executors</code> 为我们构建线程池提供了几种的静态工厂方法。功能强大、简单易用、工厂模式等。看上去是个不错的选择。</p><p><strong>但是，这些线程池的使用可能会造成严重的后果。</strong></p><p>话题要从 <a href="https://zhuanlan.zhihu.com/p/32867181">一次Java线程池误用引发的血案和总结</a> 引出。头条的系统中由于使用了 <code>newFixedThreadPool</code> 造成了服务器内存溢出熔断</p><p>同时，阿里在 <strong>嵩山版Java开发手册</strong> 中也【强制】不允许使用Executors去创建线程池。</p><p>那么问题究竟出在哪里呢？</p><a id="more"></a><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>1 interface Executor<br>2 interface ExecutorService extends Executor<br>3 abstract class AbstractExecutorService implements ExecutorService<br>4 class ThreadPoolExecutor extends AbstractExecutorService</p><h5 id="ThreadPoolExecutor-构造方法"><a href="#ThreadPoolExecutor-构造方法" class="headerlink" title="ThreadPoolExecutor 构造方法"></a>ThreadPoolExecutor 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>1 int corePoolSize  核心线程数</p><p>2 int maximumPoolSize  最大线程数</p><p>3 long keepAliveTime  非核心线程数空闲时等待的时间</p><p>4 TimeUnit unit       keepAliveTime 的时间单位</p><p>5 BlockingQueue<Runnable> workQueue   阻塞队列<br>    在任意时刻，不管并发有多高，永远只有一个线程能够进行队列的入队或者出队操作！（线程安全）<br>    5.1 ArrayBlockingQueue 数组结构的有界阻塞队列<br>    5.2 LinkedBlockingQueue 链表结构的有界阻塞队列<br>    5.3 DelayQueue    队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。<br>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。<br>    5.4 PriorityBlockingQueue 基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。<br>    5.5 SynchronousQueue  这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p><p>6 ThreadFactory threadFactory 线程工厂</p><p>7 RejectedExecutionHandler handler  拒绝策略<br>    AbortPolicy 抛异常<br>    CallerRunsPolicy<br>    DiscardOldestPolicy<br>    DiscardPolicy 丢弃任务</p><h5 id="线程池状态及AtomicInteger-ctl"><a href="#线程池状态及AtomicInteger-ctl" class="headerlink" title="线程池状态及AtomicInteger ctl"></a>线程池状态及AtomicInteger ctl</h5><p>ThreadPoolExecutor类中定义了一个volatile int变量runState来表示线程池的状态</p><p>1 running  能接受新任务以及处理已添加的任务<br>2 shutdown    不接受新任务，可以处理已经添加的任务<br>3 stop    不接受新任务，不处理已经添加的任务，并且中断正在处理的任务<br>4 tidying    所有的任务已经终止，ctl记录的任务数量为0，ctl负责记录线程池的运行状态与活动线程数量<br>5 terminated    线程池彻底终止</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pool%20runstate.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>AtomicInteger ctl<br>共32位<br>高3位记录线程池生命状态<br>后29位记录当前工作线程数</p><h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二次判断：</p><p>在多线程环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程状态立即就发生改变。</p><p>判断是否将command加入workqueue是线程池之前的状态，倘若没有二次检查，如果线程池处于非RUNNING状态，那么command永远不会执行。</p><h5 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h5><p>详细：<br>1 线程总数量 &lt; corePoolSize，新建一个核心线程执行任务<br>2 线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待（线程复用）<br>3 当缓存队列满了，会创建非核心线程去执行任务<br>4 总线程数达到了maximumPoolSize，拒绝策略处理</p><p>流程(先后):<br>核心线程-&gt;队列-&gt;最大线程-&gt;拒绝策略</p><h5 id="为什么不安全？"><a href="#为什么不安全？" class="headerlink" title="为什么不安全？"></a>为什么不安全？</h5><p>前面铺垫了这么多，我们来看为什么Java提供的线程池不安全。</p><p><strong>1 newFixedThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2 newSingleThreadExecutor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式创建的线程池对象设置的 <code>缓冲队列</code> 为 <code>LinkedBlockingQueue</code>，长度为 <code>Integer.MAX_VALUE</code>。所以几乎不会触发拒绝策略。当大量请求堆积时会造成OOM。</p><p><strong>3 newCachedThreadPool</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 ScheduledThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种方式创建的线程池对象设置的 <code>最大线程池数量</code> 为 <code>Integer.MAX_VALUE</code>。所以几乎不会触发拒绝策略。当大量请求堆积时会造成OOM。</p><h4 id="封装一个简易的线程池"><a href="#封装一个简易的线程池" class="headerlink" title="封装一个简易的线程池"></a>封装一个简易的线程池</h4><p>借助开源类库 <code>apache</code> 和 <code>guava</code> 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 线程池维护线程的最少数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minPoolSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/** 线程池维护线程的最大数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/** 线程池维护线程所允许的空闲时间 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleSeconds = <span class="number">1800</span>;</span><br><span class="line">    <span class="comment">/** 线程池所使用的缓冲队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueBlockSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor executor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolTools</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;custom-create-thread-%d&quot;</span>).build(); <span class="comment">// guava</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.executor = <span class="keyword">new</span> ThreadPoolExecutor(minPoolSize, maxPoolSize, idleSeconds,</span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">/* 时间单位,秒 */</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueBlockSize),</span><br><span class="line">                namedThreadFactory,</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()); <span class="comment">/* 重试添加当前加入失败的任务 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        executor.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.submit(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> </p><h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadPoolTools threadPoolTools = <span class="keyword">new</span> ThreadPoolTools();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            threadPoolTools.execute(ExecutorsTest::run);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPoolTools.executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!threadPoolTools.executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程还在执行。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;一共处理了:&quot;</span>+ (end - start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的使用方式不仅可以避免OOM的问题，也方便通过自定义的线程名称查看日志信息。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
            <tag> guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cacheline 伪共享</title>
      <link href="2021/01/08/cacheline-improve/"/>
      <url>2021/01/08/cacheline-improve/</url>
      
        <content type="html"><![CDATA[<h4 id="before"><a href="#before" class="headerlink" title="before"></a>before</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><p><strong>markWord + klass 8字节</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CacheLine </tag>
            
            <tag> JMM </tag>
            
            <tag> 缓存一致性协议(MESI) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 指令快查</title>
      <link href="2021/01/08/docker/"/>
      <url>2021/01/08/docker/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是-Docker？"><a href="#什么是-Docker？" class="headerlink" title="什么是 Docker？"></a>什么是 <a href="https://www.docker.com/">Docker</a>？</h4><p>Docker是一个开源的应用容器引擎，基于Go语言，并遵循Apache2.0协议开源。</p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>Docker核心概念：<br>1 docker主机（Host）：安装了Docker程序的机器（Docker直接安装在操作系统之上）<br>2 docker客户端（Client）：连接docker主机进行操作<br>3 docker仓库（Registry）：用来保存软件镜像<br>4 docker镜像（Images）：软件打包好的镜像，放在docker仓库中<br>5 docker容器（Container）：镜像启动后的实例称为一个容器，容器是独立运行的一个或一组应用</p><p>理解：<br>1 镜像（Images）就是一个只读的模板，可以用来创建容器（一个镜像可以创建多个容器）<br>镜像与容器的关系，有点类似于面向对象变成中的类（镜像）与对象（容器）。<br>2 容器（Container）是一个或一组独立运行的应用，每个容器相互隔离，保证安全的平台。<br>容器可以看做是一个简易版的Linux环境和运行在其中的应用程序。<br>3 仓库是集中存放镜像文件的场所。<br>仓库（Repository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器上存放着多个仓库，每个仓库有包含多个镜像，每个镜像有不同的标签（tag）</p><a id="more"></a><h4 id="安装及启动"><a href="#安装及启动" class="headerlink" title="安装及启动"></a>安装及启动</h4><h5 id="before-CentOS7"><a href="#before-CentOS7" class="headerlink" title="before CentOS7"></a>before CentOS7</h5><p>1 安装相关依赖库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><p>2 安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-io</span><br></pre></td></tr></table></figure><p>3 配置阿里云镜像路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;docker</span><br><span class="line"></span><br><span class="line">替换下面内容为aliyun镜像地址</span><br><span class="line">other_args&#x3D;&quot;--registry-mirror&#x3D;https:&#x2F;&#x2F;rkcuhe1v.mirror.aliyuncs.com&quot;</span><br></pre></td></tr></table></figure><p>4 启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><h5 id="after-CentOS7"><a href="#after-CentOS7" class="headerlink" title="after CentOS7"></a>after CentOS7</h5><p>1 卸载之前版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">      docker-client \</span><br><span class="line">      docker-client-latest \</span><br><span class="line">      docker-common \</span><br><span class="line">      docker-latest \</span><br><span class="line">      docker-latest-logrotate \</span><br><span class="line">      docker-logrotate \</span><br><span class="line">      docker-engine</span><br></pre></td></tr></table></figure><p>2 安装yum工具类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure><p>3 启用docker源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><p>4 安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>5 配置镜像加速其器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;rkcuhe1v.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>安装后操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">2 启动后查看</span><br><span class="line">docker -v</span><br><span class="line">3 设置开机启动docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">4 停止docker</span><br><span class="line">systemctl stop docker </span><br></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><h5 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h5><p>1 搜索镜像<br>是从 <a href="https://hub.docker.com/">https://hub.docker.com/</a> 查找的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search [options] 关键字</span><br><span class="line">eg: docker search mysql</span><br></pre></td></tr></table></figure><p>options参数：<br>-s 列出STARS不小于指定值的镜像<br>-no-trunc 显示完整的镜信息（这里简写了DESCRIPTION）<br>-automated 只列出automated build类型的镜像</p><p>2 拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名 [:TAG]</span><br></pre></td></tr></table></figure><p>tag是版本号，不添加时，默认下载的是latest版本<br>如果配置了阿里云镜像，那么会从阿里云镜像地址下载</p><p>3 查看本地镜像列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [options] images</span><br></pre></td></tr></table></figure><p>options参数：<br>-a 列出本地所有镜像（含中间层）<br>-q 只显示镜像的ID<br>–digests 显示镜像摘要信息<br>–no-trunc 显示完整的镜像信息（这里简写ID，原本默认显示12位）</p><p>列表详情：<br>REPOSITORY：镜像仓库源<br>TAG：标签<br>IMAGE ID：镜像ID（默认显示12位）<br>CREATED：创建时间<br>SIZE：镜像大小<br>DIGEST：摘要信息</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/docker%20image.png" alt="镜像信息"></p><p>4 删除本地镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [options] 镜像名&#x2F;ID [:TAG]</span><br></pre></td></tr></table></figure><p>5 镜像commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像</span><br><span class="line">docker commit -m&#x3D;&quot;信息&quot; -a&#x3D;&quot;作者&quot; 容器ID 要创建的镜像名:tag名</span><br></pre></td></tr></table></figure><p><strong>删除本地所有镜像：<code>docker rmi -f $(docker images -qa)</code></strong></p><h5 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h5><p>1 运行镜像并启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run docker run [options] 镜像ID [:TAG]</span><br><span class="line">例：</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">docker run -d -p 8000:8080 tomcat</span><br></pre></td></tr></table></figure><p>options参数：<br>–name= 为容器指定一个名称<br>-d 后台运行容器，以守护式运行容器，返回容器ID<br>-i 以交互式运行容器（通常 -it 同用）<br>-t 为容器重新分配一个伪输入终端（通常 -it 同用）<br>-P 随机端口映射<br>-p 指定端口映射，有四种方式：<br>    ip:hostPort:containerPort<br>    ip::containerPort<br>    hostPort:containerPort<br>    containerPort</p><p>2 查看运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]</span><br></pre></td></tr></table></figure><p>options参数：<br>-a 列出正在运行的容器+历史运行的容器<br>-l 显示最新创建的容器<br>-n 显示最新创建的n个容器<br>-q 静默模式，只显示容器编号<br>–no-trunc 显示完整信息</p><p>3 停止运行中的容器</p><p>3.1 正常关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名&#x2F;ID</span><br></pre></td></tr></table></figure><p>3.2 强制关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill 容器名&#x2F;ID</span><br></pre></td></tr></table></figure><p>3.3 退出容器<br>以 docker run -it 这种交互模式进入的容器，会有退出容器的操作<br>3.3.1 命令exit 停止并退出<br>3.3.2 快捷键ctrl+p+q 不停止退出</p><p>退出后重新回到容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure><p>进入容器中运行命令后自动退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -t 容器ID +命令</span><br></pre></td></tr></table></figure><p>4 启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名&#x2F;ID</span><br></pre></td></tr></table></figure><p>5 删除一个容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure><p><strong>删除本地所有容器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 docker rm -f $(docker ps -qa)</span><br><span class="line">2 docker ps -qa | xargs docker rm ，上一个命令的结果集传递给下一个命令</span><br></pre></td></tr></table></figure><p>6 查看容器日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [options] container-name&#x2F;container-id</span><br></pre></td></tr></table></figure><p>options参数：<br>-t 表示加入时间戳<br>-f 跟随最新的日志打印<br>–tail 数字 显示最后多少条</p><h5 id="常用软件启动"><a href="#常用软件启动" class="headerlink" title="常用软件启动"></a>常用软件启动</h5><p>docker运行mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql</span><br><span class="line">-v &#x2F;yy&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d</span><br><span class="line">-v &#x2F;yy&#x2F;mysql&#x2F;logs:&#x2F;logs</span><br><span class="line">-v &#x2F;yy&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456</span><br><span class="line">-d mysql:版本号 </span><br></pre></td></tr></table></figure><p>docker运行redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:7379</span><br><span class="line">-v &#x2F;yy&#x2F;myredis&#x2F;data:&#x2F;data</span><br><span class="line">-v &#x2F;yy&#x2F;myredis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">-d redis:版本号 redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br><span class="line">--appendonly yes</span><br></pre></td></tr></table></figure><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><p>查看容器内运行的进程 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器ID</span><br></pre></td></tr></table></figure><p>查看容器内部细节 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure><p>重新进入不停止退出ctrl+p+q 的docker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker attach 容器ID，重新回到容器</span><br><span class="line">docker exec -t  容器ID 命令，进入容器中运行命令后自动退出</span><br></pre></td></tr></table></figure><p>容器内拷贝文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器ID:容器内路径 目标路径</span><br></pre></td></tr></table></figure><h4 id="数据卷容器Volume"><a href="#数据卷容器Volume" class="headerlink" title="数据卷容器Volume"></a>数据卷容器Volume</h4><p>能做什么？<br>1 容器的持久化<br>2 容器间继承+数据共享</p><h5 id="使用命令添加容器数据卷"><a href="#使用命令添加容器数据卷" class="headerlink" title="使用命令添加容器数据卷"></a>使用命令添加容器数据卷</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;host绝对路径目录:&#x2F;容器内目录 镜像名</span><br></pre></td></tr></table></figure><p>这个命令会在宿主机和容器中添加共通的目录，<strong>这两个目录可以进行数据共享和对接，容器停止退出后，主机修改的数据依然可以同步</strong></p><p>可以用命令控制容器内目录的读写权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v &#x2F;myDataVolume:&#x2F;dataVolumeContainer:ro centos</span><br></pre></td></tr></table></figure><p>加了只读权限后，在共享目录中。主机添加的文件，容器内可以查看。但是不能修改，也不能创建文件</p><h5 id="使用DockerFile添加容器数据卷"><a href="#使用DockerFile添加容器数据卷" class="headerlink" title="使用DockerFile添加容器数据卷"></a>使用DockerFile添加容器数据卷</h5><p>考虑到可移植和分享，使用-v命令不太好，建议使用DockerFile<br>DockerFile是Docker image源码级的文件</p><p>例子：通过DockerFile构建自己的centos镜像：<br>1 主机跟目录上新建 mkdir /mydocker 目录<br>2 书写DockerFilter文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;&#x2F;dataVolumeContainer1&quot;,&quot;&#x2F;dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;success&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>3 docker build 将上面DockerFile所在的文件，构建成镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t 起一个新镜像名 目录</span><br><span class="line">eg:</span><br><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t yycentos .</span><br></pre></td></tr></table></figure><p>-f 指文件<br>-t 命名空间</p><p>4 启动<br>docker run -it yycentos<br>启动后可以发现，在容器内会出现 /dataVolumeContainer1和/dataVolumeContainer2 两个文件目录</p><blockquote><p>ps：如果容器内访问共享目录出现：cannot open directory .: Permission denied<br>解决：在docker run 命令最后加 –privileged=true 参数</p></blockquote><h4 id="DockerFile解析"><a href="#DockerFile解析" class="headerlink" title="DockerFile解析"></a>DockerFile解析</h4><p>DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本<br>构建步骤：<br>1 编写DockerFile文件<br>2 docker build<br>3 docker run</p><p>语法规则：<br>1 每条保留字执行都必须大写，后面要跟随至少一个参数<br>2 执行按照从上到下，顺序执行<br>3 #表示注释<br>4 每条指令都会创建一个新的镜像层，并对镜像进行提交</p><p>保留字指令：<br>1 FROM 基础镜像，当前新镜像是基于哪个镜像的<br>2 MAINTAINER 镜像维护者的姓名和邮箱<br>3 RUN 容器构件时需要运行的命令<br>4 EXPOSE 当前容器对外暴露出的端口号<br>5 WORKDIR 指定创建容器后，终端默认登录的工作目录，落脚点<br>6 ENV 用来在构建镜像过程中设置环境变量<br>7 COPY 拷贝，源路径到新一层路径<br>    写法1：COPY src dest — 这种是linux命令形式<br>    写法2：COPY [“src”,”dest”] — 这种是json串形式<br>8 ADD 拷贝并解压，将宿主机目录下的文件拷贝进镜像，且自动处理URL和解压<br>9 VOLUME 容器数据卷，用于数据保存和持久化<br>10 CMD 指定一个容器启动时要运行的命令<br>    DockerFile中可以有多个CMD指令，但是只有最后一个生效，且会被docker run之后的参数替换<br>11 ENTRYPOINT 指定一个容器启动时要运行的命令<br>    ENTRYPOINT的目的和CMD一样，都是指定容器启动程序及参数，但不会被docker run之后的参数替换，而是追加<br>12 ONBUILD 当构建一个被继承的DockerFile时运行命令，父镜像在被子继承后，父镜像的onbuild被触发<br>    在构建子镜像时会显示 # Executing 1 build triggers</p><p>案例：做一个自己的CentOS镜像<br>1 编写DockerFile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER yy&lt;521300259@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local  # 创建一个环境变量，名为MYPATH，代表路径&#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH         # 指定启动后落脚点为 &#x2F;usr&#x2F;local</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim     # 给centos安装vim</span><br><span class="line">RUN yum -y install net-tools    # 给centos安装ifconfig</span><br><span class="line"></span><br><span class="line">EXPOSE 80  # 对外暴露80端口</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>2 构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;DockerFile -t yycentos2 .</span><br></pre></td></tr></table></figure><p>3 运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run yycentos2 </span><br></pre></td></tr></table></figure><p>4 查看镜像变更历史</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history 镜像名</span><br></pre></td></tr></table></figure><h4 id="镜像原理"><a href="#镜像原理" class="headerlink" title="镜像原理"></a>镜像原理</h4><p>之后更新</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个简陋的LRU算法</title>
      <link href="2021/01/04/handle-redis-LRU/"/>
      <url>2021/01/04/handle-redis-LRU/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通过手写一个简陋的LRU算法实现，达到理解其数据结构和算法的目的。</p><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>LRU：最近最少使用置换算法(Least Recently Used)，也就是首先淘汰最长时间未被使用的页面</p><a id="more"></a><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>在 <code>LinkedHashMap</code> 源码中有这样一行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This kind of map is well-suited to building LRU caches.</span><br></pre></td></tr></table></figure><p>也就是说这是官方推荐的最高效的LRU算法的实现。</p><p>这种方式实现只需要继承 <code>LinkedHashMap</code> ，并重写一下 <code>removeEldestEntry</code> 方法即可。</p><p>您可以查看 <a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/lru/LRULinkedHashMap.java">LRULinkedHashMap.java</a></p><h4 id="散列表-双向链表"><a href="#散列表-双向链表" class="headerlink" title="散列表+双向链表"></a>散列表+双向链表</h4><p>设计思路：<br>1 参考AQS设计Node节点和双向链表<br>2 通过散列表判断和限制链表的长度<br>3 通过双向链表来记录每个节点的热度（例如：热度高的移动至最侧）</p><p>完成的代码实现：</p><p>由于代码篇幅较长，您可以查看 <a href="https://github.com/YorickYu/JPP/blob/main/src/main/java/com/yy/lru/LRUCustomMap.java">LRUCustomMap.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yy.lru;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCustomMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;K, Node&lt;K, V&gt;&gt; lruMap;</span><br><span class="line">    <span class="keyword">private</span> DoubleLinkedList&lt;K, V&gt; lruDoubleLinkedList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCustomMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        lruMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        lruDoubleLinkedList = <span class="keyword">new</span> DoubleLinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lruMap.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;K, V&gt; node = lruMap.get(key);</span><br><span class="line">        lruDoubleLinkedList.popNode(node);</span><br><span class="line">        lruDoubleLinkedList.pushNode(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lruMap.containsKey(key)) &#123;</span><br><span class="line">            Node&lt;K, V&gt; node = lruMap.get(key);</span><br><span class="line">            node.v = value;</span><br><span class="line">            lruMap.put(key, node);</span><br><span class="line">            lruDoubleLinkedList.popNode(node);</span><br><span class="line">            lruDoubleLinkedList.pushNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lruMap.size() == capacity) &#123;</span><br><span class="line">                Node&lt;K, V&gt; lastNode = lruDoubleLinkedList.lastNode();</span><br><span class="line">                lruMap.remove(lastNode.k);</span><br><span class="line">                lruDoubleLinkedList.popNode(lastNode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// new</span></span><br><span class="line">            Node&lt;K, V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">            lruMap.put(key, newNode);</span><br><span class="line">            lruDoubleLinkedList.pushNode(newNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node 节点类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        K k;</span><br><span class="line">        V v;</span><br><span class="line">        Node&lt;K, V&gt; prev;</span><br><span class="line">        Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k = k;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Node&lt;K, V&gt; prev, Node&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; HEAD;</span><br><span class="line">        Node&lt;K, V&gt; TAIL;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HEAD = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            TAIL = <span class="keyword">new</span> Node&lt;&gt;();</span><br><span class="line">            HEAD.next = TAIL;</span><br><span class="line">            TAIL.prev = HEAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// head  &lt;=&gt;   tail</span></span><br><span class="line">        <span class="comment">// head  &lt;=&gt;   node   &lt;=&gt;   tail</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushNode</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">            node.prev = HEAD;</span><br><span class="line">            node.next = HEAD.next;</span><br><span class="line">            HEAD.next.prev = node;</span><br><span class="line">            HEAD.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">lastNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TAIL.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popNode</span><span class="params">(Node&lt;K, V&gt; node)</span> </span>&#123;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.prev = <span class="keyword">null</span>;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
            <tag> Reids </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snowflake 雪花算法封装</title>
      <link href="2021/01/04/snowflake-config/"/>
      <url>2021/01/04/snowflake-config/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>基于 <a href="https://www.hutool.cn/">Hutool</a> 工具包 <code>唯一ID工具-IdUtil</code> 封装的一个雪花算法ID生成工具。</p><h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>雪花算法简单介绍下：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Image.png"></p><p>Twitter公司开源的一种生成分布式id的算法。<br>大致满足：<br>1 生产性能高，每秒生成26万个趋势自增的ID<br>2 稳定性高，不依赖其他第三方系统，分布式系统中不会产生ID碰撞<br>3 使用灵活，ID中包含时间戳、工作主机、数据中心等数据，可以自由配置</p><p>缺点：<br>1 依赖机器时钟，如果机器时钟回拨，会产生重复ID<br>2 单机上递增，分布式环境每台机器时钟不可能完全同步，有时候会出现不是全局递增的情况<br>（分布式Id一般只要求趋势递增，所以这个缺点可以忽略）</p><p>其他分布式ID算法：<br>1 百度 UidGenerator<br>2 美团 Leaf<br><strong>上面这两种算法没有时钟回拨问题，有兴趣可以自行了解</strong></p><a id="more"></a><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1 建议引入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2 项目中导入 <code>SFIdGenerator.java</code> </p><p>3 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">SFIdGenerator sfIdGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> id = sfIdGenerator.getId();</span><br></pre></td></tr></table></figure><h4 id="工具地址"><a href="#工具地址" class="headerlink" title="工具地址"></a>工具地址</h4><p>您可以在 <a href="https://github.com/YorickYu/JPP/tree/main/src/main/java/com/yy/snowflake">SFIdGenerator</a> 下载使用这个工具</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> snowflake </tag>
            
            <tag> 雪花算法 </tag>
            
            <tag> hutool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean加载图解</title>
      <link href="2020/12/31/spring-bean-and-c-d/"/>
      <url>2020/12/31/spring-bean-and-c-d/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/spring%20bean.jpg" alt="图解"></p><p>调试过程跟踪Spring项目启动</p><p>你可以在 <a href="https://github.com/YorickYu/JPP">JPP</a> 中的/circularDependency包下查看相关代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Bean 加载 </tag>
            
            <tag> Spring 循环依赖 </tag>
            
            <tag> Spring 三层缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射快查</title>
      <link href="2020/12/30/whatis-reflection-in-java/"/>
      <url>2020/12/30/whatis-reflection-in-java/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h4><p>通过Class实例获取class信息的方法称为反射 Reflection</p><h4 id="Class实例"><a href="#Class实例" class="headerlink" title="Class实例"></a>Class实例</h4><p>以String为例：</p><table><thead><tr><th>Class Instance</th></tr></thead><tbody><tr><td>name = “java.lang.String”</td></tr><tr><td>package = “java.lang”</td></tr><tr><td>super = “java.lang.Object”</td></tr><tr><td>interface = CharSequence…</td></tr><tr><td>field = value[],hash,…</td></tr><tr><td>method = indexOf()…</td></tr></tbody></table><a id="more"></a><h5 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h5><ul><li>通过 <code>class</code> 静态变量获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;String[]&gt; aClass = String[].class;</span><br></pre></td></tr></table></figure><ul><li>通过实例的 <code>getClass()</code> 方法获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Class&lt;? extends HashMap&gt; mClass = m.getClass();</span><br></pre></td></tr></table></figure><ul><li>通过完整的 <code>class</code> 类名获取，调用 <code>Class.forName()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; cClass = Class.forName(<span class="string">&quot;java.time.Clock&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; stringClass = String.class;</span><br><span class="line">String name = stringClass.getName();</span><br><span class="line">String packageName = stringClass.getPackage().getName();</span><br><span class="line">Field[] fields = stringClass.getFields(); <span class="comment">// getDeclaredFields()</span></span><br><span class="line">Method[] methods = stringClass.getMethods(); <span class="comment">// getDeclaredMethods()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NoSuchFieldException</span></span><br><span class="line">Field hashField = stringClass.getDeclaredField(<span class="string">&quot;hash&quot;</span>); <span class="comment">// getField()</span></span><br><span class="line"><span class="comment">// NoSuchMethodException</span></span><br><span class="line">Method toStringMethod = stringClass.getMethod(<span class="string">&quot;toString&quot;</span>); <span class="comment">// getDeclaredMethod()</span></span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhatisReflection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果（以String为例）：</span><br><span class="line">is interface: false</span><br><span class="line">is enum: false</span><br><span class="line">is array: <span class="keyword">false</span></span><br><span class="line">is primitive: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="Jvm动态加载"><a href="#Jvm动态加载" class="headerlink" title="Jvm动态加载"></a>Jvm动态加载</h4><p>第一次用到时才加载，根据这个特性，可以在运行时根据条件加载不同的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>声明对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h5><p>注意属性的访问级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class stdClass = Student.class;</span><br><span class="line"><span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line"><span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"><span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">Field grade;</span><br><span class="line">System.out.println(grade = stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br></pre></td></tr></table></figure><p>输出：<br>public int com.yy.reflection.WhatisReflectionField$Student.score<br>public java.lang.String com.yy.reflection.WhatisReflectionField$Person.name<br>private int com.yy.reflection.WhatisReflectionField$Student.grade</p><h5 id="Field常用方法"><a href="#Field常用方法" class="headerlink" title="Field常用方法"></a>Field常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Field grade = stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>);</span><br><span class="line">String name = grade.getName();</span><br><span class="line">Class&lt;?&gt; type = grade.getType();</span><br><span class="line"><span class="comment">// 返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</span></span><br><span class="line"><span class="keyword">int</span> modifiers = grade.getModifiers(); </span><br><span class="line"></span><br><span class="line">Modifier.isFinal(modifiers); <span class="comment">// false</span></span><br><span class="line">Modifier.isPublic(modifiers); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(modifiers); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(modifiers); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(modifiers); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="Field的get、set"><a href="#Field的get、set" class="headerlink" title="Field的get、set"></a>Field的get、set</h5><p>注意属性的访问级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// field.get(o) 获取值</span></span><br><span class="line"><span class="comment">// IllegalAccessException 因为grade是private</span></span><br><span class="line"><span class="comment">// 解决: grade.setAccessible(true); 或者 将grade更改为public</span></span><br><span class="line">grade.setAccessible(<span class="keyword">true</span>); <span class="comment">// 一律允许访问，可能会失败</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// get</span></span><br><span class="line">Object value = (<span class="keyword">int</span>)grade.get(s);</span><br><span class="line">System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">grade.set(s, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;value = &quot;</span> + s.grade);</span><br></pre></td></tr></table></figure><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><h5 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = year;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class stdClass = Student.class;</span><br><span class="line"><span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">System.out.println(stdClass.getMethod(<span class="string">&quot;setScore&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line"><span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line"><span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">Method grade;</span><br><span class="line">System.out.println(grade = stdClass.getDeclaredMethod(<span class="string">&quot;setGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br></pre></td></tr></table></figure><p>输出：<br>public int com.yy.reflection.Student.getScore(java.lang.String)<br>public java.lang.String com.yy.reflection.Person.getName()<br>private int com.yy.reflection.Student.getGrade(int)</p><h5 id="Method常用方法"><a href="#Method常用方法" class="headerlink" title="Method常用方法"></a>Method常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Method grade = stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">String methodName = grade.getName();</span><br><span class="line">Class&lt;?&gt; returnType = grade.getReturnType();</span><br><span class="line"><span class="keyword">int</span> parameterCount = grade.getParameterCount();</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = grade.getParameterTypes();</span><br><span class="line"><span class="keyword">int</span> modifiers = grade.getModifiers();</span><br><span class="line">Modifier.isFinal(modifiers);</span><br><span class="line">Modifier.isPublic(modifiers);</span><br><span class="line">Modifier.isProtected(modifiers);</span><br><span class="line">Modifier.isPrivate(modifiers);</span><br><span class="line">Modifier.isStatic(modifiers);</span><br></pre></td></tr></table></figure><h5 id="Method方法调用"><a href="#Method方法调用" class="headerlink" title="Method方法调用"></a>Method方法调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法、私有方法</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">grade.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object invoke = grade.invoke(student, <span class="number">7</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;student.grade = &quot;</span> + student.grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态</span></span><br><span class="line">Method personHelloMethod = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">personHelloMethod.invoke(<span class="keyword">new</span> Student());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Method parseInt = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">Object res = parseInt.invoke(<span class="keyword">null</span>, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;res = &quot;</span> + res);</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用无参数构造方法</span></span><br><span class="line">Person person = Person.class.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用无参数构造方法</span></span><br><span class="line">Person person = Person.class.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数构造方法</span></span><br><span class="line"><span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">System.out.println(n1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">System.out.println(n2);</span><br></pre></td></tr></table></figure><p>你可以在 <a href="https://github.com/YorickYu/JPP">JPP</a> 中的/reflection包下查看相关代码</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> Reflection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 30 串联所有单词的子串</title>
      <link href="2020/12/24/sw-findsubwords/"/>
      <url>2020/12/24/sw-findsubwords/</url>
      
        <content type="html"><![CDATA[<h5 id="LeeCode-30-串联所有单词的子串"><a href="#LeeCode-30-串联所有单词的子串" class="headerlink" title="LeeCode 30 串联所有单词的子串"></a>LeeCode 30 串联所有单词的子串</h5><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p><p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p><p> <br>示例 1：</p><p>输入：<br>  s = “barfoothefoobarman”,<br>  words = [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。</p><p>示例 2：</p><p>输入：<br>  s = “wordgoodgoodgoodbestword”,<br>  words = [“word”,”good”,”best”,”word”]<br>输出：[]</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>1 words数组是无序的，所以考虑使用 <code>HashMap</code> 存储，key为word元素，value为出现的次数<br>2 循环次数，因为数组元素是等长的，最开始考虑每次递增 <code>words[0].length()</code> 长度，但是测试用例中有一些需要案例无法通过。所以改为 <code>+=1</code>。这里是主要损耗性能的来源，应该可以想办法优化。<br>3 比对方法，每次取出一个目标子串，然后将子串按单词的长度切分遍历，分别到 <code>HashMap</code> 中查找是否存在。如果存在相应的key，则把对应的value减1。如果key本身的value就是1，那么直接把这个key删除。<br>4 最终判断 <code>HashMap</code> 的 <code>size</code> 是否为 0 即可</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// return list</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = words[<span class="number">0</span>].length(); <span class="comment">// word 等长</span></span><br><span class="line">    <span class="keyword">int</span> pin = l * words.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; pin)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        String window = s.substring(loop, pin+loop);</span><br><span class="line">        map.clear();</span><br><span class="line">        <span class="keyword">for</span> (String w:words) &#123; <span class="comment">// words map</span></span><br><span class="line">            map.put(w, map.getOrDefault(w, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; window.length(); i += l) &#123;</span><br><span class="line"></span><br><span class="line">            String fakeWord = window.substring(i, i + l);</span><br><span class="line">            Integer count = map.getOrDefault(fakeWord, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                map.put(fakeWord, --count);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                map.remove(fakeWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.size() == <span class="number">0</span>)</span><br><span class="line">            list.add(loop);</span><br><span class="line">        loop += <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span> (loop &lt; s.length() - pin + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>176 / 176 个通过测试用例<br>执行用时: 291 ms<br>内存消耗: 39.2 MB</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> LeeCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抖音面试题：是否存在无序子串</title>
      <link href="2020/12/23/sw-findsubstring/"/>
      <url>2020/12/23/sw-findsubstring/</url>
      
        <content type="html"><![CDATA[<p>题目：<br>存在一个较长的字符串a，检查a中是否包含一个较短字符串b的所有连续字符。顺序无所谓。<br>如果包含，返回字符串a中的起始下标。如果不包含返回-1。</p><p>eg：<br>输入：s1 = “abcsadefgzxcvb”   s2 = “cas”<br>输出: 2<br>解释: s1字符串中存在子串 “csa”</p><p>思路：滑动窗口<br>1 先记录b字符串字符出现次数，在count数组中<br>2 在长字符串中建立并保持一个窗口（长度与b字符串长度相等）<br>3 每当元素进入窗口时，查看count数组中有没有该元素，如果有，数量减1，如果没有，数量减1的同时，记录一个标志位。因为此时已经不满足题目的需求；元素移出窗口时，count数组中该元素的数量加1。如果数量本身小于0，那么标志位加1。<br>4 滑动过程中，如果出现标志位为0。即说明出现了满足条件的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(String s, String a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span> || a==<span class="keyword">null</span> || s.length()&lt;a.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] aim = a.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aim.length; i++) &#123; <span class="comment">// 记录 sub 字符串中的字符个数</span></span><br><span class="line">        count[aim[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M = aim.length;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> inValidTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; R &lt; M; R++) &#123; <span class="comment">// 建立窗口</span></span><br><span class="line">        <span class="keyword">if</span> (count[str[R]]-- &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            inValidTimes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; R &lt; str.length; R++) &#123; <span class="comment">// 滑动</span></span><br><span class="line">        <span class="keyword">if</span> (inValidTimes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R - M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count[str[R]]-- &lt;= <span class="number">0</span>) &#123; <span class="comment">// 窗口扩容</span></span><br><span class="line">            inValidTimes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count[str[R-M]]++ &lt; <span class="number">0</span>) &#123; <span class="comment">// 窗口收缩</span></span><br><span class="line">            inValidTimes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inValidTimes == <span class="number">0</span> ? R - M : -<span class="number">1</span>; <span class="comment">// 判断最后一个窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dynamic programming 动态规划</title>
      <link href="2020/12/21/dynamic-programming/"/>
      <url>2020/12/21/dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p>输出中.</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读ThreadLocal源码-Hash冲突、启动/探测式清理、扩容</title>
      <link href="2020/12/13/threadlocal2/"/>
      <url>2020/12/13/threadlocal2/</url>
      
        <content type="html"><![CDATA[<h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4><p>因为ThreadLocalMap中的数据其实是存在Entry[]数组中的，一个纯数组的结构能存储值的数量是非常有限的，几遍在Hash算法中使用了黄金分割，但是不可避免的还是会产生Hash冲突。<br>当插入Entry[]数组时发生Hash冲突时，会进入for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry e = tab[i]; </span><br><span class="line">    e != <span class="keyword">null</span>;</span><br><span class="line">    e = tab[i = nextIndex(i, len)]) &#123;  <span class="comment">// Hash冲突</span></span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如当前ThreadLocal计算出的下标是5，tab[5]对应的Entry不为null，则说明产生了Hash冲突。<br>进入for循环：<br>1 判断这个Entry的key是否等于传入的ThreadLocal，如果相等，替换并返回<br>2 判断这个Entry的key是否为null（说明key已经过期），开始探测式清理<br>3 循环过程中，数组下标通过 <code>nextIndex(i, len)]</code> 累加，如果发现新下标对应数组位置为空，那么会插入在新的位置</p><a id="more"></a><h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>ThreadLocalMap中的set方法，在key值计算的数组下标处元素不为null，且循环过程中遇到key已经过期的元素时会进入这个方法。</p><p>这里涉及到了探测式清除<br>总之最后方法执行的结果是，清除了过期的Entry元素，并且通过多次for循环和hash计算，让之前发生过Hash冲突的元素更靠近正确的位置。达到优化查询效率的目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要明确，方法传入的参数有3个：<br>1 当前线程中创建的一个ThreadLocal对象<br>2 需要存入的value值<br>3 在ThreadLocalMap的set方法中发生Hash冲突时，遍历找到的一个过期的Entry的下标<br><strong>这个下标处的Entry是一个过期的Entry</strong></p><p>我们逐行理解一下源码：<br>1 将传入的第三个参数（过期Entry的下标）记录在 <code>slotToExpunge</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> slotToExpunge = staleSlot;</span><br></pre></td></tr></table></figure><p>2 第一个for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">    (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">    i = prevIndex(i, len)) <span class="comment">// 循环往前</span></span><br><span class="line">    <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.1 从传入的下标位置，<strong>循环往前</strong> 遍历数组，直到发现Entry为null停止。<br>2.2 在遍历的过程中，如果发现key为null的过期元素，更新 <code>slotToExpunge</code> 的值。<br>2.3 for循环中数组下标的计算是 <code>prevIndex(i, len)</code> 方法，可以看出，如果向前遍历到下标为0时，会更新下标为 <code>len-1</code> 继续循环。停止的唯一条件是找到 <code>Entry==null</code> 才停止。</p><p>3 第二个for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = nextIndex(i, len)) &#123; <span class="comment">// 循环往后</span></span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        e.value = value;</span><br><span class="line"></span><br><span class="line">        tab[i] = tab[staleSlot];</span><br><span class="line">        tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.1 从传入的下标位置，<strong>循环往后</strong> 遍历数组，直到发现 <code>Entry==null</code> 或者 找到一个Entry的key与传入参数的ThreadLocal相同时停止。<br>3.2 如果向后遍历时发现了一个key相同的Entry，那么会先更新这个Entry的value，然后把这个Entry与此次发生Hash冲突的Entry进行交换。<br>3.3 交换完成后开始过期Entry的清理工作，清理从 <code>slotToExpunge</code> 下标开始。<br>如果 <code>slotToExpunge == staleSlot</code>，这说明在之前的两个for循环中都未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的index，即 <code>slotToExpunge = i</code><br>这个方法后面详细讲：<br><code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code></p><p>3.4 如果循环过程中没有找到相同key的Entry，会判断这个Entry是否已经过期（即 <code>k==null</code>），如果过期了，且在上面第一个for循环中没有更新过 <code>slotToExpunge</code>。那么会更新 <code>slotToExpunge</code> 的值。</p><p>4 代码执行到这里，说明在数组中没有找到key相同的Entry。<br>那么就创建一个新的Entry，替换table[stableSlot]的过期Entry。</p><p>5 最后，通过判断 <code>slotToExpunge != staleSlot</code> 可以得知除了 staleSlot 这个传入的下标以外，是否还有其他的过期Entry在数组中。如果有，则执行清理操作<br><strong>清理分为两种：<code>探测式清理</code> 和 <code>启发式清理</code></strong></p><h4 id="探测式清除"><a href="#探测式清除" class="headerlink" title="探测式清除"></a>探测式清除</h4><p>从开始位置 <strong>循环向后</strong> 探测清理过期数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程：<br>1 因为调用方法时传入的 <code>slotToExpunge</code> 就是记录过期元素下标位置的，所以进入方法用 <code>staleSlot</code> 接收这个参数，并直接将对应位置的Entry置空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">size--;</span><br></pre></td></tr></table></figure><p>2 接下去 <strong>循环向后</strong> 遍历每一个Entry，遇到 <code>key==null</code> 就置空。如果不为空就 <code>rehash</code> 获取新的数组下标，由于Entry对象插入数组的过程是向后循环找空位，所以rehash的下标肯定在当前下标之前。<br>2.1 从新下标的位置，向后遍历，如果找到空位就插入<br>2.2 如果找不到空位，最坏情况就是插入到原本的位置</p><p>3 这个方法最后会返回一个数组下标，这个下标位置的 <code>Entry</code> 为 <code>null</code>。<strong>可以理解为，数组中从入参 <code>slateSlot</code> 到出参 <code>i</code> 这个区间内的元素都完成了清理和重定位</strong>。</p><p><strong>探测式清理结束后，数组中过期的元素应该会被 <del>全部清理</del> 部分清除，而且之前发生 <code>Hash冲突</code> 的Entry元素的位置应该更接近真实hash出来的位置。提升了查找的效率</strong></p><blockquote><p>这里探测式清理并不能全部清除数组中的过期元素，而是从传入的下标清理到第一个 <code>Entry==null</code> 为止。部分清除。<br>其余的部分，需要通过 <strong>启发式清理</strong></p></blockquote><h4 id="启发式清除"><a href="#启发式清除" class="headerlink" title="启发式清除"></a>启发式清除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启发式清理需要接收两个参数：<br>1 探测式清理后返回的数字下标，这里至少保证了Hash冲突的下标至探测式清理后返回的下标这个区间无过期的Entry。<br>2 数组总长度</p><p>根据源码可以看出，启动式清理会从传入的下标 <code>i</code> 处，向后遍历。<br>如果发现过期的Entry则再次触发探测式清理，并重置 <code>n</code>。这个n是用来控制 <code>do while</code> 循环的跳出条件。<br>如果遍历过程中，连续 <code>m</code> 次没有发现过期的Entry，就可以认为数组中已经没有过期Entry了。<br>这个 <code>m</code> 的计算是 <code>n &gt;&gt;&gt;= 1</code> ，你也可以理解成是数组长度的2的几次幂。<br><strong>例如：数组长度是16，那么2^4^=16，也就是连续4次没有过期Entry，即 <code>m =  logn/log2(n为数组长度)</code></strong></p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>在 ThreadLocalMap 的 <code>set</code> 方法最后，执行完 <code>cleanSomeSlots(i, sz)</code> 启动式清理后，如果没有发现过期元素，那么说明此时数组长度进行了 <code>size++</code>。需要判断是否需要进行数组扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure><p><strong>Entry[] 数组的扩容阈值是 <code>len * 2 / 3</code>，数组长度的三分之二。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以发现，数组扩容之前会进行一次 <strong>全面的清理</strong>，直接用 <code>fori</code> 全部遍历数组中的每一个元素，如果发现过期的Entry就进行探测式清理。</p><p>全面清理结束之后，会进一步判断数组的长度是否满足 <code>size &gt;= threshold - threshold / 4</code>，也就是说，扩容前真正的阈值判断是 <code>len * 2/3 * 3/4</code>，也就是阈值真正的值是 <strong>数组长度的1/2</strong>。是两个步骤计算出来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次扩容会将数组长度扩容至原来的2倍，然后遍历老数组，将老数组中的元素重新计算下标，并插入新数组。<br>插入时如果发生Hash冲突，那就向后遍历寻找空位。这个遍历的过程和探测式清理中有点类似。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>阅读过程中发现ThreadLocal的源码远比我想想的要复杂的多得多，关于Hash冲突、数组清理机制、扩容机制的逻辑非常复杂。而且我只是根据源码逐行理解了大概的思路。具体的流程我也没有通过Demo去调试代码。</strong></p><p><strong>不过阅读ThreadLocal的源码的收获还是很大的。原来数组这种数据结构还可以通过这种方式解决Hash冲突的问题。</strong></p><p><strong>也给实际开发中，处理并发安全问题时提供了多一种解决方案。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash冲突 </tag>
            
            <tag> 数组扩容 </tag>
            
            <tag> 启动式清理 </tag>
            
            <tag> 探测式清理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动装箱和拆箱的发生场景</title>
      <link href="2020/12/12/java-boxing-unboxing/"/>
      <url>2020/12/12/java-boxing-unboxing/</url>
      
        <content type="html"><![CDATA[<h3 id="自动装箱拆箱的常见使用场景"><a href="#自动装箱拆箱的常见使用场景" class="headerlink" title="自动装箱拆箱的常见使用场景"></a>自动装箱拆箱的常见使用场景</h3><ul><li>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</li><li>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</li></ul><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 10;  &#x2F;&#x2F;自动装箱</span><br><span class="line">int b &#x3D; a;      &#x2F;&#x2F;自动拆箱</span><br></pre></td></tr></table></figure><p>我在JDK1.8环境下，反编译结果与原代码没有差别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 10;</span><br><span class="line">int b &#x3D; a;</span><br></pre></td></tr></table></figure><p>阿里手册中提到反编译的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a&#x3D;Integer.valueOf(10); </span><br><span class="line">int i&#x3D;a.intValue(); </span><br></pre></td></tr></table></figure><p>说明自动装箱底层实际是 <code>Integer.valueOf()</code> ，自动拆箱底层实际是 <code>a.intVakue()</code></p><a id="more"></a><h4 id="1-将基本数据类型放入集合类"><a href="#1-将基本数据类型放入集合类" class="headerlink" title="1 将基本数据类型放入集合类"></a>1 将基本数据类型放入集合类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">list.add(1);</span><br></pre></td></tr></table></figure><p>首先，List中只能接收对象类型。其次，上面代码声明List<Integer>也指定的存储Integer类型。上面代码 <code>list.add(1)</code> </p><h4 id="2-对象类型和基本数据类型比较判断和运算"><a href="#2-对象类型和基本数据类型比较判断和运算" class="headerlink" title="2 对象类型和基本数据类型比较判断和运算"></a>2 对象类型和基本数据类型比较判断和运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D;10;  &#x2F;&#x2F;自动装箱</span><br><span class="line">int b &#x3D; a;      &#x2F;&#x2F;自动拆箱</span><br><span class="line">if (a &gt; 10) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    int c &#x3D; a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-三目运算符的使用"><a href="#3-三目运算符的使用" class="headerlink" title="3 三目运算符的使用"></a>3 三目运算符的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; 0;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">int k &#x3D; flag ? i : j;</span><br></pre></td></tr></table></figure><p>上面这段代码反编译的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; 0;</span><br><span class="line">int j &#x3D; true;</span><br><span class="line">if (flag) &#123;</span><br><span class="line">    i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，程序写到这里，编译器根本无法推断变量 k 的类型。</p><p>但是对原代码稍作修改，就可以准确的推断出 k 是 int类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; 0;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">int k &#x3D; flag ? i : j;</span><br><span class="line">System.out.println(&quot;k &#x3D; &quot; + k);</span><br></pre></td></tr></table></figure><p>上面的代码会将 Integer类型的i自动拆箱为int类型，赋值给k</p><p><strong>三目运算符因为这一特性，有可能会发生空指针异常，稍微修改下上面的代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean flag &#x3D; true;</span><br><span class="line">Integer i &#x3D; null;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">int k &#x3D; flag ? i : j;</span><br><span class="line">System.out.println(&quot;k &#x3D; &quot; + k);</span><br></pre></td></tr></table></figure><p>这里在自动拆箱时会出现NPE</p><blockquote><p>这个问题被收录在阿里开发手册中：<a href="https://www.hollischuang.com/archives/435">自动拆箱导致空指针异常</a></p></blockquote><h4 id="4-函数入参和返回值"><a href="#4-函数入参和返回值" class="headerlink" title="4 函数入参和返回值"></a>4 函数入参和返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自动拆箱</span><br><span class="line">public int unboxing(Integer num) &#123;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;自动装箱</span><br><span class="line">public Integer boxing(int num) &#123;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-自动拆箱时的临界值问题"><a href="#5-自动拆箱时的临界值问题" class="headerlink" title="5 自动拆箱时的临界值问题"></a>5 自动拆箱时的临界值问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 &#x3D; 129; &#x2F;&#x2F; 自动装箱</span><br><span class="line">Integer integer2 &#x3D; 129;</span><br><span class="line"></span><br><span class="line">if (integer1 &#x3D;&#x3D; integer2)</span><br><span class="line">    System.out.println(&quot;integer1 &#x3D;&#x3D; integer2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;integer1 !&#x3D; integer2&quot;);</span><br><span class="line"></span><br><span class="line">if (integer1.equals(integer2))</span><br><span class="line">    System.out.println(&quot;integer1 &#x3D;&#x3D; integer2&quot;);</span><br><span class="line">else</span><br><span class="line">    System.out.println(&quot;integer1 !&#x3D; integer2&quot;);</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">结果：</span><br><span class="line">integer1 !&#x3D; integer2</span><br><span class="line">integer1 &#x3D;&#x3D; integer2</span><br></pre></td></tr></table></figure><p>1 数字赋值给Integer对象时自动装箱<br>2 两值的 <code>==</code> 符号判断会进行自动拆箱<br>同<font color=black> <a href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E5%88%A4%E6%96%AD%E5%92%8C%E8%BF%90%E7%AE%97">2.对象类型和基本数据类型比较判断和运算</a> </font></p><blockquote><p>这里涉及到一个 <a href="https://www.hollischuang.com/archives/1174">[译]Java中整型的缓存机制</a> 的知识</p></blockquote><blockquote><p>大概意思就是：<br>如果数字在-128至127之间时，相同数字自动装箱给不同的对象类型会直接使用缓存中的对象，而不是重新创建一个对象。<br>然而上面代码中129超过了这个区间，所以拆箱判断时不等于。<br>Byte, Short, Long有固定范围: -128 到 127。对于Character, 范围是 0 到 127。除了Integer以外，这个范围都不能改变。</p></blockquote><h3 id="需要理清的事情"><a href="#需要理清的事情" class="headerlink" title="需要理清的事情"></a>需要理清的事情</h3><p>自动装箱和拆箱非常好用，但是有底层需要了解的事情不能丢：</p><p>1 基本数据类型存储在栈中，对象类型创建在堆中</p><p>2 因为Java的面向对象特性，所以出现了8大基本数据类型的包装对象类型</p><p>3 自动装箱拆箱是JDK1.5之后引入的</p><p>4 自动拆箱时注意null处理，不然会抛NPE异常</p><p>5 循环中尽量使用基本数据类型，相比大量的拆装箱操作跟节省资源</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> boxing </tag>
            
            <tag> unboxing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CODING EVERYDAY</title>
      <link href="2020/12/11/Ryan-Dahl/"/>
      <url>2020/12/11/Ryan-Dahl/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ryan%20dahl.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读ThreadLocal源码-基础部分</title>
      <link href="2020/12/10/threadlocal/"/>
      <url>2020/12/10/threadlocal/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新于：2020-12-14 22:25 内容补充</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>起初了解 <code>ThreadLocal</code> 这个类还是从阿里手册的一篇文章过来的。他的源码中通篇没有一个<code>lock</code>、也没有出现 <code> synchronized</code> 关键字。但是他却利用一些巧妙的方法保证了并发下数据的安全。</p><p>带着下面这几个问题尝试着从 <code>ThreadLocal</code> 的源码中找找答案？</p><p>1 ThreadLocal 和 Thread 有什么联系？<br>2 ThreadLocal 底层的数据结构是什么？<br>3 ThreadLocal 存储数据有没有大小限制？<br>4 什么情况下 ThreadLocal 会发生内存泄漏？<br>5 已知 Entry 继承于 WeakReference，那么GC内存回收时会不会导致存储的内容丢失？<br>6 Entry[] 数组发生Hash冲突如何解决？<br>7 如何清理陈旧的Entry对象？何时清理？<br>8 ThreadLocalMap中数组扩容机制？几个步骤？阈值到底是多少？</p><a id="more"></a><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/threadlocal.png"></p><p>1 每个Thread线程中都有一个threadlocals属性，他的类型是ThreadLocal.ThreadLocalMap<br>2 ThreadLocalMap是ThreadLocal的静态内部类，被ThreadLocal类管理<br>3 ThreadLocalMap底层的数据结构是一个弱引用的数组Entry[]<br>4 Entry继承于WeakReference，在这里可以简单的理解成他是一个key-value的形式</p><blockquote><p>他的‘key’就是ThreadLocal对象，value就是我们需要保存的值<br>但是Entry实际是一个Reference，将‘key’保存在referent引用中</p></blockquote><blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ThreadLocal-entry.png"></p></blockquote><p><strong>此外，在源码调试过程中，我有两个疑问没得到解答：</strong><br>1 为什么我们不能直接像Thread类中那样创建ThreadLocalMap的对象？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap map &#x3D; null; &#x2F;&#x2F; 编译不通过</span><br></pre></td></tr></table></figure><p>2 程序启动时会默认在主线程的threadlocals中添加几个值？一个Object和两个软引用？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/threadloacl-defaultvalues.png"></p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>简单看下ThreadLocal中的 <code>set</code>，<code>get</code>，<code>remove</code> 方法<br>方法本身也比较简单，思路就是通过ThreadLocal的方法来关联 Thread类 和 ThreadLocalMap类</p><blockquote><p>你也许会问：为什么Thread不自己管理ThreadLocalMap呢？<br>这是一个比较巧妙的设计，上面也讲过 ThreadLocalMap 中的数据结构是 Entry[] 数组，数组中每个Entry可以理解成一个key-value键值对。<br>首先，ThreadLocal将自身this指针作为Entry的key。其次，Entry是一个弱引用对象，这样用户只需要控制ThreadLocal对象就可以回收保存的value值了。（这个说法不严禁，后面再补充）</p></blockquote><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单，需要注意的是，ThreadLocalMap是在这个方法中创建的。</p><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释下 <code>@SuppressWarnings(&quot;unchecked&quot;)</code> 是做什么的？<br>简单来说就是让编译器忽略 泛型T 产生的警告。告诉编译器这个写法是合法的。<br>可以通过 <a href="https://stackoverflow.com/questions/1129795/what-is-suppresswarnings-unchecked-in-java">What is SuppressWarnings (“unchecked”) in Java?</a> 了解更多</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">if (m !&#x3D; null)</span><br><span class="line">m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="threadLocalHashCode"><a href="#threadLocalHashCode" class="headerlink" title="threadLocalHashCode"></a>threadLocalHashCode</h5><p>因为ThreadLocal将自身作为Entry的key保存<br>这个threadLocalHashCode仅用于在Entry[]数组中计算下标使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private final int threadLocalHashCode &#x3D; nextHashCode();</span><br><span class="line"></span><br><span class="line">private static AtomicInteger nextHashCode &#x3D; new AtomicInteger();</span><br><span class="line"></span><br><span class="line">private static final int HASH_INCREMENT &#x3D; 0x61c88647;</span><br><span class="line"></span><br><span class="line">private static int nextHashCode() &#123;</span><br><span class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLocalHashCode的产生是由一个 <code>AtomicInteger</code> 对象每次累加一个 <code>HASH_INCREMENT</code> 的值得出。<br>这个值很特殊，它是 <a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><strong>斐波那契数</strong></a> 也叫 黄金分割数。<br>大概的作用就是尽量避免Hash冲突。</p><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>上面也提到过，ThreadLocal主要是用来联系Thread类和管理ThreadLocalMap的。<br>所以关键的代码都是在ThreadLocalMap中</p><h5 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t use a fast path as with get() because it is at</span><br><span class="line">    &#x2F;&#x2F; least as common to use set() to create new entries as</span><br><span class="line">    &#x2F;&#x2F; it is to replace existing ones, in which case, a fast</span><br><span class="line">    &#x2F;&#x2F; path would fail more often than not.</span><br><span class="line"></span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (len-1); &#x2F;&#x2F; 通过ThreadLocal的threadLocalHashCode计算下标</span><br><span class="line"></span><br><span class="line">    for (Entry e &#x3D; tab[i]; </span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;  &#x2F;&#x2F; Hash冲突</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] &#x3D; new Entry(key, value);</span><br><span class="line">    int sz &#x3D; ++size;</span><br><span class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;&#x3D; threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 这个方法的最开始，有一段注释，提到一个 <code>fast path</code> 的概念。<br>大概的意思就是，通常我们定义的 <code>set</code> 方法都类似于：<code>public void setA(int a) &#123;    this.a = a; &#125;</code><br>但是这里的set方法需要传入key和value两个值。<br>我能理解注释的前半段，因为与以往的set方法不同，这里传入的ThreadLocal作为key，需要进行数组下标的计算等等。<br>但是后半段注释中 <code>a fast path would fail more often than not</code> 提到的这种写法失败概率更低我并不是很理解。<br>这个疑惑我也在 <a href="https://github.com/YorickYu/IHAVEAQUESTION">I HAVE A QUESTION</a> 中的第11个问题中指出，希望有大神看到可以发个 <code>Issues</code> 告知一下。感激不尽</p><p>2 通过ThreadLocal的threadLocalHashCode计算下标，使用按位与的方法提升效率</p><p>3 for循环，这个for循环做了几件事：<br>3.1 判断数组中原本要插入的下标位置是否为null，如果不为空则进入循环<br>3.2 循环中通过 Entry的get()方法 获取Entry对象中的key-ThreadLocal 对象，命名为 k<br>3.3 如果这次传入的ThreadLocal与k相等，那么替换value并返回<br>3.4 如果k为null，则调用 <code>replaceStaleEntry(key, value, i);</code> 方法（<strong>这里说明原本存在这个位置的Entry中的key-ThreadLocal已经被系统GC，会触发探测式清理</strong>）<br>3.5 如果这个k即不是传入的ThreadLocal，又不是null，那么会通过 <code>nextIndex(i, len)</code> 方法继续循环寻找下一个下标（<strong>如果遍历过程中，在找到相同的key或者key为null的情况之前，找到Entry[]数组中对应的下标是空的，那么带着新的下标跳出循环，创建一个Entry对象，插入在这里。这里说明发生了Hash冲突</strong>）</p><p>4 如果方法执行到这里，说明Entry[]数组中对应的下标是空的，那么直接创建一个 Entry对象插入即可（这里插入的下标有可能在上面的for循环中发生了改变）</p><p>5 清理 &amp; 扩容，<code>threshold = len * 2 / 3;</code> </p><blockquote><p>这里会先进行 <code>cleanSomeSlots(i, sz) </code> 启发式清理。</p></blockquote><p><strong>上面出现了几个概念：探测式清理、启发式清理和Hash冲突。这些过程较为复杂，放在下一篇详细介绍</strong><br>总之，这个set方法返回时，已经完成了value的插入。</p><h5 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</span><br><span class="line">    int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);</span><br><span class="line">    Entry e &#x3D; table[i];</span><br><span class="line">    if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)</span><br><span class="line">        return e;</span><br><span class="line">    else</span><br><span class="line">        return getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line"></span><br><span class="line">    while (e !&#x3D; null) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line">        if (k &#x3D;&#x3D; key)</span><br><span class="line">            return e;</span><br><span class="line">        if (k &#x3D;&#x3D; null)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        else</span><br><span class="line">            i &#x3D; nextIndex(i, len);</span><br><span class="line">        e &#x3D; tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Entry不为空，并且Entry对象中的key就是获取的ThreadLocal key，那么就返回。<br>反之，就调用 <code>getEntryAfterMiss(key, i, e);</code> 方法，这个方法中有一个while循环，思路和上面set方法中的for循环差不多。</p><p>当遍历发现数组中的Entry元素有key==null时，进入探测式循环</p><h5 id="Entry中的key为什么会变为null？"><a href="#Entry中的key为什么会变为null？" class="headerlink" title="Entry中的key为什么会变为null？"></a>Entry中的key为什么会变为null？</h5><p>我们都知道，ThreadLocalMap底层的数据结构是Entry[]数组，Entry是弱引用类型的对象。</p><blockquote><p>这里关于Java的对象的引用类型不做展开了，分为 <code>强引用</code>、<code>软引用</code>、<code>弱引用</code>、<code>虚引用</code>。<br>弱引用使用WeakReference修饰，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/threadlocal-weak.png"><br>他们得引用关系如图所示</p><p>这里需要满足2个条件，Entry中的key就会变为null<br>1 在当前线程中失去了对ThreadLocal对象的强引用<br>2 发生了GC内存回收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ThreadLocal&lt;&gt;().set(&quot;be GC&quot;);</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8 &#x3D; &#123;ThreadLocal$ThreadLocalMap$Entry@512&#125; </span><br><span class="line">    value &#x3D; &quot;be GC&quot;</span><br><span class="line">    referent &#x3D; null</span><br><span class="line">    queue &#x3D; &#123;ReferenceQueue$Null@515&#125; </span><br><span class="line">    next &#x3D; &#123;ThreadLocal$ThreadLocalMap$Entry@512&#125; </span><br><span class="line">    discovered &#x3D; null</span><br></pre></td></tr></table></figure><p>从上面这个例子可以看出，由于 <code>new ThreadLocal&lt;&gt;().set(&quot;be GC&quot;);</code> 这种创建方式，不会再栈中保存一个ThreadLocal的强引用，所以当系统发生GC时，这个Entry的key就会被回收变成null</p><hr><p>下一篇详细看一下关于ThreadLocal的Hash冲突、探测式清理、启动时清理的源码</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thread </tag>
            
            <tag> WeakReference </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的tomcat为什么启不起来？</title>
      <link href="2020/12/09/how-to-checkout-running-port/"/>
      <url>2020/12/09/how-to-checkout-running-port/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在测试服务器的使用过程，由于大家的使用没有非常规范，所以经常会出现服务启动不起来的问题。这类问题的产生经常是因为你配置的服务端口号被其他程序占用了。</p><p>那么如何定位一台服务器中端口的使用情况呢？这里推荐两个非常好用的命令</p><h4 id="查看正在使用的端口"><a href="#查看正在使用的端口" class="headerlink" title="查看正在使用的端口"></a>查看正在使用的端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnlp   </span><br></pre></td></tr></table></figure><blockquote><p>-t : 指明显示TCP端口<br>-u : 指明显示UDP端口<br>-l : 显示监听套接字<br>-p : 显示进程标识符和程序名称，每一个套接字都属于一个程序<br>-n : 不进行DNS轮询，显示IP(可以加速操作)<br>-a : 显示全部（包括ESTABLISHED）</p></blockquote><p>套接字就是socket，表示一对IP/PORT的组合。每个套接字对应一个PID，相当于给一个应用程序赋予了收发通讯协议的能力<br>网关，用于匹配目标IP于掩码的与运算结果，网络层完成，寻找下一跳<br>这里关于套接字和网关的信息不展开，等我完全理解以后可能会整理一篇博客</p><p>这里 <code>-u</code> 不是很常用。</p><p>查询结果以我自己的一台服务器为例：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/netstat.jpg"></p><blockquote><p>上图中本地地址和远端地址的组合对应一个PID，其中本地地址和远端地址的组合就是一个socket。多个socket指向同一个PID，就是多路复用。</p></blockquote><p>上图中本地地址 <code>Local Address</code> 一栏中显示出了目前所有正在监听的端口号。</p><p>以tomcat为例，从最右侧 <code>Program name</code> 为 java 的就是 tomcat。因为它是由 java 开发的一款 servlet 容器。</p><p>通常可以通过 <code>jps</code> 命令查看tomcat的PID。名称为 Bootstrap 。</p><blockquote><p>为什么 tomcat 启动叫 Bootstrap？给大家留个问题，答案在/bin/startup.sh 和 /bin/catalina.sh 中</p></blockquote><p>从上面的图可以看出，我这台机器的tomcat占用了两个端口：8005和8080，前者是用来监听SHUTDOWN指令的。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这篇博客没有太多内容，就是分享一个好用的命令行工具，便于大家查看服务器中已经占用的端口号。这样在配置新服务的过程中可以避免因为端口被占用而浪费时间。</p><p>文章中途有一些发散的知识和问题，都是跟网络编程相关的。等我学习完成后再输出。</p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ps </tag>
            
            <tag> netstat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说我对happens-before原则和as-if-serial语义的理解</title>
      <link href="2020/12/07/whatis-happensbefore/"/>
      <url>2020/12/07/whatis-happensbefore/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于 happens-before原则 和 as-if-serial语义 到底是什么意思？为什么会出现？解决什么问题？简短的说下我自己的理解</p><h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>如果单一线程中操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序</p><p>这个重排序的过程并不会影响程序运行的结果，对程序员来说是无感的。所以叫做 as-if-serial “看上去像是连续的”</p><blockquote><p>证明重排序的存在：<a href="https://yloopdaed.icu/2020/10/19/CPU-Out-of-Order/">CPU 乱序执行反证</a></p></blockquote><h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><p>JMM中定义的 跨线程内存可见性的规则：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果 A happens-before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的</p><blockquote><p>JMM：Java内存模型(Java Memory Model)<br>屏蔽掉不同硬件和操作系统的内存模型差异，以实现让Java程序在各种平台下都能达到一致的内存访问结果。所以对于Java程序员，无需了解底层硬件和操作系统内存模型的知识，只要关注Java自己的内存模型，就能够解决Java语言中的内存可见性问题了</p></blockquote><h4 id="为什么会出现？"><a href="#为什么会出现？" class="headerlink" title="为什么会出现？"></a>为什么会出现？</h4><p>因为 CPU缓存和重排序 可能会在多线程并发时导致程序执行结果与程序员代码的执行语义不符</p><p><strong>所以JMM定义了一套规则，CPU重排序时需要遵守这些规则</strong></p><p><strong>这些规则可以指导程序员写出正确的代码，让程序正确执行</strong></p><h4 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h4><p>共有8项：<br>1 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>2 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>3 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>4 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。<br>5 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。<br>6 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>7 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。<br>8 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>可以理解为：<br>1 as-if-serial，单线程程序是按程序的顺序来执行的（可能发生指令重排序，但是程序员无感知）<br>2 happens-before，**<em>正确同步**</em>的多线程程序是按执行顺序执行的（正确同步的操作需要程序员完成）<br>3 as-if-serial语义和happens-before原则，都是为了在不改变程序执行结果的前提下，尽可能地提高程序的执行效率</p><p>参考：<br><a href="https://blog.csdn.net/ThinkWon/article/details/102074107?utm_medium=distribute.pc_relevant_download.none-task-blog-searchFromBaidu-1.nonecase&depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-searchFromBaidu-1.nonecas">as-if-serial规则和happens-before规则的区别</a><br><a href="https://segmentfault.com/a/1190000011458941">从Java多线程可见性谈Happens-Before原则</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> happens-before </tag>
            
            <tag> as-if-serial </tag>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thread.interrupt() 线程中断</title>
      <link href="2020/11/30/interrupt/"/>
      <url>2020/11/30/interrupt/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。<br>所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p><p>具体来说，当对一个线程，调用 interrupt() 时，<br>① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。<br>② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。</p><p>interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。<br>① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。<br>② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        <span class="comment">// do more work.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间以后</span></span><br><span class="line">thread.interrupt();</span><br></pre></td></tr></table></figure><p>具体到你的问题，Thread.interrupted()清除标志位是为了下次继续检测标志位。<br>如果一个线程被设置中断标志后，选择结束线程那么自然不存在下次的问题<br>如果一个线程被设置中断标识后，进行了一些处理后选择继续进行任务<br>而且这个任务也是需要被中断的，那么当然需要清除标志位了。</p><p>以上内容摘自：<a href="https://www.zhihu.com/question/41048032/answer/89431513">Intopass在知乎的回答</a></p><h4 id="thread-interrupt-thread-isInterrupted-Thread-interrupted-三者区别"><a href="#thread-interrupt-thread-isInterrupted-Thread-interrupted-三者区别" class="headerlink" title="thread.interrupt()\thread.isInterrupted()\Thread.interrupted() 三者区别"></a>thread.interrupt()\thread.isInterrupted()\Thread.interrupted() 三者区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// while 循环</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123; <span class="comment">// true -&gt; Thread.interrupted()重置为false</span></span><br><span class="line">                System.err.println(<span class="string">&quot;线程中断&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(thread.isInterrupted()); <span class="comment">// false</span></span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">thread.interrupt(); <span class="comment">// 中断 thread</span></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">System.out.println(thread.isInterrupted()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读AQS源码（countdownlatch await）</title>
      <link href="2020/11/30/AQS-countdownlatch/"/>
      <url>2020/11/30/AQS-countdownlatch/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>CountDownLatch 也是 JUC 包中提供的。<br>它的作用是可以让多个线程阻塞。是共享锁的一种体现</p><p>本篇记录一下 CountDownLatch 的源码阅读过程，记录一下，方便以后复习</p><a id="more"></a><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/CountDownLatch-structure.png" alt="CountDownLatch"></p><h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// await() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// countDown() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>创建 CountDownLatch 时需要指定一个大于零的整数，用于计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个传入的正整数会被记录在AQS的state中，保证了多线程并发情况下的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总的来说，CountDownLatch 的构造方法就是为 state 赋值。</strong></p><h5 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h5><p>使当前线程一直等待，直到latch的state减为0。<br><strong>除非其他线程中断了此线程，那么会打断等待，抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://yloopdaed.icu/2020/11/30/interrupt/">thread.interrupt() 线程中断</a></p><p>这个方法被 await() 方法调用<br>首先判断线程是否被其他线程中断，如果中断直接抛出异常并返回<br>其次调用 <code>tryAcquireShared(arg)</code> 方法判断当前state是否为0<br>如果返回0，则结束该方法，程序正常执行。<br>如果返回-1，则说明当前线程需要 <strong>入队并阻塞</strong>。</p><blockquote><p>这里为什么方法名中都有一个shard（共享）？先带着这个问题往下看</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="comment">// Thread.interrupted()会重置标志位</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取state的值并判断，如果state为0，则方法返回1，否则返回-1<br><strong>注意：这个方法的入参 <code>int acquires</code> 是没用的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doAcquireSharedInterruptibly(1)这个方法和 reentrantLock.lock() 中的 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</code> 加锁方法非常相似。</strong></p><p>重要的区别有两处：<br>1 reentrantLock.lock() 不能响应 interrupt() 中断<br>2 假如在自旋的时候锁被释放了，reentrantLock 会判断AQS队列中是否有其他线程等待，而countDownLatch 可以直接返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 判断state是否为0</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 1 </span></span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 入队<br>这个方法会通过当前线程创建一个Node并加入AQS队列<br>具体过程参考 <a href="https://yloopdaed.icu/2020/11/29/AQS-reentrantlock/">尝试阅读AQS源码（ReentrantLock 加锁）</a></p><p><strong>区别在于这里创建的 Node 是 <code>Node.SHARED</code> 共享模式！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 已经初始化，追加 node</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 队列没有初始化，去初始化</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 阻塞线程<br>这里的逻辑都和 <a href="https://yloopdaed.icu/2020/11/29/AQS-reentrantlock/">尝试阅读AQS源码（ReentrantLock 加锁）</a> 相同<br>如果程序运行到这里，那么该线程会阻塞在这里。并且记录该线程的Node会记录在AQS队列中等待唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())    </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure><hr><blockquote><p>上面的内容都比较容易理解<br>个人认为 CountDownLatch 源码中比较难得部分是下面 <code>setHeadAndPropagate()</code> 方法。</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-countdownlatch.jpg" alt="流程"></p><p><strong>假如自旋过程中 state 被改为 0，那么会执行 <code>setHeadAndPropagate()</code> 方法。重新设置AQS队列的head并传播。</strong></p><blockquote><p>什么叫传播？<br>因为对于 countDownLatch.await() 的加锁而言。无论当前有多少个线程阻塞，无论AQS队列中有多少个线程等待。一旦 state==0，那么所有的线程都可以返回并继续执行程序。</p><p><strong>之前提到的为什么源码中有很多方法命名中带有 <code>shared</code> 可能就是这个原因。包括上面创建Node入队时，创建的NodeSHARED共享模式的</strong></p></blockquote><p>首先，进入这个方法。说明state已经为0，那么通过 <code>setHead(node)</code> 方法将AQS的Head指向这个node（head = node;），并且将node的thread和prev都置null（node.thread = null;node.prev = null;）。<br>其次，因为state=0，所以传入这个方法的 propagate 参数为1。此时无论当前这个node的下一个节点有没有元素。都会继续执行 <code>doReleaseShared()</code> 这个方法去 <strong>唤起阻塞的线程</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// state == 0 时，传入的propagate为1</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果node没有下一个节点，或者node本身是共享模式，那么执行 doReleaseShared()</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的目的就是唤起阻塞的线程，这里也有自旋操作<br>1 假如此时head==tail，那么说明当前线程刚创建node，在自旋时state就被countDown为0了。此时当前线程还没有执行park阻塞。所以直接break返回即可<br>2 假如此时AQS队列中不止一个node，那么就要判断AQS的head的waitStatus。假如等于-1，说明这些node对应的线程已经在阻塞状态，那么调用 <code>unparkSuccessor(h)</code> 循环唤起AQS队列中的每一个线程即可<br><strong>3 假如此时AQS队列中不止一个node，而且AQS的head的waitStatus等于0（或者上面第2点运行完成后，waitStatus也等于0），那么这里会CAS把waitStatus改为-3（Node.PROPAGATE）并退出循环</strong></p><blockquote><p><strong>上面的第3点，我并不是特别清楚最后将AQS的Head节点对应的node中的waitStatus标记成-3是什么用意</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head; <span class="comment">// 获取AQS队列的head节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; </span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; <span class="comment">// 获取head的waitStatus</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 如果ws == -1</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果ws==0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS队列的tail循环向前移动，取出node，释放被阻塞的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在阅读 CountDownLatch 源码之前先看了 ReentrantLock 的源码。对 AQS队列的相关知识有了一些了解<br>本以为可以比较容易的完成阅读，但是 CountDownLatch 中自旋时的操作真的非常复杂和巧妙<br>与 ReentrantLock 不同的是，ReentrantLock 中的锁只能同一时间被一个线程占有。所以只需要查看队列中的排队顺序即可。<br>但是 CountDownLatch 中阻塞的线程会在 state 被置为 0 时同时释放。而且无论如何AQS都在工作。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> AQS </tag>
            
            <tag> countdownlatch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试阅读AQS源码（ReentrantLock 加锁）</title>
      <link href="2020/11/29/AQS-reentrantlock/"/>
      <url>2020/11/29/AQS-reentrantlock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更新于：2020-12-14 22:47 调整排版，提升阅读感受</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>尝试通过 reentrantLock.Lock() 加锁部分阅读 AQS 源码。</p><p>博客的形式展现源码其实非常苦难：</p><p>1 代码之间很难建立跳转的关系，从而增加阅读的难度。</p><p>2 然后流程图又只能梳理代码运行的大致流程，很难反映代码执行的过程。</p><p>况且我个人对于源码的理解也没有非常深入。只是通过阅读和调试的过程把大概的思路整理一下，分享出来</p><a id="more"></a><h4 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h4><p>结构：ReentrantLock中有三个内部类和一个Sync属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/RL-structure.png" alt="structure"></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>ReentrantLock是公平锁还是非公平锁？<br>取决于你如何初始化，默认是非公平锁，可以给构造方法传入true创建公平锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lock方法"><a href="#Lock方法" class="headerlink" title="Lock方法"></a>Lock方法</h4><h5 id="公平锁流程"><a href="#公平锁流程" class="headerlink" title="公平锁流程"></a>公平锁流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 公平锁继承于Sync，Sync继承于AQS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 acquire() 方法在 AbstractQueuedSynchronizer 中<br>首先调用 tryAcquire() 方法尝试获取锁</p><p>3 state值的判断流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 如果state</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; </span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 判断有无其他线程等待</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-tryAcquire.png" alt="tryAcquire流程"></p><p>根据state是否为0，判断锁是否空闲<br>    1. 如果锁空闲，要继续看AQS队列里有没有其他线程等待<br>        1.1 没有其他线程等待，那么获取锁，修改state值，方法返回 true<br>        1.2 有其他线程等待，方法返回 false<br>    2 如果锁不空闲，要看获取锁的线程是不是当前线程<br>        2.1 如果是，重入，方法返回 true<br>        2.2 如果不是，方法返回 false</p><p><strong>总结：</strong><br>tryAcquire() 方法中有一个state值的判断<br>如果 state == 0，说明目前这个锁处于空闲状态，那么进一步判断AQS队列中是否有前置线程等待，如果没有前置线程，那么当前线程可以成功获取锁<br>如果 state != 0，说明目前这个锁被某线程占中，那么进一步判断占用这个锁的线程是不是当前线程，如果是，<strong>可重入</strong>。如果不是则方法返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断AQS队列中是否有其他线程等待（这个方法先不展开，后面会详细讲）<br>先了解如果没有其他线程等待，返回fasle。那么 tryAcquire() 方法中就可以获得锁<br><code>((s = h.next) == null || s.thread != Thread.currentThread())</code> 后面分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AbstractQueuedSynchronizer 类中对 unsafe 类方法进行了一次封装<br>这里 unsafe.compareAndSwapInt() 方法就是 CAS ，这个方法在汇编层面保证了原子性调用 <code>LOCK_IF_MP(mp) lock cmpxchg </code> 是CPU可以识别的指令，保证了多线程同步执行</p><p>最后，当 tryAcquire() 返回true时，那么当前线程会成功获取锁并继续执行代码<br>如果返回 false，那么说明锁当前被持有，或者仍有其他线程在等待。这两种情况下面会详细分析</p><h5 id="非公平锁流程"><a href="#非公平锁流程" class="headerlink" title="非公平锁流程"></a>非公平锁流程</h5><p>非公平锁就是在上面公平锁流程之前，判断一步当前线程是否空闲，如果空闲则直接抢占。不用管是否有其他线程在AQS队列中等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>截止到这里，我们可以得出一个结论：<br><strong>假如在单线程或者多线程同步执行的情况下，ReentrantLock的执行效率非常高，JDK层面解决。<br>所以在项目中如果你的并发量不高，也可以放心使用 ReentrantLock。</strong></p></blockquote><hr><h5 id="复杂场景加锁流程"><a href="#复杂场景加锁流程" class="headerlink" title="复杂场景加锁流程"></a>复杂场景加锁流程</h5><p>如果现在的情况是多线程并发执行，那么ReentrantLock的执行过程又是怎么的呢？</p><p>根据上面的分析可知，如果是多线程并发执行，那么 tryAquire() 方法的返回值是 false，那么会继续调用<br><code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 方法 <strong>入队</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中 Node 对象中的关键属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">// 如果AQS队列 tail 不为空，则追加 node</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// AQS队列 tail 为空，初始化队列</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过当前线程创建一个新的 Node 并入队。新 Node 的 nextWaiter=Node.EXCLUSIVE=null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t; <span class="comment">// 入队</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化队列时会进行自旋操作<br>第一次循环，先创建一个空的 node，让AQS队列的 head 和 tail 都指向他。空node成为AQS队列的第一个元素<br>第二次循环，将先前创建的 node 追加在刚刚创建的 空node 后面，并跳出循环。此时AQS队列中有两个元素排队<br>最后将新创建的 node 返回<br>注意：AQS队列的 head 指向的 Node 中的 thread 永远为 null : <code>compareAndSetHead(new Node())</code></p><h6 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h6><p>尝试拿锁 | 阻塞线程<br>运行到这里时，AQS队列中有两个node元素。第一个node的 thread 为 null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果当前这个node为AQS的head，那么tryAcquire(arg)尝试拿锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 阻塞</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自旋操作<br>首先，取出传入node的 prev指向的node，判断这个node是否是AQS队列的head<br>如果是，则调用先前讲到的 tryAcquire() 方法尝试拿锁。（因为此时传入的node已经排在AQS队列的第二位，第一位是thread=null）<br>如果不是，则调用 shouldParkAfterFailedAcquire(p, node) 方法阻塞当前线程（这里用到了自旋）</p><p><strong>调用 tryAcquire() 方法尝试拿锁时，如果锁的状态恰好是空闲（state==0）的话，就会涉及到 &lt;判断当前线程的排队情况&gt;, 也就是 hasQueuedPredecessors()方法</strong></p><h6 id="hasQueuedPredecessors流程"><a href="#hasQueuedPredecessors流程" class="headerlink" title="hasQueuedPredecessors流程"></a>hasQueuedPredecessors流程</h6><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-hasQueue.png" alt="hasQueuedPredecessors流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="总结hasQueuedPredecessors流程："><a href="#总结hasQueuedPredecessors流程：" class="headerlink" title="总结hasQueuedPredecessors流程："></a>总结hasQueuedPredecessors流程：</h6><p>hasQueuedPredecessors() 方法返回false的时候，当前线程会成功获取到锁<br>那么会返回false的情况有2个：<br>1 AQS队列中没有其他线程等待，那么当前线程自然可以获取到锁<br><strong>2 当前线程创建的 node 刚刚入队且排在队首位，自旋时锁被释放了。那么当前线程可以获取到锁</strong></p><blockquote><p>解释：<br><code>acquireQueued(addWaiter(Node.EXCLUSIVE)</code> 的执行顺序是先 <code>addWaiter(Node.EXCLUSIVE)</code> 创建Node并入队（如果AQS队列原本为空，会先创建一个空Node，不为空就直接追加）。创建完成Node之后会调用 <code>acquireQueued(node)</code> 方法。<br>在 <code>acquireQueued(node)</code> 方法中，上面有提到：如果传入node的前一个节点恰好是AQS中Head指向的节点，那么说明这个node有资格尝试获取锁，此时调用 <code>tryAcquire()</code> 方法尝试拿锁时假如锁恰好被释放了（state==0），在这种情况下会调用 <code>hasQueuedPredecessors()</code> 方法检查AQS中是否有线程在排队。<br>现在的情况是，假如有一个线程T刚进入AQS队列，创建的Node排在第二位（第一位Node的thread是null）。那么 <code>h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread())</code> 这个判断会返回 fasle，此时虽然线程T刚入队，但是正好获取了锁，就顺理成章拿锁、修改state=1、然后重排AQS队列、GC回收无用Node等等。而不必在让线程T阻塞park()了。</p></blockquote><hr><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/AQS-addwriter-acquire.png" alt="手画流程图"></p><hr><h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><p>这里涉及到 Node 类中的 waitStatus 属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性的设计非常巧妙，因为假如当前线程阻塞了，那么对于当前线程来说，阻塞线程和标记为阻塞状态是有一个先后顺序的<br>如果先标记状态，那么万一系统发生异常，该线程并没有成功park()，那也会产生bug。<br>但是如果先阻塞，就无法再去标记状态了，因为线程已经停止运行了。<br>所以这里 waitStatus 很巧妙的利用当前node的前一个节点的waitStatus来标记当前这个线程的阻塞状态<br>如果进入这个方法时 waitStatus 不为 -1，那么会自旋将其标记为 -1，然后返回true</p><h6 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h6><p>直到 shouldParkAfterFailedAcquire() 方法返回true时，这个方法才会执行。<br>使用LockSupport.park() 方法阻塞当前线程，直到再次被唤醒时返回 Thread.interrupted();  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6 由 LockSupport 封装 UNSAFE 类中的 park() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于 Thread.interrupted() 线程中断，这里需要与 lockInterruptibly() 锁一起理解</strong></p><p>这部分等我真正理解后再输出吧。</p><p>我的个人理解是：</p><p>在 Lock() 加锁时，<code>thread.interrupt();</code> 并不能中断阻塞的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 lockInterruptibly() 加锁时，<code>thread.interrupt();</code> 可以通过抛出异常来中断阻塞线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure><p>仅供参考</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> AQS </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点整理|B站面试录播（三太子敖丙）</title>
      <link href="2020/11/27/interview/"/>
      <url>2020/11/27/interview/</url>
      
        <content type="html"><![CDATA[<p>这个视频很早之前就收藏了</p><p>今天从头到尾细看了一遍，收获挺大的。把视频中出现的思维导图补充和整理了一版（并没有涵盖所有的点）</p><p>视频链接在下面 ↓</p><p><a href="https://www.bilibili.com/video/BV1HQ4y1P7hE">Bilibili-程序员面试北大研究生Java岗</a></p><p>由于图片导出实在是太大了，放在OSS非常消耗带宽，如果需要的话可以通过下面链接获取</p><p><a href="https://github.com/YorickYu/Java-abilities-summary">知识点整理</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大化满足你需求的日志系统</title>
      <link href="2020/11/26/simple-log-project/"/>
      <url>2020/11/26/simple-log-project/</url>
      
        <content type="html"><![CDATA[<h1 id="simple-log-project"><a href="#simple-log-project" class="headerlink" title="simple_log_project"></a>simple_log_project</h1><p>最大化满足你需求的日志系统</p><a id="more"></a><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>最大化满足需求的同时尽可能避免代码侵入</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过AOP去切入你自定义的注解，不断维护你的注解类和切面类，最后将这个工具打包成jar包发布到maven仓库。</p><p><strong><em>因为没有一款三方的插件可以完美覆盖你所有的需求，所以最好的方式就是按这个流程不断维护自己的工具。</em></strong></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>1 导入文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.java</span><br><span class="line">LogAspect.java</span><br></pre></td></tr></table></figure><p>前者定义注解</p><p>后者AOP切入注解，完善功能</p><p>2 在目标方法上添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>.MIDDLE(description = <span class="string">&quot;标记测试方法&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundTest</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// TODO..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 执行结果</p><p><img src="https://upload-images.jianshu.io/upload_images/1260967-96d5ae227bf41496.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result"></p><p>日记会记录使用的切面类型、执行的类和方法、传入参数、执行结果、持续时间等。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>你可以在 <a href="https://github.com/YorickYu/JPP/tree/main/src/main/java/com/yy/annotation">JPP</a> 或者<a href="https://github.com/YorickYu/simple_log_project">simple_log_project</a> 中下载并使用这个小工具</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Annotation </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 最长公共前缀</title>
      <link href="2020/11/18/longest-common-prefix-string/"/>
      <url>2020/11/18/longest-common-prefix-string/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p><p>所有输入只包含小写字母 a-z 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>其实这个题目不难，也没有使用什么特别巧妙的想法。只是单纯的结果让我出乎意料。<br>纪念一下我的第一个0ms吧。</p><p>解法就是暴力for。<br>拿出数组中一个元素，循环与其他元素比较，如果不包含相同前缀就把当前的字符串减去最后一个字符继续遍历。</p><p><del>随后就是两种结果，要么得到一个子串符合条件，那么就继续验证合法性（这也就是为什么要for两次）。要么就是被减成了空串，那就说明没有公共前缀。直接返回即可</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String finalString &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; strs.length ; i++) &#123;</span><br><span class="line">            String x &#x3D; strs[i];</span><br><span class="line">            finalString &#x3D; i &#x3D;&#x3D; 0? x : finalString;</span><br><span class="line">            if (finalString.length() &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 如果目标字符串为空，说明没有公共串</span><br><span class="line">                return &quot;&quot;;</span><br><span class="line">            &#125;else if (i !&#x3D; 0 &amp;&amp; x.indexOf(finalString) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 此元素以目标字符串开头，遍历下一个元素</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                for (int j &#x3D; i+1; j &lt; strs.length; j++) &#123;</span><br><span class="line">                    while (strs[j].indexOf(finalString) !&#x3D; 0) &#123; &#x2F;&#x2F; 如果不是以目标字符串开头，则截掉目标字符串最后一个字符并重试</span><br><span class="line">                        finalString &#x3D; finalString.substring(0, finalString.length()-1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return finalString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><p>昨天写的代码太多余了，因为题目中有 <strong><em>公共</em></strong> 两个字，让我想要多验证一次前缀的合法性。<br>但是也正因为 <strong><em>公共</em></strong> 二个字。其实并不用去验证，因为只要有一个不合法，在while中就削减为空串了。</p><p>下面的代码当然也可以多加一个判断。就是循环的时候判断空串。</p><p>但是我保留Java4行代码0ms难道不好吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        String finalString &#x3D; strs.length &gt; 0 ? strs[0] : &quot;&quot;;</span><br><span class="line">        for (int j &#x3D; 1; j &lt; strs.length; j++) &#123;</span><br><span class="line">            while (strs[j].indexOf(finalString) !&#x3D; 0) </span><br><span class="line">                finalString &#x3D; finalString.substring(0, finalString.length()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return finalString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/result-longgestcommonprefix.jpg" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode X 京东 周赛挑战（失败）</title>
      <link href="2020/11/16/min-operations/"/>
      <url>2020/11/16/min-operations/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong><em>Leetcode 将 x 减到 0 的最小操作数</em></strong></p><p>给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。</p><p>如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。</p><p>示例 1：</p><p>输入：nums = [1,1,4,2,3], x = 5<br>输出：2<br>解释：最佳解决方案是移除后两个元素，将 x 减到 0 。<br>示例 2：</p><p>输入：nums = [5,6,7,8,9], x = 4<br>输出：-1<br>示例 3：</p><p>输入：nums = [3,2,20,1,1,3], x = 10<br>输出：5<br>解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1 声明两个指针，分别指向数组的第一个和最后一个元素<br>2 多种情况判断数组首尾的值和x的大小关系</p><p>直接看代码吧，卡在最后一个长数组的用例过不去，debug了好久，期望次数是对的，但是结果不对。时间有限，暂时没弄清错在哪里，以后再改。</p><p>代码贴一下，请大神指教：<br>我能想到的就是 <strong>最小</strong> 问题，但是结果不应该有错。不知道哪里出了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int minOperations(int[] nums, int x) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        int p1 &#x3D; 0;</span><br><span class="line">        int p2 &#x3D; nums.length-1;</span><br><span class="line"></span><br><span class="line">        while (p2&gt;p1) &#123;</span><br><span class="line">            if (nums[p1] + nums[p2] &#x3D;&#x3D; x) &#123;</span><br><span class="line">                &#x2F;&#x2F; +2 返回</span><br><span class="line">                count +&#x3D;2;</span><br><span class="line">                x &#x3D; 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;else if (nums[p1] + nums[p2] &lt; x) &#123;</span><br><span class="line">                &#x2F;&#x2F; 两边都可以移动，选大的移</span><br><span class="line">                x -&#x3D; nums[p1] &gt;&#x3D; nums[p2] ? nums[p1++] : nums[p2--];</span><br><span class="line">                count +&#x3D; 1;</span><br><span class="line">            &#125;else if (nums[p1] + nums[p2] &gt; x) &#123;</span><br><span class="line">                if (nums[p1] &#x3D;&#x3D; x || nums[p2] &#x3D;&#x3D; x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; +1 返回</span><br><span class="line">                    count +&#x3D; 1;</span><br><span class="line">                    x &#x3D; 0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;else if (nums[p1] &gt; x &amp;&amp; nums[p2] &lt; x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 移动p2</span><br><span class="line">                    x -&#x3D; nums[p2--];</span><br><span class="line">                    count +&#x3D; 1;</span><br><span class="line">                &#125;else if (nums[p2] &gt; x &amp;&amp; nums[p1] &lt; x) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 移动p1</span><br><span class="line">                    x -&#x3D; nums[p1++];</span><br><span class="line">                    count +&#x3D; 1;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    &#x2F;&#x2F; -1</span><br><span class="line">                    count &#x3D; -1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return x &#x3D;&#x3D; 0 ? count: -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 两个数组的交集 II</title>
      <link href="2020/11/16/intersection-of-array/"/>
      <url>2020/11/16/intersection-of-array/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>示例 1:</p><p>输入：nums1 = [1,2,2,1], nums2 = [2,2]</p><p>输出：[2,2]</p><p>示例 2:</p><p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</p><p>输出：[4,9] </p><p>说明：</p><p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。</p><p>进阶：</p><p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1 先将两个数组分别存入HashMap中，key为元素的值，value为元素出现的次数<br>2 选择数组较短的那个HashMap进行遍历<br>3 如果HashMap的key相同，则说明有交集<br>4 Key的value值就是这个元素出现的次数，两个HashMap的value值取最小值，就是这个Key重复的次数。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; array1Map &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; array2Map &#x3D; new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        for (int a: nums1) &#123;</span><br><span class="line">            Integer times &#x3D; 0;</span><br><span class="line">            if (array1Map.get(a) !&#x3D; null)</span><br><span class="line">                times &#x3D; array1Map.get(a);</span><br><span class="line">            array1Map.put(a, ++times);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int b: nums2) &#123;</span><br><span class="line">            Integer times &#x3D; 0;</span><br><span class="line">            if (array2Map.get(b) !&#x3D; null)</span><br><span class="line">                times &#x3D; array2Map.get(b);</span><br><span class="line">            array2Map.put(b, ++times);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; target;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; copy;</span><br><span class="line">        if (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            target &#x3D; array2Map;</span><br><span class="line">            copy &#x3D; array1Map;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            target &#x3D; array1Map;</span><br><span class="line">            copy &#x3D; array2Map;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; arrList &#x3D; new ArrayList&lt;Integer&gt;(target.keySet().size());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator &#x3D; target.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Integer targetKey &#x3D; iterator.next();</span><br><span class="line">            Integer targetValue &#x3D; target.get(targetKey);</span><br><span class="line">            Integer copyValue &#x3D; copy.get(targetKey);</span><br><span class="line"></span><br><span class="line">            if (copyValue &#x3D;&#x3D; null)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">            int finalValue &#x3D; Math.min(targetValue, copyValue);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; finalValue; i++) &#123;</span><br><span class="line">                arrList.add(targetKey);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] returnints &#x3D; new int[arrList.size()]; </span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        for (final Integer value: arrList) &#123;</span><br><span class="line">            returnints[index++] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return returnints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码存在的问题：<br>没必要将两个数组都存入HashMap，只存一个，然后遍历另一个数组即可。遍历的过程中取HashMap中get(key)，只要不为null就记录一次。</p><p>大概可以节省1-2次遍历的开销。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>双指针：<br>1 首先将两个数组排序<br>2 声明两个指针变量，分别指向两个数组的第一个元素<br>3 如果两个元素相等，则记录一次，并且两个指针均向后移动一位<br>4 如果不相等，数值小的指针向后移动，直到元素相等，以此类推<br>5 直到任意一个指针指向了数组的末尾结束</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public static int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        int f1 &#x3D; 0,f2&#x3D;0;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrl &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while(f1&lt;nums1.length &amp;&amp; f2&lt;nums2.length)&#123;</span><br><span class="line">            if(nums1[f1]&lt;nums2[f2])&#123;</span><br><span class="line">                f1++;</span><br><span class="line">            &#125;else if(nums1[f1]&gt;nums2[f2])&#123;</span><br><span class="line">                f2++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                arrl.add(nums1[f1]);</span><br><span class="line">                f1++;</span><br><span class="line">                f2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] jiao &#x3D; new int[arrl.size()];</span><br><span class="line">        for(int i&#x3D;0; i&lt;arrl.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            jiao[i] &#x3D; arrl.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return jiao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式结果如下：<br>6 小时前    通过    2 ms    38.7 MB<br>6 小时前    通过    5 ms    38.4 MB    </p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和挖矿程序拼到底！</title>
      <link href="2020/11/11/centos-attack/"/>
      <url>2020/11/11/centos-attack/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>服务器被挖矿了，CPU占用一直是100%。</p><p>没有过多深入研究，照着网上几个处理方式执行了一些命令。无果</p><p>同事给出的建议就是重装系统，但是我偏不</p><p>我要和他拼到底！</p><p>由于是在太影响使用了，我先写个Shell脚本，每2小时清一次。以后有时间再收拾你！</p><h3 id="Shell思路"><a href="#Shell思路" class="headerlink" title="Shell思路"></a>Shell思路</h3><p>由于太久没写过Shell了，所以很简陋，以后再优化。</p><p>大概思路如下：</p><p>1 获取 [用户名] 的进程号</p><p>2 遍历进程号，获取其对应的CPU信息</p><p>3 判断CPU使用量是否大于85，如果大于，则杀死该进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">向上取整</span></span><br><span class="line">function ceil()&#123;</span><br><span class="line">  floor=`echo &quot;scale=0;$1/1&quot;|bc -l ` # 向下取整</span><br><span class="line">  add=`awk -v num1=$floor -v num2=$1 &#x27;BEGIN&#123;print(num1&lt;num2)?&quot;1&quot;:&quot;0&quot;&#125;&#x27;`</span><br><span class="line">  echo `expr $floor  + $add`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定时清理git用户开辟的进程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">用户名</span></span><br><span class="line">USERNAME=&quot;root&quot;</span><br><span class="line">THRESHOLD=&quot;85&quot;</span><br><span class="line">TIME=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取git用户的所有进程号</span></span><br><span class="line">PIDS=`ps -ef | grep $USERNAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">循环PID</span></span><br><span class="line">for PID in $PIDS; do</span><br><span class="line"><span class="meta">#</span><span class="bash">statements</span></span><br><span class="line">CPU_DATA=`pgrep java | xargs ps -u --pid $PID | awk &#x27;&#123;print $3&#125;&#x27;`</span><br><span class="line">for C in $CPU_DATA; do</span><br><span class="line"><span class="meta">#</span><span class="bash">如果CPU占用大于80%，杀死进程</span></span><br><span class="line">if [[ $C != &#x27;%CPU&#x27; ]]; then</span><br><span class="line">CEIL_C=`ceil $C`</span><br><span class="line">if [[ CEIL_C -gt $THRESHOLD ]]; then</span><br><span class="line">                echo $TIME &gt;&gt; mining.log</span><br><span class="line">echo &quot;git 用户的 $PID 已占用CPU $C&quot; &gt;&gt; touch mining.log</span><br><span class="line">kill -9 $PID</span><br><span class="line">echo &quot;已将 $PID 进程 killed&quot; &gt;&gt; touch mining.log</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挖矿 </tag>
            
            <tag> mining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIO/NIO/多路复用 原理与区别</title>
      <link href="2020/11/11/about-IO/"/>
      <url>2020/11/11/about-IO/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网络通信中BIO、NIO、多路复用相关的知识点非常多，网络上也有很多相关的技术文章。但是每个人的角度和切入点不同，知识涵盖的内容太多了，很难整理出一条清晰的思路。</p><p>我这两天尝试着脱离代码（因为加入代码Demo之后，篇幅增长，很多API也不是很熟悉，增加阅读的难度），单纯从操作系统网络通信的流程去梳理BIO、NIO，再到多路复用的优缺点。最终达到了解这些技术的联系和发展的目的。</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>此流程基于Java示例代码，代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> /IOTest 类</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/bio.png" alt="BIO"> </p><a id="more"></a><p>主线程：</p><p>1 服务端等待客户端连接，阻塞进程</p><p>2 检测到客户端连接，返回对应的文件描述符fd，并将连接移动到子线程</p><p>3 开始下一次循环，跳回第1步</p><p>子线程：</p><p>1 子线程中服务端等待客户端响应，阻塞进程</p><p>2 接收到客户端响应，子线程处理</p><p>3 开始下一次循环，跳回第1步</p><p>优势：可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。</p><p>问题：</p><p>1 线程的创建和销毁成本很高</p><p>2 线程本身占用较大内存</p><p>3 线程的切换成本是很高的</p><p>4 容易造成锯齿状的系统负载</p><blockquote><p>为了解决BIO的缺点，进入NIO</p></blockquote><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>此流程基于Java示例代码，代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> /NIOTest 类</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nio.png" alt="NIO"> </p><blockquote><p>本文介绍的NIO是操作系统网络通信中的NON-BLOCKING IO，是Java NIO的基础。<br>上图中的两个 <strong>主线程 循环</strong> 指的是没有开辟子线程。意思是服务端接收客户端连接和处理客户端请求都在同一个线程中。</p></blockquote><p>流程：</p><p>1 服务端请求客户端连接，非阻塞。如果没有直接返回null并向下执行</p><p>2 如果有客户端连接，请求消息响应，非阻塞。如果没有响应直接返回null并继续遍历客户端</p><p>3 遍历完所有客户端后，会重新开始循环，跳回第1步</p><p>优势：</p><p>1 规避多线程的问题</p><p>2 单线程解决多任务</p><p>问题：</p><p>客户端循环遍历时，不断进行用户态和内核态的切换，系统调用开销非常大</p><blockquote><p><strong><em>什么是用户态和内核态？</em></strong><br>我的理解就是权限不同。用户态的进程能够访问的资源受操作系统的控制，而运行在内核态的进程才可以访问系统中的硬件设别，例如网卡。</p><p>所以上面客户端循环遍历询问消息响应，会不断进行用户态和内核态的切换。</p><p><strong><em>开销大在哪？</em></strong></p><ul><li>1 保护现场</li><li>2 恢复现场</li><li>3 软中断</li><li>4 寻找中断向量表</li><li>5 找回调函数<br>等</li></ul></blockquote><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在NIO的基础上，通过一次系统调用将连接客户端响应询问移动到内核处理，而不是反复进行用户态和内核态的切换。</p><p>如果把每次系统调用理解成一条通路，那么这种把多次系统调用合并成一次的方式，就叫做**<em>多路复用**</em>。</p><p>例如：<a href="https://tech.meituan.com/2016/11/04/nio.html">美团 Java NIO浅析</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface ChannelHandler&#123;</span><br><span class="line">void channelReadable(Channel channel);</span><br><span class="line">void channelWritable(Channel channel);</span><br><span class="line">&#125;</span><br><span class="line">class Channel&#123;</span><br><span class="line">Socket socket;</span><br><span class="line">Event event;&#x2F;&#x2F;读，写或者连接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;IO线程主循环:</span><br><span class="line">class IoThread extends Thread&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">Channel channel;</span><br><span class="line">while(channel&#x3D;Selector.select())&#123;&#x2F;&#x2F;选择就绪的事件和对应的连接</span><br><span class="line">  if(channel.event&#x3D;&#x3D;accept)&#123;</span><br><span class="line">     registerNewChannelHandler(channel);&#x2F;&#x2F;如果是新连接，则注册一个新的读写处理器</span><br><span class="line">  &#125;</span><br><span class="line">if(channel.event&#x3D;&#x3D;write)&#123;</span><br><span class="line">     getChannelHandler(channel).channelWritable(channel);&#x2F;&#x2F;如果可以写，则执行写事件</span><br><span class="line">&#125;</span><br><span class="line">if(channel.event&#x3D;&#x3D;read)&#123;</span><br><span class="line">getChannelHandler(channel).channelReadable(channel);&#x2F;&#x2F;如果可以读，则执行读事件</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Channel，ChannelHandler&gt; handlerMap;&#x2F;&#x2F;所有channel的对应事件处理器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Selector中的select函数会执行系统内核的调用：Linux 2.6之前是select、poll，2.6之后是epoll。</p><p>此流程基于Java示例代码，代码可以查看 <a href="https://github.com/YorickYu/JPP">JPP</a> /NIOEpollTest 类</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/epoll.png" alt="多路复用"> </p><h3 id="多路复用的实现方式"><a href="#多路复用的实现方式" class="headerlink" title="多路复用的实现方式"></a>多路复用的实现方式</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>流程：</p><p>1 客户端建立连接后返回fd</p><p>2 用二进制位表bitmap标记fds对应的位置，并将这个bitmap从用户态拷贝到内核态</p><p>3 收到客户端响应，将对应的bitmap位标记为1</p><p>4 程序处理消息，重新创建bitmap，循环下一次</p><p>缺点：</p><p>1 bitmap默认最大限制1024位</p><p>2 bitmap不可重用，每次循环重新创建</p><p>3 用户态和内核态切换开销</p><p>4 轮询所有的客户端处理消息 O(n)</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>流程：</p><p>与select相似，select中用bitmap标记fds，在poll中自己声明了结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">short</span> events;</span><br><span class="line"><span class="keyword">short</span> revents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传输pollfd数组，解决了select中fds限制1024位的问题</p><p>其次，内核将响应客户端对应的pollfd结构体中的revnets标记为1，说明这个客户端有消息响应</p><p>处理消息时将这个pollfd的revnets重置即可，不用在重新创建数组，所以select中每次循环重新创建bitmap的问题也被解决了</p><p>遗留问题：</p><p>1 由于fds文件描述符存储在用户空间，拷贝到内存空间处理一定会涉及到用户态和内核态的切换。这个系统调用有一定开销</p><p>2 每次内核态返回的信息是全量信息，要轮询处理，时间复杂度是 O(n)，如果连接数过多，也会有很多无意义的开销</p><p><strong><em>这两个问题留给 epoll</em></strong></p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>流程：</p><p>1 建立epoll对象时在内核分配资源，其数据结构是红黑树。添加和检索的时间复杂度 O(lgn)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; </span><br></pre></td></tr></table></figure><p>2 建立连接时，在红黑树中存储 epoll_event结构体，其中包含fd和events等信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;  </span><br></pre></td></tr></table></figure><p>3 调用epoll_wait收集响应的连接，放入一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,<span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;  </span><br></pre></td></tr></table></figure><p>到此为止，上面提到的多路复用的所有缺点都得以解决。</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p><a href="https://github.com/YorickYu/JPP/raw/main/IO_xmind/IO.png">网络通信</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BIO </tag>
            
            <tag> NIO </tag>
            
            <tag> 多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap resize loTail.next=e loTail=e</title>
      <link href="2020/11/06/hashmap-resize-lotail/"/>
      <url>2020/11/06/hashmap-resize-lotail/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap扩容的过程包含了很多巧妙的思考，思想简单易懂，但是代码的实现真的让人折服！</p><p>今天快速浏览resize方法时，被两行代码绕住了：</p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/loTail.next%20%3D%20e.png" style="zoom:50%;" /><p>可能是对于引用类型的理解不够深刻吧，这两行代码真的看了我一天！网上也很少有人分析这两行代码（可能因为太容易了吧）</p><p>最后我自己写了个Demo，算是把这个操作搞清楚了。因为是引用类型的指针指向问题，所以画图也不太好理解，只能自己写个Demo，一点点Debug分析过程。</p><p>相关代码在：<a href="https://github.com/YorickYu/JPP">Jpp</a> /TailInsert类中</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="准备一个简单的链表对象"><a href="#准备一个简单的链表对象" class="headerlink" title="准备一个简单的链表对象"></a>准备一个简单的链表对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(K key, V value, Node&lt;K, V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化过程"><a href="#简化过程" class="headerlink" title="简化过程"></a>简化过程</h2><p>先看下面的代码，理解这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node a &#x3D; null;</span><br><span class="line">Node b &#x3D; null;</span><br><span class="line">Node c &#x3D; new Node(&#39;c&#39;, &#39;c&#39;, null);</span><br><span class="line">b &#x3D; c;</span><br><span class="line">a &#x3D; c;</span><br><span class="line">c &#x3D; new Node(8,8, null);</span><br><span class="line">a.next &#x3D; c;</span><br><span class="line">a &#x3D; c;</span><br></pre></td></tr></table></figure><h3 id="代码1-5行"><a href="#代码1-5行" class="headerlink" title="代码1-5行"></a>代码1-5行</h3><p>声明了a，b两个Node类型的引用，声明c指向一个Node@478对象</p><p>然后把a和b都指向了Node@478对象。如下图所示：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep1.jpg" alt="p1"></p><h3 id="代码-6行"><a href="#代码-6行" class="headerlink" title="代码 6行"></a>代码 6行</h3><p>创建了一个新的Node@479对象，将c引用指向这个对象。如下图所示：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep2.jpg" alt="p1"></p><h3 id="代码-7行"><a href="#代码-7行" class="headerlink" title="代码 7行"></a>代码 7行</h3><p>在Node@478中有一个next属性，a.next = c;表示将Node@478的next指向c引用指向的地址(即Node@479)</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep3.jpg" alt="p1"></p><h3 id="代码-8行"><a href="#代码-8行" class="headerlink" title="代码 8行"></a>代码 8行</h3><p>a = c; 就是将a的引用重新指向c引用指向的地址(即Node@479)</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/nodep4.jpg" alt="p1"></p><p>所以最终的结果就是：</p><p>a，c引用指向相同的Node@479对象</p><p>b指向Node@478对象，其中Node@478的next引用指向Node@479对象</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pend.png"></p><p>理解了上面的过程，下面就非常容易了 ^ ^</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><p>创建链表并插入10个元素（尾插）来模拟HashMap数组中某一个节点的链表。</p><blockquote><p>JDK1.8中，链表长度超过 <strong>变树阈值</strong> 时会将链表变化成红黑树<br>这个变化需要满足两个条件：1 链表长度超过变树阈值 2 HashMap的size大于64</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node tab = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>); <span class="comment">// node链表</span></span><br><span class="line">Node p = tab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Node tail = <span class="keyword">new</span> Node(i, i, <span class="keyword">null</span>); <span class="comment">// 最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.next = tail;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 尾插</span></span><br><span class="line">        Node e;</span><br><span class="line">        <span class="keyword">while</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.next = tail;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="仿写resize核心代码"><a href="#仿写resize核心代码" class="headerlink" title="仿写resize核心代码"></a>仿写resize核心代码</h3><p>在HashMap扩容时有一个很巧妙的操作，就是数组长度扩容至原先两倍时，重新计算链表节点的插入角标会将原链表随机分布到新数组的两个位置：1 原来角标的位置 2 原角标+原数组长度的位置</p><p>而这个操作在JDK1.7和JDK1.8中的思想是相同的，不过实现方式略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">假设：</span><br><span class="line">现在有两个链表节点</span><br><span class="line">他们的hash值低8位分别是 0110 1011 、1001 1011</span><br><span class="line">扩容前数组长度为16，扩容长度变为32</span><br><span class="line">扩容前他们都在数组角标11的位置</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK1.7 e.hash &amp; (length-1)</span><br><span class="line">&#x2F;&#x2F; 第一个节点</span><br><span class="line">0110 1011</span><br><span class="line">0001 1111</span><br><span class="line">&amp; 0000 1011 角标11</span><br><span class="line">&#x2F;&#x2F; 第二个节点</span><br><span class="line">1001 1011</span><br><span class="line">0001 1111</span><br><span class="line">&amp; 0001 1011 角标27</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; JDK1.8 (e.hash &amp; oldCap) &#x3D;&#x3D; 0</span><br><span class="line">&#x2F;&#x2F; 第一个节点</span><br><span class="line">0110 1011</span><br><span class="line">0001 0000</span><br><span class="line">&amp; 0000 0000 结果0，在原数组位置</span><br><span class="line">&#x2F;&#x2F; 第二个节点</span><br><span class="line">1001 1011</span><br><span class="line">0001 0000</span><br><span class="line">&amp; 0001 0000 结果1，在新数组位置</span><br></pre></td></tr></table></figure><p>JDK1.7中，直接通过hash值与新数组长度-1 按位与 得到新角标</p><p>JDK1.8中，通过计算hash值对应的原数组位置是否为0，如果为0则插入tab[j]，否则插入tab[j+oldCap]</p><hr><p>我模拟的Demo中没有设计这么多复杂的数据，所以简化为节点value值的奇偶判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Node loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">Node next;</span><br><span class="line">Node e = tab;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)e.value % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 进入次判断的节点为 0,2,4,6,8</span></span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)e.value % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>以取模结果等于0为例：</p><p>第一次进入，loHead = 0, loTail = 0。loTail和loHead指向相同的内存地址</p><p>第二次进入，loTail.next = 2会移动loHead.next指向 2。随后loTail = 2，即loHead.next和loTail指向相同的内存地址</p><p>第三次进入，loTail.next = 4也就是loHead.next.next指向4。随后loTail = 4，即loHead.next.next和loTail指向相同的内存地址</p><p>以此类推，如下图：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/hashmap%20resize%20%281%29.jpg"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面就是我对 <code>loTail.next = e; loTail = e;</code> 这两行代码的理解。</p><p>进一步思考，为什么HashMap在 JDK1.7 的时候会选择头插法插入元素？</p><p>不考虑JDK1.7中resize时的循环引用问题，我认为头插法无论是从理解的角度，还是从代码实现的角度都更胜一筹。甚至还可能能稍微优化一些查询的速率。</p><p>就拿上面Demo中的尾插生成测试链表为例，我的写法是仿照JDK1.8的，中间要声明很多局部变量，所以你会看到 JDK1.8 的源码中有很多判断中赋值的操作。如果不这么写的话，估计JDK1.8的源码会再多几百行（本身实现了一套红黑树，代码量相较1.7膨胀了几乎一倍）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
            <tag> resize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode reverse-words</title>
      <link href="2020/11/03/reverse-words/"/>
      <url>2020/11/03/reverse-words/</url>
      
        <content type="html"><![CDATA[<p>LeetCode p151 逐个翻转字符串中的每个单词</p><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ReverseWords类中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 给定一个字符串，逐个翻转字符串中的每个单词。 </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 说明： </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 无空格字符构成一个 单词 。 </span><br><span class="line">&#x2F;&#x2F; 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 </span><br><span class="line">&#x2F;&#x2F; 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 1： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;the sky is blue&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;blue is sky the&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 示例 2： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;  hello world!  &quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;world! hello&quot;</span><br><span class="line">&#x2F;&#x2F;解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 3： </span><br><span class="line">&#x2F;&#x2F; 输入：&quot;a good   example&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;example good a&quot;</span><br><span class="line">&#x2F;&#x2F;解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 4： </span><br><span class="line">&#x2F;&#x2F; 输入：s &#x3D; &quot;  Bob    Loves  Alice   &quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;Alice Loves Bob&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 示例 5： </span><br><span class="line">&#x2F;&#x2F; 输入：s &#x3D; &quot;Alice does not even like bob&quot;</span><br><span class="line">&#x2F;&#x2F;输出：&quot;bob like even not does Alice&quot;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 提示： </span><br><span class="line">&#x2F;&#x2F; 1 &lt;&#x3D; s.length &lt;&#x3D; 104 </span><br><span class="line">&#x2F;&#x2F; s 包含英文大小写字母、数字和空格 &#39; &#39; </span><br><span class="line">&#x2F;&#x2F; s 中 至少存在一个 单词 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; 进阶：  </span><br><span class="line">&#x2F;&#x2F; 请尝试使用 O(1) 额外空间复杂度的原地解法。 </span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Related Topics 字符串 </span><br><span class="line">&#x2F;&#x2F; 👍 240 👎 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        String[] strings &#x3D; s.split(&quot;\\s+&quot;);</span><br><span class="line">        HashMap m &#x3D; new HashMap();</span><br><span class="line">        int modCount &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; strings.length; i++) &#123;</span><br><span class="line">            String innerstring &#x3D; strings[i];</span><br><span class="line">            if (!innerstring.equals(&quot;&quot;)) &#123;</span><br><span class="line">                m.put(modCount++, innerstring);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (;modCount&gt;0;) &#123;</span><br><span class="line">            sb.append(m.get(--modCount));</span><br><span class="line">            if (modCount !&#x3D; 0)</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解题思路就是用Java现有的API配合正则去拆分传入的字符串s，得到一个字符串数组</p><p>然后利用HashMap查找O(1)的特性，将value值按序存入key，并记录key值</p><p>最后倒序key值，取出value即可。</p><blockquote><p>这里其实一次for循环逆序遍历也可以得出答案，时间复杂度不会有太大差别，因为本身字符串数组长度不会很大。<br>我只是单纯的像仿照HashMap源码中modCount的想法记录一下编辑次数，所以for了两次。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String reverseWords(String s) &#123;</span><br><span class="line">    String[] words &#x3D; s.trim().split(&quot;\\s+&quot;);</span><br><span class="line">    int len &#x3D; words.length;</span><br><span class="line">    StringBuilder ans &#x3D; new StringBuilder();</span><br><span class="line">    ans.append(words[len - 1]);</span><br><span class="line">    for (int i &#x3D; len - 2; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">        if (words[i].equals(&quot;&quot;))</span><br><span class="line">            continue;</span><br><span class="line">        ans.append(&quot; &quot; + words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，学了一下网上一些时间复杂度很低的解法，耗时的步骤都来源于数组的 <code>split</code> 方法。</p><p>想要突破的可以自定义一个数组拆分的方法。</p><p>还有，基本可以确定的是，使用 <code>StringBuilder</code> 的API拼接数组比直接使用 String 速度要快。</p><blockquote><p>关于String拼接的性能，阿里手册中有专门收录：<a href="https://developer.aliyun.com/article/756752?spm=a2c6h.12873639.0.0.6fee1e8brXp7fY">为什么不建议在 for 循环中使用“+”进行字符串拼接？</a></p></blockquote><p>for循环中5万次字符串拼接性能差别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ cost:5119</span><br><span class="line">StringBuilder cost:3</span><br><span class="line">StringBuffer cost:4</span><br><span class="line">concat cost:3623</span><br><span class="line">StringUtils.join cost:25726</span><br></pre></td></tr></table></figure><p>先后提交了2次，结果如下：</p><p>11 分钟前    通过    10 ms    38.9 MB    Java<br>20 分钟前    通过    12 ms    39.3 MB    Java</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.7 ConcurrentHashMap 两次数组下标计算问题</title>
      <link href="2020/11/03/concurrenthashmap-two-array-index/"/>
      <url>2020/11/03/concurrenthashmap-two-array-index/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ConcurrentHashMap结构如下:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p><p>Segment[]数组的长度在ConcurrentHashMap的构造方法中由并发级别 <code> DEFAULT_CONCURRENCY_LEVEL</code> 计算得出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且初始化完成后，Segment[]数组不会再扩容。</p><p>HashEntry[]数组的长度在ConcurrentHashMap的构造方法中由初始化容量 <code> DEFAULT_INITIAL_CAPACITY</code> 和并发级别 <code> DEFAULT_CONCURRENCY_LEVEL</code> 计算得出，且最小值为2，向上取值时为2的整数幂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">if (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line">int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; &#x2F;&#x2F; 最小值2</span><br><span class="line">while (cap &lt; c) &#x2F;&#x2F; 保证取值是2的整数幂</span><br><span class="line">    cap &lt;&lt;&#x3D; 1;</span><br></pre></td></tr></table></figure><p>初始化完成后，HashEntry[]数组会扩容。而且由自旋锁和volatile保证了线程安全性</p><p>由此可见，ConcurrentHashMap元素插入需要两次计算数组下标，让我们分析一下源码中是如何设计的。</p><a id="more"></a><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用的 <strong><em><a href="http://d0evi1.com/wang-jenkins-hash/">Wang/Jenkins Hash算法</a></em></strong> </p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>segmentShift在构造方法中计算的出：32 - sshift，sshift记录值为Segment[]数组长度值为2的几次幂。</p><p>例：</p><p>并发级别为16，通过构造方法中的while遍历，得到：ssize为32，sshift为5。</p><p>即Segment[]数组的数组长度ssize为32，sshift为5 – $2^5$</p><p>所以，</p><p>上面第4行代码表示让hash值高位(Segment数组长度)决定下标。</p><h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第6行代码表示让hash值的低位(HashEntry数组长度)决定下标。</p><h2 id="他是怎么想到的？"><a href="#他是怎么想到的？" class="headerlink" title="他是怎么想到的？"></a>他是怎么想到的？</h2><p>源码中真的有好多巧妙的设计值得学习和思考，最近总有一个问题萦绕在耳边：”他们到底TM是怎么想出来的？“</p><p>也太秀了！华丽的像是投机取巧～</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ConcurrentHashMap </tag>
            
            <tag> put </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap modCount fast-fail X原子性</title>
      <link href="2020/11/01/hashmap-modCount/"/>
      <url>2020/11/01/hashmap-modCount/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap源码中定义的成员变量并不多，其中我们最不熟悉的应该就是modCount，那么它到底是做什么的呢？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/modcount.jpg"></p><p><font color=red>如果你没时间思考这篇文章，你可以直接跳转到 <a href="#%E7%BB%93%E8%AE%BA">9.结论</a> 处</font></p><h2 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h2><p>modCount在HashMap中记录的是HashMap对象被修改的次数，这里专业的说法是集合在结构上修改时被会记录在modCount中。</p><blockquote><p>文中源码版本为 JDK1.7，modCount的部分在JDK1.8中作用是相同的。只因为JDK1.7中源码比较简洁，所以本文选用JDK1.7来缩减篇幅。</p></blockquote><p>在源码中记录到的modCount++的方法包括：</p><ul><li>HashMap put方法</li><li>HashMap的remove-&gt;removeEntryForKey方法 通过key移除元素</li><li>HashMap的removeMapping方法，通过object移除元素</li><li>HashMap的clear方法</li></ul><p>从这里可以看出，结构上的修改主要是添加和删除两部分。</p><h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p>我们都知道在JDK1.7中HashMap是线程不安全的，这个 <strong>不安全</strong> 我是分两方面理解的：</p><p><strong>1 多线程数组扩容时出现循环链表问题</strong></p><p>因为扩容时链表顺序会反转，所以多线程操作时可能会出现循环链表的情况，那么在get方法时就会死循环</p><blockquote><p>JDK1.8中也修复了这个问题</p></blockquote><p><strong>2 多线程读写时造成数据混乱的问题</strong></p><p>HashMap中有引入了一个 <strong>fast-fail</strong> 的概念，目的是避免高并发读写造成的数据错乱的隐患。</p><h2 id="expectedModCount"><a href="#expectedModCount" class="headerlink" title="expectedModCount"></a>expectedModCount</h2><p>expectedModCount这个变量被记录在HashIterator迭代器中。顾名思义，表示期望的修改次数，当期望修改的次数不等于实际修改的次数时，就会触发 <strong>fast-fail</strong> 快速失败的容错处理</p><h2 id="fast-fail"><a href="#fast-fail" class="headerlink" title="fast-fail"></a>fast-fail</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; nextEntry() &#123;</span><br><span class="line">    if (modCount !&#x3D; expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器调用 next() 方法时会调用 nextEntry() 方法，方法中首先会判断 modCount 与 expectedModCount 是否相等</p><p>如果不相等直接抛出 java.util.ConcurrentModificationException 异常</p><blockquote><p><strong>GeeksForGeeks中的解释为：</strong></p><p>In multi threaded environment, if during the detection of the resource, any method finds that there is a concurrent modification of that object which is not permissible, then this ConcurrentModificationException might be thrown.</p><ol><li>If this exception is detected, then the results of the iteration are undefined.</li><li>Generally, some iterator implementations choose to throw this exception as soon as it is encountered, called fail-fast iterators.</li></ol><p>For example: If we are trying to modify any collection in the code using a thread, but some another thread is already using that collection, then this will not be allowed.</p></blockquote><p>在多线程环境中，如果在检测资源期间，任何方法发现该对象存在并发修改，而这是不允许的，则可能会抛出此ConcurrentModificationException。</p><p>1 如果检测到此异常，则迭代结果不确定。</p><p>2 通常，某些迭代器实现选择将遇到此异常的异常立即抛出，称为快速失败迭代器。</p><p>例如：如果我们试图使用一个线程来修改代码中的一个集合，但是另一个线程已经在使用该集合，这种做法是不被允许的</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ConcurrentModificationExceptionDemo类中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">for (int i &#x3D; 0; i &lt;100 ; i++) &#123;</span><br><span class="line">    m.put(String.valueOf(i), &quot;value&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Iterator iterator &#x3D; m.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String next &#x3D; (String) iterator.next();</span><br><span class="line">            if (Integer.parseInt(next) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                System.out.println(&quot;thread 1&quot;);</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Iterator iterator  &#x3D; m.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String next &#x3D; (String) iterator.next();</span><br><span class="line">            System.out.println(m.get(next));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这里第一个线程中的 <code>System.out.println(&quot;thread 1&quot;);</code> 的作用是 <strong><em>触发数据和内存同步</em></strong>。</p><blockquote><p>这部分内容和寄存器的 <strong><em>缓存行</em></strong> 知识有关，如果不触发数据和内存同步，第二个线程无法正确获取modCount。</p></blockquote><h2 id="单线程错误案例"><a href="#单线程错误案例" class="headerlink" title="单线程错误案例"></a>单线程错误案例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">m.put(&quot;key1&quot;, &quot;value2&quot;);</span><br><span class="line">m.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">for (String key: m.keySet()) &#123;</span><br><span class="line">    if (key.equals(&quot;key2&quot;)) &#123;</span><br><span class="line">        m.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码块也有可能发生 fast-fail</p><p>我们来看一下上面代码块编译后的class文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap m &#x3D; new HashMap();</span><br><span class="line">m.put(&quot;key1&quot;, &quot;value2&quot;);</span><br><span class="line">m.put(&quot;key2&quot;, &quot;value2&quot;);</span><br><span class="line">Iterator i$ &#x3D; m.keySet().iterator();</span><br><span class="line">while(i$.hasNext()) &#123;</span><br><span class="line">    Object key &#x3D; i$.next();</span><br><span class="line">    if (key.equals(&quot;key2&quot;)) &#123;</span><br><span class="line">        m.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看应该就很容易理解了，而且这个错误也很容易发生。</p><p>在迭代器遍历的过程中，会将key值为“key2”的元素移除。移除时调用的HashMap的remove方法会对modCount值+1，但是这个方法并不会同步expectedModCount的值。所以在下一次迭代器调用i$.next();方法时，会发生异常。</p><p>expectedModCount // For fast-fail：在以下方法会同步modCount值</p><ul><li>HashIterator的构造方法</li><li>HashIterator的remove方法</li></ul><p>所以将上面移除元素的代码。替换为 <code>i$.remove();</code> 就可以了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>关于 i++ 计算不是原子性的怀疑：</p><p>HashMap源码记录modCount++这个计算方式在多线程操作时如果不能保证原子性，那么岂不是也有可能触发ConcurrentModificationException异常？</p><p>验证过程：<br>1 因为HashMap的put操作会进行modCount++<br>2 modCount声明时也没有指明<strong>volatile</strong><br>那么多线程put是否会造成modCount的值不准确？</p><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/ConcurrentModificationExceptionDemo类中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void atomicTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    HashMap m &#x3D; new HashMap();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">                m.put(i, String.valueOf(i).hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 10000; i &lt; 20000; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; System.out.println(i);</span><br><span class="line">                m.put(i, String.valueOf(i).hashCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(5000);</span><br><span class="line">    Iterator iterator &#x3D; m.keySet().iterator();</span><br><span class="line">    iterator.next(); &#x2F;&#x2F; 对比modCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>运行的结果是，如果循环次数不多，最后可以保证modCount的数值正确。但是提升循环插入的次数，会锁住一个线程，导致其他线程的数据没有插入成功，但是modCount的值依然是正确的。</del></p><p><del>具体这个魂循环次数设定的阈值，我也没有过多尝试。至少目前我没有因为++计算不是原子性的原因出现过fast-fail</del></p><p>运行结果有意外收获:</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/modcount%2B%2B%2B.jpg"></p><p>从上图可以看出，不仅在多线程写入的时候modCount的值无法保证（从expectedModCount看出），而且HashMap的size也不满足期望（因为多线程put时，两个线程的key不重复）</p><p>为了再次证明我的猜测，可以在多线程中添加 <code>System.out.println(i);</code> 代码，来达到内存同步的目的</p><p>结果不出所料：</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/sysmodcount%2B%2B.jpg"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1 HashMap多线程读写时可能会抛出ConcurrentModificationException异常，这是fast-fail快速失败机制。</p><p>2 fast-fail实现的原理是判断modCount和expectedModCount是否相等</p><p>3 modCount++在多线程操作时无法保证原子性，甚至HashMap整个put方法都出现了问题</p><blockquote><p>PS：所以在JDK1.7的ConcurrentHashMap中出现大量 <strong><em>UNSAFE</em></strong> 和 <strong><em>volatile</em></strong> 关键字，同时加入了ReentrantLock（在JDK1.8中由于 <code>synchronized</code>的性能得到优化，将锁换成了<code>synchronized</code>）。</p></blockquote><blockquote><p>PS：fast-fail的问题，不仅仅出现在HashMap中，Java中很多集合类型都有这个机制。<br>同时，这个问题也被收录在阿里开发手册中：<a href="https://developer.aliyun.com/article/756753?spm=a2c6h.12873639.0.0.6fee1e8bz6HCIu">为什么阿里巴巴禁止在 foreach 循环里进行元素的 remove/add 操作</a></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上文所有代码片段都是基于JDK1.7，虽然JDK1.8中对HashMap做了较大的改动。但是文章的思路和结论都是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> HashMap </tag>
            
            <tag> fast-fail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IHAVEAQUESTION - JDK1.7 HashMap 链表头插疑问？</title>
      <link href="2020/10/31/question-of-hashmap-put/"/>
      <url>2020/10/31/question-of-hashmap-put/</url>
      
        <content type="html"><![CDATA[<h2 id="IHAVEAQUESTION"><a href="#IHAVEAQUESTION" class="headerlink" title="IHAVEAQUESTION"></a>IHAVEAQUESTION</h2><p>为什么JDK1.7中HashMap链表插入时要在 <strong>遍历完一遍链表</strong> 后，再采用头插法？</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>HashMap在JDK1.7中采用 数组+链表 的存储结构。</p><p>数组的角标是在key值hashCode()的基础上进行多次高位移动的扰动后尽量保持散列，代码片段如下：</p><p>1 hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final int hash(Object k) &#123;</span><br><span class="line">    int h &#x3D; hashSeed;</span><br><span class="line">    if (0 !&#x3D; h &amp;&amp; k instanceof String) &#123;</span><br><span class="line">        return sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^&#x3D; k.hashCode();</span><br><span class="line">    &#x2F;&#x2F; 多次让高位参与运算，扰动函数</span><br><span class="line">    h ^&#x3D; (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 % -&gt; &amp;</p><p>采用更搞笑的 &amp;运算。这里length为数组的长度，源码中巧妙的设计数组的长度必须保持2的整数幂。这样设计才能保证length-1计算后得到 <strong>全1</strong> 的的二进制序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组的index确认后，就可以将键值对插入相应位置的链表了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    ... </span><br><span class="line">    int hash &#x3D; hash(key); &#x2F;&#x2F; hash</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length); &#x2F;&#x2F; %</span><br><span class="line">    &#x2F;&#x2F; 判断hashmap中有没有存在相同的key，如果有的话将这个key原来的value覆盖，并返回</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 扩容，头插</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的源码部分只保留了关键部分</p></blockquote><p>我们都知道JDK1.7中链表的插入方式是头插。头插与尾插相比是节省了一次链表全遍历的时间。直接采用下面代码即可完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 链表头插</span><br><span class="line">table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, table[bucketIndex]);</span><br></pre></td></tr></table></figure><p>这部分代码在put方法的addEntry()中，addEntry()方法在链表头插之前做了扩容操作。</p><p>但是奇怪的是，在上面put方法中有一段循环遍历链表的代码，这段代码的目的只是检查要插入的Key值是否已经存在在HashMap中，如果存在就修改，同时将原来的值返回。</p><p><strong><em>这我就很疑惑了，为什么这里明明已经遍历过一遍链表了，为什么不多写一个else，如果没有找到存在的Key值，直接将目标键值对插入在链表尾部呢？都已经遍历完了，插个值咋了？</em></strong></p><p>可能的原因只能是扩容时机不好把握？</p><p>HashMap的扩容机制是键值对size超过阈值后，数组长度扩充至之前的两倍，然后将原本下标的全部链表迁移（这个迁移的过程会倒序链表，也可能分散链表中的数据，以缩短链表的长度）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity &#x3D; newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null !&#x3D; e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 同一个元素转移后的下标有两种情况。</span><br><span class="line">            &#x2F;&#x2F; 1 与原来相同 2 在原来下标基础上加原数组长度</span><br><span class="line">            int i &#x3D; indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 这样遍历头插后，链表的顺序与之前相反</span><br><span class="line">            e.next &#x3D; newTable[i];</span><br><span class="line">            newTable[i] &#x3D; e;</span><br><span class="line">            e &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解HashMap源码的朋友可能都知道，这个扩容和迁移的代码在高并发时并不是线程安全的。可能出现循环链表，以至于get时陷入死循环。</p><p>也许正因如此，需要将链表插入和扩容的代码从之前的循环中独立出来。并采用头插的方式，尽量再循环一次链表。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>以上都是我在阅读HashMap源码后产生疑问，独立思考，自我解答的过程。</p><p>可能是很少有人产生跟我相似的疑问，所以我在网上也没能查找到准确的资料和答案。</p><p>所以以上全是自己的推断和猜测。毕竟HashMap源码不论是在数据结构还是算法思想层面都是非常优雅的。别人这么设计肯定是有原因的。哈哈</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 0/1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象的内存布局</title>
      <link href="2020/10/29/memory-layout-of-java-object/"/>
      <url>2020/10/29/memory-layout-of-java-object/</url>
      
        <content type="html"><![CDATA[<h3 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h3><p>对象的存储涉及内存的三部分：<strong>方法栈</strong>（存储指针）、<strong>方法区</strong>（存储类信息、常量、静态变量）、<strong>堆</strong>（存储对象的实例数据）。</p><p>对象在内存中存储的结构由三部分组成：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>。</p><h3 id="Java对象在内存中存储布局"><a href="#Java对象在内存中存储布局" class="headerlink" title="Java对象在内存中存储布局"></a>Java对象在内存中存储布局</h3><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.jpg" alt="Java对象在内存中存储布局"></p><a id="more"></a><blockquote><p>注意：下文涉及到的占位大小都是基于64位操作系统</p></blockquote><h4 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h4><p>占用16个字节</p><p>前8个字节是markword，会包含锁信息、GC信息、hashCode</p><p>后面4个字节为class pinter，指针压缩，内存容量超过32G会存8位</p><p>数组对象的对象头占用24个字节，启用压缩之后占用16个字节。</p><h5 id="1-markword结构"><a href="#1-markword结构" class="headerlink" title="1 markword结构"></a>1 markword结构</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/markword.png" alt="存储内容"></p><h5 id="2-Klass-Pointer（类型指针）"><a href="#2-Klass-Pointer（类型指针）" class="headerlink" title="2 Klass Pointer（类型指针）"></a>2 Klass Pointer（类型指针）</h5><p>klass pointer存储的是该对象所属的类在方法区的地址，所以是一个指针，默认Jvm对指针进行了压缩，用4个字节存储，如果不压缩就是8个字节。</p><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，这块占用4个字节。因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>实例数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。也就是说，除去静态变量和常量值放在方法区，非静态变量的值是随着对象存储在堆中的。<br>因为修改静态变量会反映到方法区中class的数据结构中，故而推测对象保存的是静态变量和常量的引用。</p><h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><p>用于确保对象的总长度为8字节的整数倍。<br>HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的。因此需要对齐补充字段确保整个对象的总长度为8的整数倍。</p><h4 id="JOL-java-object-layout-验证"><a href="#JOL-java-object-layout-验证" class="headerlink" title="JOL - java object layout 验证"></a>JOL - java object layout 验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/JolTest类中查看。</p><blockquote><p><a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a> 是一个Java技术分享的平台，欢迎大家加入</p></blockquote><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jol.png" alt="JOL"></p><hr><h3 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th>类型名称</th><th>存储大小</th></tr></thead><tbody><tr><td>boolean</td><td>1</td></tr><tr><td>byte</td><td>1</td></tr><tr><td>short</td><td>2</td></tr><tr><td>char</td><td>2</td></tr><tr><td>int</td><td>4</td></tr><tr><td>float</td><td>4</td></tr><tr><td>long</td><td>8</td></tr><tr><td>double</td><td>8</td></tr></tbody></table><h4 id="引用数据类型（Object）"><a href="#引用数据类型（Object）" class="headerlink" title="引用数据类型（Object）"></a>引用数据类型（Object）</h4><p>在栈中存储一个引用（指针），指向堆中的对象本身。</p><blockquote><p>有看到一种说法：<br>一个普通的引用类型对象，会在内存中消耗24个字节，p指针占8个字节，Object对象占16个字节。</p></blockquote><p>我的理解是引用类型的指针存储在方法栈中，即klass pointer，指向方法区中的类信息，堆中存放的是对象的成员变量。</p><p>这里就引出很多问题，因为时间和能力的关系，没有来得及考证：<br>1 引用类型中声明的基本数据类型到底存放在哪里？<br>2 引用类型中的属性，它的指针是存在哪里？<br>这类问题很绕，就像iOS中的结构体是声明在栈中的，但是结构体中声明一个class类型的属性又是存在在堆中的。</p><p>所以，不过分纠结的话，只要了解一个引用类型的变量会在栈中存储一个指针，指向堆中的对象本身即可。以Object对象为例就是16字节。</p><p>此外，这里还有一个压缩指针的概念（+UseCompressedOops），目的是提高内存的利用率。将原本占位8字节的指针压缩成4字节。</p><h4 id="字段重排序"><a href="#字段重排序" class="headerlink" title="字段重排序"></a>字段重排序</h4><p>为了更高效的使用内存，实例数据字段将会重排序。排序的优先级为：<br>long = double &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class OrderTest&#123;</span><br><span class="line">    byte a;</span><br><span class="line">    int c;</span><br><span class="line">    boolean d;</span><br><span class="line">    long e;</span><br><span class="line">    People f;</span><br><span class="line">&#125;</span><br><span class="line">class People &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>并不是完全符合，但是确实存在字段重排序</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/ordertest.png" alt="order"></p><h3 id="对象存储在堆上还是栈上？"><a href="#对象存储在堆上还是栈上？" class="headerlink" title="对象存储在堆上还是栈上？"></a>对象存储在堆上还是栈上？</h3><p>看下面这段代码，循环创建一亿次Object对象，通常理解一个空Object对象创建会在栈中存在一个4字节的指针，指向堆中的对象16字节。<br>循环创建一亿次大概会占用1.6G的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    new Object();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 38ms</p></blockquote><p><strong><em>这是为什么？</em></strong></p><p>这里要提出一个概念<strong>指针逃逸</strong>，new Object() 新建的对象并没有在外部被使用，所以它被优化为在栈上分配，我们知道方法执行完成后该栈帧就会被清空，所以也就不会有GC。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    Object o &#x3D; new Object();</span><br><span class="line">    o.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;use time: &quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：use time: 8014ms</p></blockquote><p>相关代码可以在 <a href="https://github.com/YorickYu/JPP"><strong><em>JPP</em></strong></a>/NewObject类中查看。</p><p>结论: 虚拟机指针逃逸分析是默认开启的，对象不会逃逸的时候优先在栈上分配，否则在堆上分配。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JOL </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tri-colour marking</title>
      <link href="2020/10/21/Tri-colour-marking/"/>
      <url>2020/10/21/Tri-colour-marking/</url>
      
        <content type="html"><![CDATA[<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/gc-1.gif"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU 乱序执行反证</title>
      <link href="2020/10/19/CPU-Out-of-Order/"/>
      <url>2020/10/19/CPU-Out-of-Order/</url>
      
        <content type="html"><![CDATA[<h3 id="循序运行"><a href="#循序运行" class="headerlink" title="循序运行"></a>循序运行</h3><p>主条目：指令周期<br>在早期的处理器中，指令的执行一般在以下的步骤中完成：</p><p>1 指令获取。<br>2 如果输入的运算对象是可以获取的（比如已经存在于寄存器中），这条指令会被发送到合适的功能单元。如果一个或者更多的运算对象在当前的时钟周期中是不可获取的（通常需要从主存获取），处理器会开始等待直到它们是可以获取的。<br>3 指令在合适的功能单元中被执行。<br>4 功能单元将运算结果写回寄存器。</p><h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>这种范式通过以下步骤挑选可执行的指令先运行：</p><p>1 指令获取。<br>2 指令被发送到一个指令序列中（也称执行缓冲区或者保留站）。<br>3 指令将在序列中等待直到它的数据运算对象是可以获取的。然后指令被允许在先进入的、旧的指令之前离开序列缓冲区。<br>4 指令被分配给一个合适的功能单元并由之执行。<br>5 结果被放到一个序列中。<br>6 仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器中。这个过程被称为毕业或者退休周期。</p><p>乱序执行的重要概念是实现了<strong>避免计算机在用于运算的对象不可获取时的大量等待。</strong>在上述文字的要点中，乱序执行处理器避免了在顺序执行处理器处理过程第二步中当指令由于运算数据未到位所造成的等待。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; a * 5</span><br><span class="line">v &#x3D; b++</span><br><span class="line">c &#x3D; a + 3</span><br></pre></td></tr></table></figure><p>由于1与3可并发运行，而2之b无法随即获得，因此可以先计算乘法1与加法3，再运行2。</p><a id="more"></a><h3 id="证明CPU乱序执行存在"><a href="#证明CPU乱序执行存在" class="headerlink" title="证明CPU乱序执行存在"></a>证明CPU乱序执行存在</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class OutOfOrder &#123;</span><br><span class="line">    private static int x &#x3D; 0, y &#x3D; 0;</span><br><span class="line">    private static int a &#x3D; 0, b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int i &#x3D; 0; &#x2F;&#x2F; 记录次数</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x &#x3D; 0; y &#x3D; 0;</span><br><span class="line">            a &#x3D; 0; b &#x3D; 0;</span><br><span class="line">            Thread one &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    a &#x3D; 1;</span><br><span class="line">                    x &#x3D; b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread two &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    b &#x3D; 1;</span><br><span class="line">                    y &#x3D; a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();two.start();</span><br><span class="line">            one.join();two.join();</span><br><span class="line">            if (x &#x3D;&#x3D; 0 &amp;&amp; y &#x3D;&#x3D;0) &#123;</span><br><span class="line">                System.out.println(&quot;第&quot;+i+&quot;次，出现(&quot;+x+&quot;,&quot;+y+&quot;)&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常执行期待的结果不会出现x和y同时为0的情况<br>demo中测试的是语句级乱序的现象，语句级乱序的发生说明必定存在指令级乱序<br>如果出现则说明CPU存在乱序执行</p><p>结果：<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/outoforder.png"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/12/hello-world/"/>
      <url>2020/10/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello ~ Here is a personal blog.<br>yloopdaed, the reverse spelling of deadpooly which is my network aka.<br>This blog is serve to my Github project - <a href="https://github.com/YorickYu/JPP">JPP</a> (Java promotion process).<br>you can also check out my jianshu channel - <a href="https://www.jianshu.com/u/9901b7042663">YYYYYY25</a> where stores many iOS articles i wrote before.</p><hr><p>建站的目的是为 <a href="https://github.com/YorickYu/JPP">JPP</a> 开源项目提供文章支持<br>本身自己也有记录和分享的习惯，之前的技术分享集中在简书 <a href="https://www.jianshu.com/u/9901b7042663">YYYYYY25</a><br>技术类的分享可能会在本站和简书同步更新，之前的技术类文章分享会选择性的移至本站</p><p>✨ Love &amp; Peace ❤️</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sliding window algorithm 滑动窗口</title>
      <link href="2020/10/12/slide-windows/"/>
      <url>2020/10/12/slide-windows/</url>
      
        <content type="html"><![CDATA[<p>滑动窗口本质上来源于单调性，一般可以理解为，随着左端点位置的增加，其最优决策的右端点位置单调不减。</p><p>事实上是利用决策单调性来实现复杂度优化。</p><p>时间复杂度：O(n)</p><p>可以解决的问题有：求最小区间、区间最大值、最小子串等</p><a id="more"></a><blockquote><p>LeetCode 3 <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a><br>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>滑动窗口之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    char[] chars &#x3D; s.toCharArray();</span><br><span class="line">    List&lt;Map&gt; maps &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    AtomicInteger InnerMax &#x3D; new AtomicInteger();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;</span><br><span class="line">        Character target &#x3D; chars[i];</span><br><span class="line">        Map&lt;Character, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        int innerI &#x3D; i;</span><br><span class="line">        maps.stream().filter(e -&gt; !e.containsKey(&quot;rep&quot;))</span><br><span class="line">                .forEach(e -&gt; &#123;</span><br><span class="line">                    if (e.containsKey(target)) &#123;</span><br><span class="line">                        int length &#x3D; e.size();</span><br><span class="line">                        InnerMax.set(length &gt; InnerMax.get() ? length : InnerMax.get());</span><br><span class="line">                        e.put(&quot;rep&quot;,&quot;-1&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        e.put(target, innerI);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        map.put(target, i);</span><br><span class="line">        maps.add(map);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; maps.size(); j++) &#123;</span><br><span class="line">            Map m &#x3D; maps.get(j);</span><br><span class="line">            if (m.containsKey(&quot;rep&quot;)) &#123;</span><br><span class="line">                maps.remove(j);</span><br><span class="line">                j--;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(maps);</span><br><span class="line">    maps.stream().forEach(e-&gt; &#123;</span><br><span class="line">        int length &#x3D; e.size();</span><br><span class="line">        if (e.containsKey(&quot;rep&quot;)) &#123;</span><br><span class="line">            length &#x3D; length - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        InnerMax.set(length &gt; InnerMax.get() ? length : InnerMax.get());</span><br><span class="line">    &#125;);</span><br><span class="line">    return InnerMax.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：398 ms 40.6 MB</p><p>优化版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    char[] chars &#x3D; s.toCharArray();</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    int length &#x3D; 0;</span><br><span class="line">    Map&lt;Character, Integer&gt; store &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i&lt;chars.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        if (store.containsKey(chars[i])) &#123;</span><br><span class="line">            max &#x3D; length &gt; max ? length : max;</span><br><span class="line">            length &#x3D; 1;</span><br><span class="line">            i &#x3D; store.get(chars[i])+1;</span><br><span class="line">            store.clear();</span><br><span class="line">            store.put(chars[i],i);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            store.put(chars[i],i);</span><br><span class="line">            length +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return length &gt; max ? length : max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：95 ms    39.5 MB</p><p>滑动窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">    &#x2F;&#x2F; 记录字符上一次出现的位置</span><br><span class="line">    int[] last &#x3D; new int[128];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 128; i++) &#123;</span><br><span class="line">        last[i] &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line"></span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    int start &#x3D; 0; &#x2F;&#x2F; 窗口开始位置</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int index &#x3D; s.charAt(i);</span><br><span class="line">        start &#x3D; Math.max(start, last[index] + 1);</span><br><span class="line">        res   &#x3D; Math.max(res, i - start + 1);</span><br><span class="line">        last[index] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：2 ms    38.8 MB</p><hr><p>滑动窗口其他题目:</p><p><a href="https://yloopdaed.icu/2020/12/23/sw-findsubstring/">抖音面试题：是否存在无序子串</a></p><ol start="30"><li><p>串联所有单词的子串</p></li><li><p>最小覆盖子串</p></li><li><p>至多包含两个不同字符的最长子串</p></li><li><p>长度最小的子数组</p></li><li><p>滑动窗口最大值  （感觉也可以使用动态规划算法）</p></li><li><p>字符串的排列</p></li><li><p>最小区间</p></li><li><p>最小窗口子序列</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git command</title>
      <link href="2020/10/10/git/"/>
      <url>2020/10/10/git/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然现在常用sourcetree或者直接在IDE中通过图形界面操作，但是开发中难免遇到一些棘手的问题需要使用git命令去管理项目</p><p>这里列出一些常用的命令，方便查询 <a href="#%E6%9C%AC%E5%9C%B0%E6%93%8D%E4%BD%9C">命令集</a></p><p><strong><em>&lt;更新20201114&gt;</em></strong></p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><h3 id="1-撤销本地-暂存区代码"><a href="#1-撤销本地-暂存区代码" class="headerlink" title="1 撤销本地\暂存区代码"></a>1 撤销本地\暂存区代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;filename&gt;</span><br><span class="line">git checkout -- &lt;filename&gt;</span><br><span class="line">批量撤销：</span><br><span class="line">git reset HEAD</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h3 id="2-撤销已提交的代码"><a href="#2-撤销已提交的代码" class="headerlink" title="2 撤销已提交的代码"></a>2 撤销已提交的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line">查看commit_id（查看命令历史）：</span><br><span class="line">git reflog </span><br></pre></td></tr></table></figure><h3 id="3-原本版本退回"><a href="#3-原本版本退回" class="headerlink" title="3 原本版本退回"></a>3 原本版本退回</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br><span class="line">git push -f origin master</span><br><span class="line">查看commit_id（查看命令历史）：</span><br><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="4-创建分支并提交到远程"><a href="#4-创建分支并提交到远程" class="headerlink" title="4 创建分支并提交到远程"></a>4 创建分支并提交到远程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git push origin dev</span><br><span class="line">删除远端分支：</span><br><span class="line">git push origin --delete dev</span><br><span class="line">删除本地分支：</span><br><span class="line">git branch -d dev</span><br><span class="line">查看本地、远端分支：</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><p>1 初始化一个仓库: </p><pre><code>git init</code></pre><p>2 添加文件到Git仓库，分两步：</p><pre><code>2.1 git add &lt;fileName&gt; 可以反复多次添加，也可以一次添加多个文件(git add . / git add file1 file2)2.2 git commit -m “message” 提交</code></pre><p>3 git status 随时掌握工作区的状态 git status -s 简短信息查看</p><p>4 git diff <fileName> 查看修改的内容 git diff –cached 查看已缓存 git diff HEAD 查看所有 git diff –stat 只显示摘要</p><p>5 在本地版本间穿梭: </p><pre><code>git reset --hard commit_id (回到上一版本：git reset —hard HEAD^)</code></pre><blockquote><p>ps：在Git中，用HEAD表示当前版本，上一版本就是HEAD^，同理上上版本HEAD^^，如果往上100个版本，可以写成HEAD~100</p></blockquote><p>6 git log 可以查看历史提交记录，以便确定要退回版本的commit_id，简化信息：</p><pre><code>git log --pretty=oneline</code></pre><p>7 查看命令历史:</p><pre><code>git reflog </code></pre><p>8 丢弃工作区的修改：</p><pre><code>git checkout -- &lt;fileName&gt; (这里的 -- 很重要，如果没有--，就编程切换分支的命令)</code></pre><p>9 丢弃暂存区的修改：</p><pre><code>第一步，git reset HEAD &lt;fileName&gt;(HEAD表示当前最新版本)第二步，git checkout -- &lt;fileName&gt;</code></pre><p>10 丢弃版本库的修改：和第5条同理，其实就是切换回先前的分支:</p><pre><code>git reset --hard commit_id</code></pre><p>11 删除文件：</p><pre><code>11.1 方法一：先删除本地rm &lt;file&gt;，然后再git add/rm &lt;file&gt;，git commit -m “message”11.2 方法二：直接git rm &lt;file&gt;，git commit -m “message”ps: 如果是rm &lt;file&gt;，可以直接通过git checkout -- &lt;file&gt;修改回来</code></pre><h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><p>1 在GitHub上创建完远程仓库后，在本地的仓库下运行命令，关联远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@server-name:path&#x2F;repo-name.git</span><br></pre></td></tr></table></figure><p>2 下一步，使用命令：，将本地库的所有内容推送到远程库上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><p>ps：第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送命令即可省略，直接用git push origin master</p></blockquote><h2 id="创建、合并分支"><a href="#创建、合并分支" class="headerlink" title="创建、合并分支"></a>创建、合并分支</h2><p>1 查看分支：git branch</p><p>2 创建分支：git branch <name></p><p>3 切换分支：git checkout <name></p><p>4 创建+切换分支：git checkout -b <name></p><p>5 合并某分支到当前分支：git merge <name></p><blockquote><p>ps：合并分支时加入–no-ff参数，表示禁用Fast forward：git merge –no-ff -m “merge with no-ff” <name>这种操作合并后的历史有分支，能看出曾经做过合并，而Fast forward合并就看不出来</p></blockquote><p>6 删除分支：git branch -d <name></p><p>7 查看合并分支图：git log –graph</p><h2 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h2><p>情景：在develop分支开发时，突然报出紧急bug：</p><p>1 在develop分支把工作现场“贮藏”起来：</p><pre><code>git stash</code></pre><p>2 然后确定要在哪个分支上处理bug，假如在master上修复，就从master创建临时分支：</p><pre><code>git checkout master git checkout -b bug001</code></pre><p>3 在bug001分支上处理bug，修复完成后切回master进行合并：</p><pre><code>git merge --no-ff -m “merge with no-ff” bug001</code></pre><p>4 现在bug处理完了，回到develop查看刚刚”贮藏”的代码：</p><pre><code>git stash list</code></pre><p>5 把”贮藏”的代码拿到develop上，继续开发：</p><pre><code>git stash pop(git stash apply + git stash drop)</code></pre><blockquote><p>ps：apply恢复，但stash的内容并不删除，需要再用drop删除；pop恢复的同时也删除了</p></blockquote><h2 id="新特性分支"><a href="#新特性分支" class="headerlink" title="新特性分支"></a>新特性分支</h2><p>情景：开发一个新feature，但是突然说这个功能不做了（在新分支上已经执行add,commit操作）</p><p>丢弃一个没有被合并过的分支，强行删除该分支：</p><pre><code>git branch -D &lt;name&gt;</code></pre><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>1 推送本地分支到远端，如果推送失败，先git pull抓去远程的新提交</p><pre><code>git push origin &lt;name&gt;</code></pre><p>2 拉取远端分支到本地：</p><pre><code>git checkout -b &lt;name&gt; origin/&lt;name&gt;</code></pre><blockquote><p>ps：查看权限：git remote -v</p></blockquote><p>3 建立本地分支和远程分支的关联：</p><pre><code>git branch --set-upstream &lt;name&gt; origin/&lt;name&gt;</code></pre><blockquote><p>ps：如果git pull提示no tracking information，则说明没有创建关联</p></blockquote><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>git rebase操作可以把本地未push的分叉提交历史整理成直线</p><h2 id="标签tag"><a href="#标签tag" class="headerlink" title="标签tag"></a>标签tag</h2><p>1 创建新标签 git tag <tagname> 默认添加在HEAD上，如果要特定添加在某条记录上可以 </p><pre><code>git tag &lt;tagname&gt; &lt;commit id&gt;例: git tag v1.0 fa=52c662</code></pre><p>2 git tag -a <tagname> -m ‘ababababllal’</p><p>3 git tag 查看所有标签</p><p>4 git tag -d <tagname> 删除标签</p><p>5 推送标签到远程</p><pre><code>git push origin &lt;tagname&gt; </code></pre><p>6 推送所有标签到远程 </p><pre><code>git push origin --tags </code></pre><p>7 删除远程标签，分两步：</p><pre><code>第一步，先删除本地标签 git tag -d v1.0第二部，删除远程，命令也是push，git push origin :refs/tags/v1.0</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理财营-学习笔记</title>
      <link href="2020/10/07/money-management/"/>
      <url>2020/10/07/money-management/</url>
      
        <content type="html"><![CDATA[<!-- ## 小白理财营学习笔记 --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>国庆期间形成安排比较满，前半段安排了家庭短途自驾旅行，后半段要去外地参加朋友的婚礼。</p><p>没有太多大块的时间可以学习和整理，于是报名参加了一个基础的理财知识的训练营，利用晚上睡前的时间了解一下理财相关的知识、丰富一下自己的知识库。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>课程共12天，所以我也会按每天的内容进行更新。全部学习结束后争取写一写自己的收获和感悟。</p><a id="more"></a><hr><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/1.jpg"></p><p>第1-3天，我们重点讲解投资理财的底层逻辑，建立好对于理财的正确认知</p><p>第4-12天，我会重点带着大家认识市面上常见的各类工具，例如：股票，REITs，指数基金、货币基金、国债逆回购，客观认识到各类工具的风险、作用以及收益情况，学会以后大家就不会被骗了，并且还能掌握几个无风险理财工具的操作</p><p>1️⃣聪明消费，摆脱月光，增加结余<br>2️⃣建立正确的金钱观、理财观，初步形成富人思维，投资不再被骗<br>3️⃣了解各种理财工具的风险和收益情况，并掌握几个无风险理财工具，形成理财的底层逻辑</p><p>学习理财不能帮助你一夜暴富，但是能够帮你梳理财务管理上的漏洞，弄清楚自己的财务状况，增加非工资收入，迈向更好的生活。</p><p>[衰]所以大家有没有发现：</p><p>三十年前，一人工作能养活全家。<br>三十年后，全家工作难养一个孩子。</p><h4 id="四条忠告"><a href="#四条忠告" class="headerlink" title="四条忠告"></a>四条忠告</h4><p>♥️欠债的人应当消除「坏支出」和「坏支出」产生的负债</p><p>♥️如果是能“帮你赚钱”的负债要尽可能的延长偿还时间。</p><p>♥️对于消费贷款，欠债的人应该将不用于生活的钱一半存起来，另一半用于还债。</p><p>♥️对于所有的消费，都要问自己【这真的有必要吗？】，尽可能的减少【不必要的】开支</p><h4 id="思维层次"><a href="#思维层次" class="headerlink" title="思维层次"></a>思维层次</h4><p>1⃣️第一层次：控制不住消费欲望，为了新出的包包、鞋就要花完自己所有的零花钱。</p><p>2⃣️第二层次：建立自己的储蓄罐，为了自己的梦想开始运用自己的优点来赚钱，但是没有自己的鹅。</p><p>3⃣️第三层次：开始养“鹅”</p><p>因为思维决定人的行为，行为成为人的习惯，最后反应在你的财务结果上</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/6.png"></p><p>还是那句，富人思维找办法，穷人思维找理由；富人思维在行动，穷人思维在观望；富人思维想着改变，穷人思维只会哀叹。</p><p>有句话分享给大家，我们常常高估一天内可以做到的事情，却低估了一年里可以做到的事情。🔔</p><p>放在理财上就是，我们常常对一天的收益率抱有过高的期望，却对三年、五年、十年甚至更长的时间里的收益率没有耐心等待。</p><p>【富人关键思维-第一条】</p><p>🔆获得经济独立、财务自由的意义是什么？</p><p>🌹经济独立、财富自由并不是独善其身，它的本质是让自己、家人变的更好的能力。</p><p>【从个人讲】，可以更好的选择自己喜欢的东西、自己喜欢的生活方式、婚姻方式，最终实现踏踏实实靠自己，得来属于自己的精神自由。把经济这个生存的“命脉”交给他人，其实就是把自己选择的权力让给了他人，也把自己生活的主动权让给了他人。</p><p>【从家庭讲】，与爱人共同分担家庭的财务重担，应对老人的医疗花销、孩子的教育花销，让家庭关系因为共同的努力获得财富而更美好，而不是因为钱受到冲击而动摇。</p><p>🌹一句话总结：提升理财技能，实现财务独立，获得更多自主选择的权力，获得给家人更好的生活的能力。</p><h2 id="正篇-1"><a href="#正篇-1" class="headerlink" title="正篇-1"></a>正篇-1</h2><h3 id="1-三大资产"><a href="#1-三大资产" class="headerlink" title="1 三大资产"></a>1 三大资产</h3><p>今天的课程分为 3 个部分：</p><p>1、什么是理财？必须有钱才能理财吗？</p><p>2、三大资产，到底什么东西能帮我们赚钱？哪些东西会让我们亏钱？</p><p>3、穷人和富人之间的差别是什么？</p><h4 id="♠️重点一：【理财】"><a href="#♠️重点一：【理财】" class="headerlink" title="♠️重点一：【理财】"></a>♠️重点一：【理财】</h4><p>投资≠理财，投资只是理财的一部分，理财是很广泛的概念。</p><p>理财包含：制定家庭日常消费计划、投资计划、保险计划、教育金计划、养老金计划等等</p><p>🌟重点，资产真正的内涵是【现金流】</p><h4 id="♠️重点二：【三大资产】"><a href="#♠️重点二：【三大资产】" class="headerlink" title="♠️重点二：【三大资产】"></a>♠️重点二：【三大资产】</h4><p>⭐️生钱资产</p><p>✅生钱资产：持有期间能给自己持续带来净现金流入的东西</p><p>常见的生钱资产有：股息、版税、利息，房屋租金等</p><p>⭐️耗钱资产</p><p>❌耗钱资产：持有期间能给你【持续】带来净现金流出的东西。</p><p>⭐️其他资产</p><p>⭕️其他资产：持有期间产生的净现金流为0的东西。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/7.png"></p><p>例：房子根据情况的不同，可以分为三种不同的资产类型</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/8.jpg"></p><h4 id="♠️重点三：【穷人和富人的区别】"><a href="#♠️重点三：【穷人和富人的区别】" class="headerlink" title="♠️重点三：【穷人和富人的区别】"></a>♠️重点三：【穷人和富人的区别】</h4><p>【关键富人思维-第一条】</p><p>这里的差别从资产结构的角度切入</p><p>1 大部分人包括我自己都属于这个情况。主要的经济来源都是依靠工资，虽然随着工作的年限增长，工资也得到一定的提升。但是同样伴随家庭和个人开销的增加。所以感觉越来越穷，生活的压力也越来越大</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/9.png"></p><p>2 正确的资产结构应该如下，工资收入应该补充到适当的理财产品中，利用少量的工资和大量的理财收益维持生活的支出</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10.jpg"></p><p>【关键富人思维-第二条】</p><p>⭐月光或者积蓄不多的人，为什么不能等有钱再学习理财？</p><p>🌹月光和积蓄不多本质是错误理财思维造成的结果。</p><p>【在花钱上】，很多都是坏支出，一心只想买买买，很多东西在冲动消费之后要么用了几次就放置一边，要么后悔自责又在下次陷入到恶性循环，但对于投资自己成长的好支出，却又思前想后。其关键在于，没有好支出、坏支出的思维意识，被欲望牵着走，没有将有限的资金花在刀刃上。</p><p>【在攒钱上】，单纯靠工资攒钱是最低效最差的方式，如果只靠工资收入来攒钱，很可能到退休了还没有攒够理财的本金。真正聪明的小伙伴会在获得第一笔工资收入时就开始选择合适的理财工具来积累自己的本金和非工资收入了。</p><p>具有富人思维的人，哪怕是现在月光或者积蓄不多，就会从一开始就通过工资和非工资收入两条路径来增加自己的收入。两条腿走路肯定比只靠工资收入一条腿走的更快更远。</p><p>🌹一句话总结：提升财富要靠工资和非工资收入【两条腿】走路，绝对不能独腿前行。</p><p>【关键富人思维-第三条】</p><p>🌹普通或中产家庭为什么不能沉溺在自己的工资收入中，不重视理财？</p><p>因为不安全，看似收入比较稳定，其实抗风险能力很低，因为有房贷车贷要还，小孩要养，大量的耗钱资产占主要，甚至父母的医疗还要大量的开销。</p><p>【孩子还未成人的家庭】<br>孩子没有收入，花销逐年增大，这时候如果夫妻中有一人遇到一段时间不能工作的情况，家庭财务整体情况可能会出现较大落差，进而影响生活质量得不到保障。</p><p>【全职宝妈的家庭】<br>女性负责照顾孩子，没有工资性收入，只有丈夫一人的收入是家庭收入的主要来源，如果丈夫遭遇大裁员等意外情况，家庭很可能立即陷入坐吃山空的财务危机中，或者啃老的尴尬境地。</p><p>所以普通家庭更需要尽早尽快建立自己的【非工资收入体系】，【在没有意外发生的时候】可以为家庭提供一份额外的收入，补贴家用；【在意外发生的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。</p><p>🌹学习并掌握获得非工资收入的能力，是为自己负责，也是为了家人生活安全负责。</p><p> 总结：普通人的【财务安全】来自工资收入和非工资收入的双管齐下，没有充沛的非工资收入的中产家庭，谈不上财务安全健康。</p><h3 id="2-复利"><a href="#2-复利" class="headerlink" title="2 复利"></a>2 复利</h3><p>今晚的课程主要讲三个重点，两个富人关键思维：</p><p>1、复利是什么？</p><p>2、复利的反向作用</p><p>3、复利的头号敌人</p><h4 id="♠️重点一：什么是复利？"><a href="#♠️重点一：什么是复利？" class="headerlink" title="♠️重点一：什么是复利？"></a>♠️重点一：什么是复利？</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/11.png"></p><p>复利本质上是一种让钱高效生钱的思维方式。<br>影响复利的因素是：本金 时间 收益率</p><p>⭐第一个重点要素：本金。本金越多，最终收益越大。<br>⭐第二个重点要素：时间<br>⭐复利的第三个重要因素：【收益率】，影响非常大！非常大！</p><h4 id="♠️重点二：复利的反响作用—通货膨胀"><a href="#♠️重点二：复利的反响作用—通货膨胀" class="headerlink" title="♠️重点二：复利的反响作用—通货膨胀"></a>♠️重点二：复利的反响作用—通货膨胀</h4><p>你的收益率低于10%,你的钱就在贬值，钱会越来越不值钱。</p><h4 id="♠️重点三：复利的头号敌人—亏损"><a href="#♠️重点三：复利的头号敌人—亏损" class="headerlink" title="♠️重点三：复利的头号敌人—亏损"></a>♠️重点三：复利的头号敌人—亏损</h4><p>一定要记住：</p><p>1、不懂的东西不要碰<br>2、只操作在国家交易所交易的工具</p><p>【关键富人思维-第四条】</p><p>⭐为什么说复利三要素中最容易掌控的是收益率？</p><p>🌹复利三要素，本金、时间、收益率。把钱存在保险箱中，复利会发挥反向作用，把钱一口一口吃掉，长期来看1万元每年贬值500元以上。投资开始的越早，时间要素发挥越大，复利的正向作用越早发挥作用。本金大的人，复利作用也比较大，但是投错了地方，本金再大也会亏完。如果本金和时间都不占优势，那么最有效的就是提高年化收益率，而提高年化收益率的关键在于自己的理财能力。</p><p>🌹一句话总结：【时间无法改变，越早开始越好；本金依赖生钱资产；收益率源于理财能力，理财能力才是决定复利终值的关键】</p><p>【富人关键思维–第五条】</p><p>⭐为什么说投资自己的大脑、学会理财技能也是中产升级之法？</p><p>🌹如同经典书籍《富爸爸》中说的，穷人卖时间换钱，其实本质是“卖命”。他们抱怨自己没有钱，其实本质是他们没有认识到投资自己的大脑是最快的脱贫致富之法。</p><p>比如一个专家花费一生写了一部巨著，我们花100元买了他的书回来看，其实某种意义上我们是买到了他一生的生命成果，学到了能获得成千上万的收益，这就叫“站在巨人的肩膀上”，贫穷的矮人站在“巨人的肩膀上”也会达到巨人的视野。</p><p>但很多人心疼这点投资大脑的钱，所以一直什么都不懂，一直贫穷下去。反之，穷人也能通过投资自己的头脑，学习他人成功的方法，买他人花了很多时间转化的成果，变成自己的东西，快速创造财富，这是最快的脱贫之法。</p><p>🌹一句话总结：心疼投资大脑的钱，一直什么都不懂，不是被通货膨胀割韭菜，就是被投资市场割韭菜，一直穷下去。反之学习他人成功的方法，变成自己的技能，是最快的脱贫、升级之法。</p><h3 id="3-理财工具"><a href="#3-理财工具" class="headerlink" title="3 理财工具"></a>3 理财工具</h3><p>今天讲的21种理财工具，我们不用样样精通，但是要抓住重点：</p><p>1、哪些工具好？</p><p>2、哪些工具不能碰？</p><p>3、哪些工具是我们财务自由的核心工具？</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/12.png"></p><h4 id="⭕无风险的理财工具"><a href="#⭕无风险的理财工具" class="headerlink" title="⭕无风险的理财工具"></a>⭕无风险的理财工具</h4><p>国债，定期存款，国债逆回购，货币基金，银行理财（保本型）</p><p>我们了解两个就行，【国债逆回购】和【货币基金】</p><p>国债：“国债，又称国家公债，是国家以其信用为基础，按照债券的一般原则，通过向社会筹集资金所形成的债权债务关系。国债是由国家发行的债券，是中央政府为筹集财政资金而发行的一种政府债券，由于国债的发行主体是国家，所以它具有最高的信用度，被公认为是最安全的投资工具。”</p><p>【国债逆回购】： 本质就是一种短期贷款。也就是说，个人通过 国债回购市场 把自己的资金借出去，获得固定的 利息收益 ；而回购方，也就是借款人用自己的国债作为抵押获得这笔借款，到期后还本付息。</p><p>【货币基金】也称“火鸡”。货币基金家族有个家伙是很出名的，它叫“余额宝”。其他货币基金也和余额宝差不多</p><p>🧧分享个【捡钱小秘密】给大家</p><p>捡钱小秘密由【国债逆回购】和【货币基金】组成。</p><p>我们平时把零钱买货币基金，每年可以获得3%左右的无风险收益。当国债逆回购收益高时，比如大于10%以上，卖掉货币基金直接买入国债逆回购。这样就可以获得几天的高收益。等国债逆回购的钱回来后，再当天买进货币基金。</p><p>👉【场内基金】就是在证券市场内，也就是二级市场买卖基金，需要自己去开立股票账户进行购买的。比如可以在场内买ETF基金、LOF基金、封闭式基金等。场内基金咱们后面重点会学习【指数基金】，有筛选方法和购买标准，收益率在12%以上，风险较低。</p><p>👉【场外基金】则是在证券市场外买卖基金，比如银行、基金公司、第三方平台(如天天基金网、支付宝、微信等)，不需要开股票账户就可以购买。场外基金咱们不会学，因为风险较大，收益也不是很高，小白不懂乱买很容易亏钱。</p><h4 id="⭕低风险的理财工具"><a href="#⭕低风险的理财工具" class="headerlink" title="⭕低风险的理财工具"></a>⭕低风险的理财工具</h4><p>⭐它又分为两类👇<br>一种是【低风险中等收益】，年化收益率一般6%—15%之间，主要包括【分级基金A】、【可转债】、【债券基金】、【股票指数基金】<br>另一种是【低风险高收益】，年化收益率一般在15%—30%之间，主要包括生钱资产类型的【股票】、【REITs】</p><p>决定【投资风险和收益大小的】不是【理财工具】本身，而是投资人的【理财技能】</p><p>🎈股票<br>对于每年【有持续分红】的股票而言，就是【生钱资产】</p><p>买了【不分红的股票】，只能靠预测未来的价格上涨，这是不确定性的，就是【其他资产】</p><p>🎈 REITS，读作 “瑞子”就行<br>这个是重点，REITs是全球配置房产的理财工具</p><p>【生钱资产类型的REITs】就是持续高分红的REITs。其实一般的REITs都是持续高分红的。因为各国法律都规定REITs每年至少要把90%以上的净利润分配给投资者。</p><p>🎈 【股票指数基金】复制股票指数的股票基金。由于股票指数具有永生不死，长期上涨的特点。在合适的价位买入股票指数基金长期持有几乎没有风险。其年化收益率一般在10%—15%。🌹</p><h4 id="⭐中风险的理财工具"><a href="#⭐中风险的理财工具" class="headerlink" title="⭐中风险的理财工具"></a>⭐中风险的理财工具</h4><p>黄金、不保本的银行理财等</p><h4 id="⭐高风险的理财工具"><a href="#⭐高风险的理财工具" class="headerlink" title="⭐高风险的理财工具"></a>⭐高风险的理财工具</h4><p>p2p、私募基金、比特币收藏品、期货等</p><p>实现财务自由的三大核心工具:</p><p>只有当企业、股票、REITs具有生钱资产的属性的时候，才能算成我们的财务自由核心工具</p><p>💰这三大核心工具，只要用好了其中的一个就能【脱贫致富】</p><p>【购买生钱资产】，主要就是购买生钱资产类型的股票和REITS</p><p>代表人物比如巴菲特 罗杰斯</p><p>【创造生钱资产】 ，就是创造企业</p><p>比如马云、马化腾</p><p>而我们普通人，大部分都可以通过购买生钱资产致富</p><p>♥️用好了企业这个核心工具，你会成为企业家</p><p>♥️用好了股票或REITs这两个核心工具，你会成为投资家；</p><p>♥️用好了企业、股票、房地产这三个工具，你会成为资本家</p><p>今天的课程共三个重点：</p><p>【重点一】：短期零钱管理，关注国债逆回购、货币基金。</p><p>【重点二】：低风险投资工具，重点关注生钱资产类型的股票、REITs</p><p>【重点三】：实现财务自由的三大核心工具——股票、REITs、企业</p><p>【关键富人思维—第六条】</p><p>🌟到底什么时候可以开始投资？</p><p>为什么有的人买股票会亏钱，因为只看了几本书，学了几天课就急急忙忙去股市。我们学车考个驾照还要一个月，而理财投资作为一个高度专业化、精细化的领域，不经过系统的学习就去“尝试”，这和训练了两天、看了几本武侠小说就上战场的士兵有什么区别？</p><p>士兵进行系统训练是为了保命，投资者进行系统的理财方法学习是为了保钱的“命”。反之，学半瓶水，一知半解就去投资市场“试试”，只会学到教训和被割韭菜，收获痛苦。那些经过系统投资训练的人会把那些无知而自以为是的人收割的一滴血不剩。在股市里，你赚的钱是别人亏得，你亏的也被别人赚走了。</p><p>⭕【投资的真相】，不系统学习理财技能就想赚快钱，本质是送钱的命，当你打算投资一个目标，要有系统的分析方法，不再为了涨跌而心惊胆战的时候，这才是投资可以真正开始的时候。</p><p>一句话总结：投资第一原则，不懂不要投，懂了安心投，盲目“尝试”无疑送命，系统训练方可真正保住钱“命”</p><p>🎁正确系统的投资技能包括：</p><ul><li>①理财的底层逻辑、富人思维</li><li>②股票的海选</li><li>③精选出好公司</li><li>④财务报表分析</li><li>⑤企业分析</li><li>⑥计算好价格</li><li>⑦制定买进标准</li><li>⑧制定持有标准</li><li>⑨制定卖出标准等</li></ul><h3 id="4-分析财报"><a href="#4-分析财报" class="headerlink" title="4 分析财报"></a>4 分析财报</h3><p>🎤那大家猜猜，在理财中学习【财务报表】最重要的作用是什么呢？</p><p>💎答：最重要的作用是排雷，是证伪，而不是证实。</p><p>一、财务报表到底是什么？有什么用？</p><p>可茫茫股市几千只，光每年分红的股票就有2000多家，怎么精准的判断是不是含金量最高的【股票】呢？</p><p>判断标准之一就是要能读懂【财务报表】<br>后面懂了股票的筛选方法，【REITs】工具得筛选方法同理</p><p>💎学习【财务报表】，老师这里给大家几个学习提示：</p><p>1、从今晚开始课程中有看不懂的是正常现象，小白营的时间有限，大家先掌握思路，就是知道选好公司，好股票，是凭借什么依据什么方向去判断的就可以了<br>具体财报怎么看，是有23个步骤的，在完整的《财富自由实践课》中有详细讲解和实操带领</p><p>2、不要局限在财报的数字和计算中，这并不是重点，财报的关键是看【结构】，看数字谁都会晕，不纠结数字。</p><p>3、思考造成文中，不同家庭财务状况的原因是什么？三类资产和好/坏支出，都是怎么在他们的家庭中起到作用的？</p><p>4、试着写出自己家庭的财报是什么样，三类资产和好/坏支出，负债率等，各是怎样的情况？占比多少？并应该怎样去调整？列在纸上写一写，生活方向就清晰很多了</p><p>⭐应付：【先用货，后给钱】</p><p>⭐预收：【先收钱，后发货】</p><p>🎤那么，应付+预收是不是能证明我企业很有实力，而且，我现金流很大。</p><p>⭐应收：【先发货，收不到钱】</p><p>⭐预付：【先给钱，收不到货】</p><p>【应付+预收】我们占用别人的钱</p><p>【应收+预付】别人占用我们的钱</p><p>通过：一家公司负债项中【应付预收】减去资产项中的【应收预付】来判断公司的竞争力强弱。</p><p>相减得出金额越大，说明公司的竞争力越强。</p><p>相减得出金额越小，说明公司的竞争力越弱。</p><p>那通过什么来判断公司的【安全性】呢？</p><p>我们可以用【资产负债率】来判断公司的偿债风险</p><p>总负债÷总资产*100%=资产负债率。</p><p>👉资产负债率【大于70%】的公司，偿债风险比较大</p><p>👉资产负债率【小于40%】的公司，几乎没有偿债风险</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/13.png"></p><p>【关键富人思维—第七条】</p><p>为什么月光、负债的人应该拿出一部分资金学习理财技能？</p><p>这里的负债主要指的是让自己的财务状况不断恶化的【坏负债】。</p><p>⭐️月光和负债只是不懂理财的结果，没有理财技能才是月光和负债的原因。很多人一方面不懂投资的骗局，一方面又眼红想赚一下，最终都入了骗局的“坑”，如果提前投资自己的大脑，难道还会犯这样的错误吗？还有很多人，本来钱就不多，贷款买了一堆耗钱资产，要么不断的刷信用卡、花呗、借呗，窟窿越来越大，要么生活拮据，每天人前风光，人后遭殃。</p><p>但对于投资自己，提升理财技能的好负债，他们却斤斤计较，错失了复利的好机会，这样的人生活只会越来越难过。</p><p>【成长有顺序，生活致富也有顺序】——先投资大脑，掌握理财的技能，然后再去生钱，月光、负债不学习只会越来越穷</p><p>🌹一句话总结：月光、负债是财务病，病根是缺少理财技能，忽视病因、不治病根，坏支出、坏负债只会越来越严重。</p><p>月光负债只是结果，不会理财是病因</p><p>投资的准则是【不懂不要投，懂了放心投】</p><p>投资的核心是【生钱资产】</p><p>投资的实质是投资【好公司/好项目】</p><p>🌟【正确理财步骤】</p><p>🎈第一步：学习富人思维，增值自己，先投资自己掌握理财技能。</p><p>🎈第二步：有了理财技能，自然就具备精准识别优质生钱资产的能力（选出好股票、好REITs）。</p><p>🎈第三步：每月收入先拿出一部分去投资，购买生钱资产，长期持有积累，利用复利发挥威力获得收益。</p><hr><p>❤️越是没钱的时候越要理财，越要重视投资自己。</p><p>❤️因为投资大脑掌握理财技能是回报最高、变现最快的投资。</p><p>❤️一定要学会让钱为自己工作，支配钱，驾驭钱</p><p>❤️内在拥有，外在呈现；内在没有发生改变，人是永远无法赚到自己认知以外的钱的</p><h3 id="5-反常识股票"><a href="#5-反常识股票" class="headerlink" title="5 反常识股票"></a>5 反常识股票</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/20.jpg"></p><h4 id="⭕️重点1：股票的定义"><a href="#⭕️重点1：股票的定义" class="headerlink" title="⭕️重点1：股票的定义"></a>⭕️重点1：股票的定义</h4><p>🎤股票到底是什么？</p><p>其实【股票】是公司的所有权凭证。</p><p>🎤人们一开始购买股票是希望能够赚到股票的什么钱？</p><p>是分红</p><p>🎤企业为什么要发行股票呢？</p><p>企业发行股票很大一部分是为了融资。</p><p>【重点】企业发行股票的主要目的就是为了融资，出让股份，让大家投钱，你用大家的钱，去干更大的事，赚到了钱，一起分。</p><p>🎤那股市是什么意思？</p><p>股市的存在让买卖股票变得非常的方便</p><p>中国A股市场有两大交易所，分别是上交所和深交所，相当于两个“菜市场”</p><p>A股交易时间是：</p><p>每周一到周五：早上9点30 - 11点30；下午1点 - 3点；节假日休市</p><p>🎤那我们投资【好公司】的股票赚的是什么钱呢？</p><p>①【公司持续的现金分红】<br>②【股票价格上涨带来的价差收益】</p><p>🎤为什么股票的收益率那么高呢？</p><p>因为股票的背后是公司，公司是一个国家创造经济的主体，因此一国的【股市平均收益率】一定是远远大于该国【GDP增长率】的。</p><p>👉中国的GDP增长率在6.5%左右；</p><p>中国股市的年化收益率一定是大于6.5%的。</p><p>为什么会这样呢？因为GDP的组成中，企业是创造价值最多的部门，而股票背后的实质就是企业</p><p>好上市公司的平均收益率&gt;所有上市公司的平均收益率&gt;所有公司的平均收益率&gt;GDP增长率&gt;银行存款收益率</p><p>据统计：</p><p>👉中国的GDP增长率在6.5%左右；</p><p>👉中国所有上市公司的平均年化收益率大于12%以上；</p><p>👉中国【好】上市公司的平均年化收益率大于24%以上。</p><p>买了好公司的股票，就相当于中国甚至世界最优秀的管理团队为自己打工。</p><h4 id="⭕️重点2：什么样的股票算是好股票？"><a href="#⭕️重点2：什么样的股票算是好股票？" class="headerlink" title="⭕️重点2：什么样的股票算是好股票？"></a>⭕️重点2：什么样的股票算是好股票？</h4><p>股票的本质是企业，好企业的股票就是好股票。股价下跌是市场的正常现象，只要公司利润在增长，这个公司就是有好公司的潜质。</p><blockquote><p>小科普：不复权价格是「真实的价格」，后复权则显示的它的「真实价值」，即分红送股转股都加进去。<br>例如你的公司市值（市场价）3元，你要给股民分红，分1元，你不能自己掏腰包垫吧。所以就要从公司市值减1元，你的公司现在就是2元（前复权），其实你的公司值3元（后复权）。</p></blockquote><p>认为买股票有很大风险的同学，想想是不是以前用错了方法？同时也直观的，让大家理解到，好公司长期持有的价值回报是很大的</p><p>所以，在正确投资股票中，建议同学们不要经常看股票行情波动，这对工作、生活、财务自由以及投资没有任何好处，实在忍不住想看看股票价格的走势，那就每年看一两次就够了。</p><blockquote><p>重点强调：正确理财的人，是根本不用花时间关注股价波动的</p></blockquote><p>⭕为什么说好公司股价暴跌反而是赚钱的机会</p><p>只要公司真实利润在增长，股价下跌你反而会更赚。</p><p>股价波动不是风险，不要怕，真正的风险是公司的真实利润在减少。</p><p>股价越跌，它的股价变的更低，你可以拿着【分红的钱】再以低价买入更多股票。</p><p>这时候你得到的股票数量就越多，分红是按照你【持股数量】分的。</p><p>股票越多，分红就越多。</p><p>分红越多，股票就越多。</p><p>一并回答4个问题：</p><ul><li>1、企业为什么发行股票？</li><li>2、股票、股份是什么？</li><li>3、不懂理财的人，是怎么炒股的呢？</li><li>4、正确投资股票的姿势是什么？</li></ul><p>👉1、企业为什么发行股票？</p><p>假设你开了家超市，一共投入10万，超市经营得很好，每年可赚2万，回报率20%。你们掐指一算，按照20%的回报率，如果投入1000万来扩大店面或开连锁，那每年就可以赚200万！</p><p>于是你们想方设法找钱，但终究资源有限，可用于抵押的资产又不多，所以你们从亲戚朋友、银行一共也只借到到了90万，因此最多每年也只能赚20万。那怎么办？还能去哪里去找钱呢？</p><p>这时候你想，既然我能把超市收益经营得这么好，如果在网上发个帖子，告知所有人我的项目，投10万即可赚2万，那肯定很多人都来投资！</p><p>有钱大家一起赚，而你在使用【借力思维】赚钱，这个模式其实就是发行股票，企业发行股票的主要目的就是为了融资！只不过企业的规模大，融资大，这么说大家是不是就更容易明白了</p><p>👉2、股票、股份是什么？</p><p>说白话就是，股票是一个凭证，证明你拥有某一家公司的股份，即股票是股份的凭证。股票的本质是企业。那股份是什么呢？股份就是你对某家公司拥有的所有权。</p><p>👉3、不懂理财的人，是怎么炒股的呢？</p><p>是关注股价的浮动趋势、大盘、K线去预测市场。这种基本都是被割韭菜。</p><p>举例说明：好比 你低价买了一家企业的股票，然后涨了一点就卖了，你赚了。然后我高价买了这家公司股票，也不了解企业实质，光看价格，没等到涨，我就心急卖了，我就赔了。</p><p>这种交易方式完全不看股票背后的公司，只是在预测股价的涨跌，但是没有任何一个人能准确预测市场，像这样赚差价的行为本质是在赌博，长期操作下去，不仅会损失惨重，还很有可能难以承受股价的波动导致，最后精神崩溃。</p><p>这就叫投机，本质是在赌涨跌。</p><p>股票的选择就是这2点</p><p>你只需要用正确的方法，找到最优质的好公司，以【合理的价格】买入和卖出就可以了</p><p>在正确的投资中，根本没有所谓的“长线”“短线”这一说，这都是不懂正确投资人的思维词汇概念。</p><p>正确投资是需要给企业估值的，是跟随企业的价值增长而增值，就不会被短期股价波动吸引注意力了</p><p>⭕正确投资一定是买最优质的好公司，赚钱就是【必然的事情】。</p><p>👉4、正确投资股票的姿势是什么？</p><p>是靠企业的发展带来内在价值的提升，表现形式为净利润的不断提升（分红是利润的一部分），这是正确的投资方式。</p><p>不懂理财的人只看表面，不分析企业实质。</p><p>包括一些只分析，实时新闻政策，去判断行业选股的，都属于不看实质，在投机</p><p>接着昨天很多人说哈，很多人一直听消息，今天国家发一个政策，明天国家发一个政策，天天看这些政策，弄到最后把自己形成一个错误的认知，就是中国是一个政策的股票。</p><p>其实完全不是这样的，因为这个政策到底对这家公司有没有作用，最简单的，你去看这家公司的财务报表就可以了，如果这家公司的这个受到了这个政策的影响，利润上涨，财报会反映出来的，如果说这家公司经营的内部是没有任何的变化，你又何必去关心这个政策呢？<br>第三个重点：选出好公司，要有一套科学的分析体系（财报分析、企业分析）</p><h4 id="⭕️重点3：如何才能分析出好公司呢"><a href="#⭕️重点3：如何才能分析出好公司呢" class="headerlink" title="⭕️重点3：如何才能分析出好公司呢"></a>⭕️重点3：如何才能分析出好公司呢</h4><p>【财报分析】可以看出一个公司的过去和现在。</p><p>【企业分析】可以看出一个公司的现在和未来。</p><p>我们【投资股票正确的方法】可以分为两大步：</p><p>第一步：选出内在价值高的好企业</p><p>第二步：在合理的价格把握时机，及时买入</p><p>【关键富人思维-第八条】</p><p>⭐股票价格大跌能跌出什么？<br>🌹我们【投资股票正确的方法】可以分为两大步：<br>第一步：选出内在价值高的好企业<br>第二步：在好的价格及时买入</p><p>这两步是不能颠倒的。<br>【当股市的价格出现下跌时】，好企业代表的好股票会出现好的买入价格，但是坏企业会跌出让投机者眼红的“陷阱”。如果在选择企业这一步错了，不管是多便宜的价格都徒劳无功，反而损失惨重。</p><p>【理性的投资者】对自己无法预测股票价格有自知之明，因为价格的波动总是难以预测的，因此他们将主要精力放在好企业的选择上，当好价格出现的时候果断出手，而后不管是继续跌还是涨，都是任凭风浪起稳坐钓鱼船。他们一般很少看股票，却获得了很高的收益。</p><p>💎一句话总结：👇<br>股票大跌既有机会也有陷阱，机会的识别需要眼力，机会的把握需要技能，当眼力和技能配不上这个机会的时候，往往会步入陷阱之中。</p><p>【关键富人思维—第九条】</p><p>⭐很多人炒股都亏，就说股票风险高，到底该怎么看待投资股票这件事？</p><p>🌹【投机炒股的人】，不懂就去投，一心想赚一把就走，那么股市就是一个大赌场，都特别想赢钱，但又特别怕输钱，风险自然是非常大</p><p>而且还很容易上当受骗，赚了以为是自己本事，亏了又说运气不好，说到底都是自欺欺人。</p><p>涨了开心要命，跌了悲伤绝望，被价格的波动带着一天悲喜两重天，说到底还是没有技能让自己内心踏实💡</p><p>🌹【真正的投资股票】，是关注股票代表的公司的好坏，是看到股票背后的本质，经过严谨的分析得出的结论。</p><p>这样的投资，即使短时间的价格波动也能心理踏实，最终能够获得复利带来的长期收益💰</p><p>💎一句话总结：👇<br>投资股票的正确姿势是靠分析，能选出好股票风险自然就小。赌徒在股市是把身家性命交给市场，不懂就投，肯定要被懂的人收割的。</p><h3 id="6-企业分析"><a href="#6-企业分析" class="headerlink" title="6 企业分析"></a>6 企业分析</h3><p>企业分析就是从一家公司的使命、愿景、核心价值观、领导团队等方面判断一家公司的未来走势</p><p>再说一下为什么要学【企业分析】？ </p><p>买股票就是买公司，投资要学企业；</p><p>打工族如果学了企业更有助于升职加薪，上班要学企业；</p><p>创业者学了企业能大幅提高成功概率，创业也要学企业。</p><h4 id="⭕️重点1：E-B-S-I，四类人群与企业的关系"><a href="#⭕️重点1：E-B-S-I，四类人群与企业的关系" class="headerlink" title="⭕️重点1：E\B\S\I，四类人群与企业的关系"></a>⭕️重点1：E\B\S\I，四类人群与企业的关系</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/21.png"></p><p>无论你是打工者、企业家还是投资者。你会发现，你越了解企业，你就越富有</p><h4 id="⭕️重点2：企业与个人职业发展、创业"><a href="#⭕️重点2：企业与个人职业发展、创业" class="headerlink" title="⭕️重点2：企业与个人职业发展、创业"></a>⭕️重点2：企业与个人职业发展、创业</h4><p>企业与个人的发展息息相关，企业愿意为员工付出、重视员工，会增加员工的归属感和责任心。在良性的企业文化中学习和成长出来的员工，也会全心全意为企业着想，推动企业的发展。循环共赢</p><p>创业也是一样，创业不仅要有好的项目支撑，更重要的为自己的企业树立良好的企业文化和核心价值观。吸引更多志同道合的人一起奋斗。</p><h4 id="⭕️重点3：企业分析工具——强大企业模型"><a href="#⭕️重点3：企业分析工具——强大企业模型" class="headerlink" title="⭕️重点3：企业分析工具——强大企业模型"></a>⭕️重点3：企业分析工具——强大企业模型</h4><p>企业分析利器——强大企业模型，学习的时候也要注意两点：</p><p>👉2、思考一下：为什么懂企业对工作、创业、投资有一箭三雕的作用？</p><p>🌟强大企业模型，包括9个关键要素。</p><p>领导者、企业文化、治理结构、商业模式、团队、沟通、现金流、系统、法规</p><p>【领导者】是最核心的要素。其他8个关键要素都和领导者有着直接的关系</p><p>强大企业模型可以让普通员工像CEO一样去思考企业的问题。</p><p>强大企业模型不但可以知道我们经营好自己的企业，还可以让我们看明白别人的企业。</p><p>分析清楚一家企业对我们有什么用呢？</p><p>1、跳槽的时候能选出更有潜力的好公司，职业发展上获得超额回报。</p><p>2、做投资的时候能选出好公司，给企业估值，获得年化20%-30%以上的收益率。</p><p>【关键富人思维第十条】</p><p>🌹为什么工作者、投资者都需要通晓企业分析技能？</p><p>⭐并不是创业者 、大老板才需要了解企业。</p><p>【投资中】，股票本质是企业，只有把9大要素都分析清楚，才能分析出好企业，才能给企业估值.</p><p>【工作中】，干工作的时候要有企业经营的思维，这样才更容易升职加薪。</p><p>即便不为升职，干工作的时候也要有企业经营的思维。因为当你站在更高层去看自己的工作内容的时候你才能更好的理解自己的工作内容，这样你可以把工作做成老板真正想要的样子。</p><p>而那些只盯着自己的岗位的“井底之蛙”，有的时候挨了骂都不知道为什么，因为他缺乏跳出自己的框框看企业的技能，这就是他自己工作干不好的原因。</p><p>所以无论投资、工作，都需要通晓企业分析技能。</p><p>💎总结一句话：工作者用企业分析模型看透工作，投资者用企业分析模型看透股票💡</p><hr><h2 id="半程总结"><a href="#半程总结" class="headerlink" title="半程总结"></a>半程总结</h2><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/14.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/15.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/16.jpg"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/17.png"></p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/18.png"></p><h2 id="正篇-2"><a href="#正篇-2" class="headerlink" title="正篇-2"></a>正篇-2</h2><h3 id="7-REITs"><a href="#7-REITs" class="headerlink" title="7 REITs"></a>7 REITs</h3><p>REITs：Real Estate Investment Trusts 房地产投资信托基金，REITs是一种依照法律程序成立的，以发行股票或基金单位的方式汇集投资者的资金，由专业机构进行房地产的经营管理，并将90%以上的税后收入净额分配给投资者的一种信托组织。简单来说，REITs 就是代理投资者投资房地产的上市企业。</p><p>特点：</p><ul><li><p>定期强制高分红</p></li><li><p>投资门槛低</p></li><li><p>交易成本低</p></li><li><p>流动性强</p></li><li><p>专业化管理</p></li><li><p>收益率相对较高</p></li></ul><p>通过 REITs 我们可以很容易的投资世界主要国家的房地产。你看中哪个国家的房地产市场，你就买他的 REITs</p><p>房地产作为投资工具的优缺点：</p><ul><li><p>优点：能带来稳定的现金流，保值增值能力强</p></li><li><p>缺点：投资金额大，交易税费高，难变现</p></li></ul><p>正因为房地产作为投资工具有着明显的优缺点，所以 REITs 才被设计出来。对于开发商而言，通过 REITs 可以把开发好的房地产快速变现，提高开发效率；对于投资者来说，几百元就可以投资房地产了，大幅降低了投资门槛；对政府来说，REITs 促进房地产市场更健康的发展，有利于国家经济。</p><p>REITs 和房地产股票区别：<br><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/22.png"></p><p>我个人的理解，REITs 的本质就是房地产，房地产有的风险，REITs 基本也会有。房价下跌REITs也会下跌。但是房地产市场相比其他市场还是比较稳定的，所以 REITs 给大家提供了一种除了买房或买商铺以外的投资房地产市场的途径。</p><h3 id="8-基金"><a href="#8-基金" class="headerlink" title="8 基金"></a>8 基金</h3><h4 id="⭕️概念：认识一下“基金”"><a href="#⭕️概念：认识一下“基金”" class="headerlink" title="⭕️概念：认识一下“基金”"></a>⭕️概念：认识一下“基金”</h4><p>1 什么是基金？</p><p>把投资者的钱集中起来交给基金公司打理，基金公司赚钱了我们就赚钱了</p><p>2 基金有哪些类型？</p><p>2.1 按照基金的交易场所划分：场内基金、场外基金</p><p>场内基金：直接在证券交易所内投资的基金</p><p>场外基金：证券交易所外可以买卖的基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-2.png"></p><p>2.2 按照基金的投资对象去划分：货币基金、债券基金、混合基金、股票基金</p><p>如果主要把钱主要投资到了股票上，那就是股票基金</p><p>如果铁蛋主要把钱投资到了债券上，那就是债券基金</p><p>如果不限制资金用途，爱投资什么投资什么，那就是混合基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-3.png"></p><p>不同类型基金的年化收益率区别</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-4.png"></p><p>2.3 按照投资方式划分：主动型基金和被动型基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-5.png"></p><p>【主动型基金】，这种基金由基金经理决定买哪些股票，如股票基金、混合基金。</p><p>【被动型基金】就是【指数基金】，只根据指数配置股票，不人为选择股票。</p><h4 id="⭕️重点1：指数基金定投"><a href="#⭕️重点1：指数基金定投" class="headerlink" title="⭕️重点1：指数基金定投"></a>⭕️重点1：指数基金定投</h4><p>推荐的方式是：定期变额定投</p><p>【定期】可以是每月、每季度、每年</p><p>【变额】指投资额度会变化</p><p>【定期】+【变额】，这相当于指数基金的收益率放大器</p><p>这个变化不是随意变的，而是跟随投资工具的【市盈率】而变。</p><p>⭕那什么是【市盈率】呢？专业说法是市价盈利比率，是一个投资回报指标</p><p>市盈率几年就代表几年回本，越低越好。正常来讲市盈率15比较合理</p><p>此外，市盈率也可以作为何时卖出的参考标准</p><blockquote><p>建议每月定投。每月定投日可以设定为发薪日。这样发了工资直接拿出一部分（比如 10%-20%）定投<br>👉市盈率小于12时，每个月定投金额为2X元<br>👉市盈率小于10时，每个月定投金额为4X元</p></blockquote><p>当然也可以设置一个停止买入的市盈率，比如市盈率大于15时暂停买入</p><blockquote><p>友情提示：想投资房子的同学，也可以想想现在的房地产，租金带给你的年化收益率是多少？<br>公式是：【每年的租金÷买房子的总价】，你就知道你房子的年化收益率了</p></blockquote><h4 id="⭕️重点2：长生不老的指数基金"><a href="#⭕️重点2：长生不老的指数基金" class="headerlink" title="⭕️重点2：长生不老的指数基金"></a>⭕️重点2：长生不老的指数基金</h4><p>【指数基金】和主动基金相比，还有一个特别厉害的优点：【永生不死，长期上涨】</p><p>指数基金是会新陈代谢的，会自动淘汰那些不好的股票，加入满足条件的股票</p><h4 id="⭕️重点3：最好的定投是选择好的【股票】和【REITs】"><a href="#⭕️重点3：最好的定投是选择好的【股票】和【REITs】" class="headerlink" title="⭕️重点3：最好的定投是选择好的【股票】和【REITs】"></a>⭕️重点3：最好的定投是选择好的【股票】和【REITs】</h4><p>其实，还有比指数基金更好的理财工具：股票和REITs</p><blockquote><p>通常我们买基金共有4种渠道<br>1、证券公司<br>2、银行<br>3、基金公司<br>4、第三方代销平台，如支付宝、天天基金，蚂蚁聚宝，京东金融等</p></blockquote><p>【关键富人思维——第十三条】</p><p>掌握高收益率投资工具的科学方法是什么？</p><p>❤️【方法一】：很多人刚刚知道有一个高收益的工具，恨不得马上就买，然后就自我憧憬能赚多少。或者选择去市场中盲目的尝试，事实证明，他们自己总结的方法时而有效，时而无效，时而自信找到了暴富出路，时而迷茫否定自己、骂社会，我称之为焦虑的“【烧钱尝试法】”</p><p>其实他们不仅损失了自己的血汗钱，同时在错误尝试的时间里，也错过了正确买入好目标的机会。</p><p>❤️【方法二】：其实最快的方法，绝对不是马上去盲目尝试，磨刀不误砍材工，应该先去学习，在学习中最快的方法是什么，是看书吗？</p><p>如果看书能够实现财务自由，那么很多人早就财务自由了，因为看书最大的弊端就是没有反馈，没有人告诉你学的对还是学的错。</p><p>沉溺在看书中寻求财富自由的人，不能说不努力，但是因为没有有经验的老师指点，很多都成了【无效的努力】，最可怕的不是慢，是选错了方向，走错了路，在错误方向上的努力只是巩固错误。<br>❤️【方法三】：那么最快的学习方法是什么？答案是【巨人同行法】，跟着已经长期成功的投资者学习，巴菲特的老师是投资之神格雷厄姆，我们早读中8岁的投资神童，她的老师是父亲，也是成功的投资家。</p><p>他们都是一边勤奋学习理论，一边在老师的指导下纠正错误，一直走在一条正确的努力之路上。这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。</p><p>这就是看似缓慢，但实际最快的投资之路。这是一条少有人懂得的路，也是一条少有人走的路，所以真正赚钱的投资者才不多。你打算选哪条路？</p><p>【给自己找到正确的反馈，别让资金、时间白费。】</p><p>❤️总结一句话：站在巨人的肩膀上成长是最快的，站在巨人的肩膀学习理财技能也是变现最快的。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/08-1.png"></p><h3 id="9-通货膨胀"><a href="#9-通货膨胀" class="headerlink" title="9 通货膨胀"></a>9 通货膨胀</h3><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/09-1.png"></p><h4 id="⭕️重点1：什么是通货膨胀"><a href="#⭕️重点1：什么是通货膨胀" class="headerlink" title="⭕️重点1：什么是通货膨胀"></a>⭕️重点1：什么是通货膨胀</h4><blockquote><p>【通货膨胀】= 通货 + 膨胀</p></blockquote><p>通货就是通用货币，也叫法币，就是法律规定的必需使用的货币，比如：人民币</p><p>我们来看一下知名的【费雪方程式】</p><pre><code>MV=PT</code></pre><blockquote><p>我们一个一个拆解来看看<br>M ：货币的数量 V ：货币流通速度<br>P ：物价水平 T ：各类商品的交易总量<br><strong>在社会中V和T一般是比较稳定的，所以货币量M决定物价P</strong></p></blockquote><p>即，VT不动，M与P呈现正比例关系</p><p>也就是说， 货币越来越多，物价就会持续上涨</p><p>这就是通货膨胀</p><h4 id="⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？"><a href="#⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？" class="headerlink" title="⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？"></a>⭕️重点2：我们手中的钱每年实际贬值到底是多少呢？</h4><pre><code>⭐实际CPI=M2增长率-GDP增长率⭐</code></pre><blockquote><p>M2增长率反映了一个国家每年钱的增长速度<br>GDP增长率反映了一个国家每年创造的商品和服务的增长速度<br>所以货币增长比商品和服务增长多出来的部分，这就是实际的CPI，也叫实际通货膨胀率⭐</p></blockquote><h4 id="⭕️重点3：如何避免被“割韭菜”？"><a href="#⭕️重点3：如何避免被“割韭菜”？" class="headerlink" title="⭕️重点3：如何避免被“割韭菜”？"></a>⭕️重点3：如何避免被“割韭菜”？</h4><p>既然理财如此重要，怎么才能在主动选择理财中，不被割韭菜呢？</p><h5 id="❌韭菜的特点1："><a href="#❌韭菜的特点1：" class="headerlink" title="❌韭菜的特点1："></a>❌韭菜的特点1：</h5><p>韭菜是【投机者】而不是【投资者】。</p><p>【投资】和【投机】有什么区别？ 👇</p><p>🍣【投资】以赚现金流为主，而且是赚确定性很高的现金流，赚差价为辅。</p><p>💰投资者会选出买入高股息率的好股票、高现金分红率的REITs。</p><p>💰即使价格不涨甚至下跌，每年也有7%—15%的现金分红收益</p><p>投机者典型的心态是：</p><p>生怕错过什么，又害怕被割韭菜，各种理由不愿意花精力去学习理财技能，所以想去市场上【试一试】，可能生活中是有负债，或者没有好支出，想着投资少点，亏了也就亏了，对理财没有正确认知。</p><h5 id="❌韭菜的特点2："><a href="#❌韭菜的特点2：" class="headerlink" title="❌韭菜的特点2："></a>❌韭菜的特点2：</h5><p>追求短期收益，高频交易，而不是长期投资</p><h5 id="❌韭菜的特点3："><a href="#❌韭菜的特点3：" class="headerlink" title="❌韭菜的特点3："></a>❌韭菜的特点3：</h5><p>不学习或不深入学习，盲目乱投资</p><p>【关键富人思维-第十四条】<br>⭐有的投机者说自己也赚钱了，那么选择做投资者到底好在哪？<br>🌹我们投资理财到底是为了什么呢？赚钱，但进一步想，赚钱是不被钱绑架，能有时间做自己想做的事，能和家人快乐的生活。</p><p>【不懂就去投的人】，短期内碰上运气了，也能赚到钱，但是他们是怎么度过的呢，每天把大量时间用来盯着大盘，昼夜想着跌了还是涨了，精神总是高度紧张，甚至睡觉都在想明天股票的情况，因为他们选择了“赌博”。历史证明，绝大多数投机者本来最应该乐观开心的两年，到头来却是在焦虑、闹心中度过的，因为他们没有真正的投资判断依据，这就是投机者的生活。</p><p>【懂得投资的人】，通过一整套分析方法选出优质的投资目标，算出买入好价格，买入，持有，再算出卖出合理价格，卖出。剩下的时间该干什么干什么，价格跌了，心里知道这是表面的波动，不被其迷惑，拿得住；价格涨了，知道什么时候该卖出，不冲动，赚踏实稳当钱。更厉害的，长期持有，被分红的复利滋润着。这是学习科学方法的自然成果，这也是不学习像苍蝇撞大运的投机者，与踏实学习走正道的投资者的最大差别。</p><p>当然，既不投机，也不投资的人都感受不到这些，他们只能感受到钱越来越不值钱，而自己的生活好像越来越紧吧了。</p><p>💎总结一句话：投资者获得的是金钱自由，时间自由，心理自由，投机者就算撞运赚了点，却一直在焦虑与煎熬中。</p><h3 id="10-股票"><a href="#10-股票" class="headerlink" title="10 股票"></a>10 股票</h3><p>以雪球app为例，选一只股票，看财务报表</p><p>几个指标：</p><p>1、行业对比：对比企业在行业中排名</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-1.png"></p><p>2、资产负债率：一般资产负债率超过70%，资产风险大</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-2.png"></p><p>3、ROE：常年收益率3%以下，还不如我拿着钱放货币基金</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-3.png"></p><p>4、毛利率：100万的售价最后只能赚9万块钱，剩下的都是成本。说明行业竞争激烈，公司没有差异化，没有很高的利润。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-4.png"></p><p>5、净利润和经营现金流：公司表面上赚到了钱，但实际上都是别人欠他不给他，说明公司根本在行业里没地位。</p><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/10-5.png"></p><p>6、分红：企业有盈利才会分红</p><blockquote><p>从长期来说，一只股票的回报率跟公司的发展是环环相扣的，如果一家公司 40 年来的盈利一直是它资本的 6%（ROE），那在长期持有 40 年后，你的年均收益率不会和 6%有什么区别，即便你当初买的是便宜货。如果该公司在 20-30 年间盈利都是资本的 18%（ROE），即便你当初出价过高，回报依然会令你满意！——查理芒格</p></blockquote><p><strong><em>但是我希望大家记住：投资股票就是投资企业，企业赚钱你就赚钱</em></strong></p><p>【关键富人思维–第十五条】</p><p>我们最贵的东西是什么？<br>钱并不是最重要的东西，那我们最重要的是什么呢？</p><p>财务自由的本质就是时间自由，你如果是个价值投资者，那么你完全可以认为你买到的是——高额的银行存款。在享受生活的同时，不用看大盘，看K线。每年只看1-2次财报，其余的时间收钱，做自己喜欢的工作，享受生活。</p><p>其实，人最宝贵的是【时间精力】，每个人每天的时间都只有24小时，但是每个人能够挥洒精力的时间却远远小于24小时。严格上说，我们一天能够真正专注的时间可能都不超过2小时。</p><p>根据二八定律，你20%的投入决定了80%的成败。而这20%实际就是那每天2小时的精力投入。因此，我们才反反复复强调要站在巨人的肩膀上，前人走过的弯路，我们就不要再走了。</p><p>我们对于这2小时真正的精力投向，决定了我们的一生。人就是自己所有选择的求和结果</p><p>那些独自学习、独自试错的人，他们需要付出四项成本：时间成本、机会成本、金钱成本、试错成本。摸索、搜寻弄懂一个知识点的时间是站在巨人肩膀上学习的数年、数倍。</p><p>当年纪慢慢变大，【精力善用】才逐渐显示出复利的威力，人生的分野就在此开始。</p><p>【总结一句话】：时间和精力才是最宝贵的，尽量用它做正确的事，高效的事，而不是为了试错而试错，为了省钱浪费了最宝贵的时间价值。</p>]]></content>
      
      
      <categories>
          
          <category> management </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dairy </tag>
            
            <tag> self management </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0926</title>
      <link href="2020/09/26/0926/"/>
      <url>2020/09/26/0926/</url>
      
        <content type="html"><![CDATA[<p>周五，我和妈妈各自都有些不太舒服，我嗓子疼有点感冒的症状，妈妈说头晕。<br>晚饭后，我坚持让妈妈跟我一起喝点小柴胡，妈妈原本有点拒绝，最后我冲好端到房间去，妈妈还是喝了。</p><p>星期六，昨晚吃过药之后好像身体都有了好转。按往常一样周六的中午全家一起出去吃了饭。<br>饭后到家，我喊了一句：再吃一顿小柴胡吧，巩固一下。妈妈说好，就回房间去了。</p><p>我拿了药，去厨房烧水、冲药。<br>以前我说身体不舒服的时候，都是妈妈来帮我冲药，给我送到房间来叮嘱我喝，我即便说不要紧她也非逼着我喝。</p><p>这时候我才意识到，原来不是我长大了，而是妈妈真的老了。</p>]]></content>
      
      
      <categories>
          
          <category> something </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dairy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悟到</title>
      <link href="2020/09/24/know-something/"/>
      <url>2020/09/24/know-something/</url>
      
        <content type="html"><![CDATA[<p>I always need to anticipate problems instead of just reacting to them.</p>]]></content>
      
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
