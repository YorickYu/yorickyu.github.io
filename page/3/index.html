<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yloopdaed.icu","root":"/","images":"/images","scheme":"Mist","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1}};
  </script>
<meta name="description" content="可能是个非典型程序员吧 ^ ^">
<meta property="og:type" content="website">
<meta property="og:title" content="yloopdaed">
<meta property="og:url" content="http://yloopdaed.icu/page/3/index.html">
<meta property="og:site_name" content="yloopdaed">
<meta property="og:description" content="可能是个非典型程序员吧 ^ ^">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yloopdaed">
<meta property="article:tag" content="iOS JAVA">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yloopdaed.icu/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>yloopdaed</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">yloopdaed</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">YYYYYY iOS to Java. DON'T BE WILD</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-xmind"><a href="/xmind/" rel="section"><i class="fa fa-tags fa-fw"></i>导图</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yloopdaed"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">yloopdaed</p>
  <div class="site-description" itemprop="description">可能是个非典型程序员吧 ^ ^</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YorickYu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YorickYu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yykeepbreak@gmail.com" title="E-Mail → mailto:yykeepbreak@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/9901b7042663" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9901b7042663" rel="noopener" target="_blank">简书</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/14337507/yloopdaed" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;14337507&#x2F;yloopdaed" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/YorickYu/JPP" title="https:&#x2F;&#x2F;github.com&#x2F;YorickYu&#x2F;JPP" rel="noopener" target="_blank">JPP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/YorickYu/YYTODOLIST" title="https:&#x2F;&#x2F;github.com&#x2F;YorickYu&#x2F;YYTODOLIST" rel="noopener" target="_blank">TODOLIST</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/YorickYu/IHAVEAQUESTION" title="https:&#x2F;&#x2F;github.com&#x2F;YorickYu&#x2F;IHAVEAQUESTION" rel="noopener" target="_blank">IHAVEAQUESTION</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://azh.ink/" title="http:&#x2F;&#x2F;azh.ink" rel="noopener" target="_blank">azh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.yitian.online/" title="https:&#x2F;&#x2F;blog.yitian.online" rel="noopener" target="_blank">lan</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/04/10/cache-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/10/cache-structure/" class="post-title-link" itemprop="url">缓存架构概念篇</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-04-10 22:10:41 / 修改时间：22:47:47" itemprop="dateCreated datePublished" datetime="2021-04-10T22:10:41+08:00">2021-04-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着业务场景复杂度的提高和数据存储量的膨胀，为了保证整体服务平稳运行，缓存系统的地位也越来越高。</p>
<p>今天就近期对缓存架构的理解，梳理成一篇浅显的文章</p>
<h2 id="Redis缓存架构分类"><a href="#Redis缓存架构分类" class="headerlink" title="Redis缓存架构分类"></a>Redis缓存架构分类</h2><p>根据日常C端面临的实际情况，Redis 做缓存时，大体分为两种模式，分别是<strong>只读缓存</strong>和<strong>读写缓存</strong>。</p>
<h3 id="只读缓存（读多写少）"><a href="#只读缓存（读多写少）" class="headerlink" title="只读缓存（读多写少）"></a>只读缓存（读多写少）</h3><p>修改数据时先删除缓存，下次读请求再写入。例如：<strong>旁路型缓存</strong></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/cache1.png"></p>
<p>当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了</p>
<h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>修改数据时不删除缓存，最新的数据是在 Redis 中，通过回写策略同步数据库。例如：<strong>穿透型缓存</strong></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/cache2.png"></p>
<blockquote>
<p>回写策略<br>1 同步直写策略，写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。<br>同步直写会降低缓存的访问性能<br>2 异步写回策略，优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。<br>异步写回有数据丢失的风险</p>
</blockquote>
<p><strong>同步直写模式侧重于保证数据可靠性，而异步写回模式则侧重于提供低延迟访问</strong></p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关于是选择只读缓存，还是读写缓存，主要看我们 <strong>对写请求是否有加速的需求</strong></p>
<p>1 如果需要对写请求进行加速，我们选择读写缓存<br>2 如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存</p>
<hr>
<p>缓存可以放到基础架构中任何存在数据传输瓶颈的地方。</p>
<h2 id="展开"><a href="#展开" class="headerlink" title="展开"></a>展开</h2><h3 id="旁路型缓存-Look-Aside-Caching"><a href="#旁路型缓存-Look-Aside-Caching" class="headerlink" title="旁路型缓存 (Look-Aside Caching)"></a>旁路型缓存 (Look-Aside Caching)</h3><p>旁路型缓存是避免微服务从后端存储中访问数据的高性能替代方案<br>1 应用读取数据时，需要先读取 Redis；<br>2 发生缓存缺失时，需要从数据库读取数据；<br>3 发生缓存缺失时，还需要更新缓存。</p>
<p>这些操作都要放在应用程序中来完成。所以，<br>有一个地方就需要注意了：因为需要新增程序代码来使用缓存，所以，Redis 并不适用于那些无法获得源码的应用，例如一些很早之前开发的应用程序，它们的源码已经没有再维护了，或者是第三方供应商开发的应用，没有提供源码，所以，我们就没有办法在这些应用中进行缓存操作。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>伴随业务膨胀，缓存的一致性维护难度上涨<br>思考：<br>数据读写方的沟通难题<br>解决方案：<br>1 AOP注解，更新缓存时通知<br>2 Mybatis 触发器<br>3 binlog 处理<br>4 MQ 最终一致性</p>
<h3 id="穿透型缓存"><a href="#穿透型缓存" class="headerlink" title="穿透型缓存"></a>穿透型缓存</h3><p>穿透型缓存的设计原则是将缓存与后端数据库的交互细节对应用层服务隐藏<br>应用层服务所有的读写请求均请求缓存，读请求 miss 后，缓存向后端数据服务器请求数据，先更新缓存后返回<br>而写请求也是同样的，先写入缓存服务器，随后在合适的时间同步给后端服务器</p>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>实现复杂度和数据一致性的问题<br>思考：<br>选择合适的回写时间节点，和回写策略<br>合理规划缓存中的键值关系<br>解决方案：<br>1 实现复杂性无法避免，为了追求高频读写场景的缓存最大化利用<br>2 一致性问题考虑配合脚本语言，触发器等实现一个回写服务，当然还要保证缓存服务的高可用（这也不算不上解决方案）</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实缓存架构的思想内嵌是无处不在的。MySQL本身也有<code>buffer pool</code>的概念。redis中也有批处理指令和pipeline管道的概念。甚至于寄存器与系统内存之间的3级缓存概念。</p>
<p>硬件的定位差距总需要通过软件去弥补，协同工作</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/04/01/cavil/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/01/cavil/" class="post-title-link" itemprop="url">吹毛求疵</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-01 10:40:19" itemprop="dateCreated datePublished" datetime="2021-04-01T10:40:19+08:00">2021-04-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 23:08:38" itemprop="dateModified" datetime="2021-04-21T23:08:38+08:00">2021-04-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>虽说吹毛求疵看似是个贬义词，但是技术上的吹毛求疵往往是有必要的。</p>
<p>这里会不定时更新一些日常编码中 <code>吹毛求疵</code> 的写法。目的也是为了养成一个良好的编码习惯。</p>
<h3 id="循环中的size判断"><a href="#循环中的size判断" class="headerlink" title="循环中的size判断"></a>循环中的size判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ~~<span class="keyword">int</span>~~ length = list.size; i &lt; length; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修正：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, length = list.size; i &lt; length; i++)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list.size 有一定的资源消耗</p>
<h3 id="返回空集合"><a href="#返回空集合" class="headerlink" title="返回空集合"></a>返回空集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Result&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO.</span></span><br><span class="line">    <span class="keyword">return</span> Collections.EMPTY_LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果查询数据为空时，也需要返回一个空集合，而不是null。防止调用方空指针异常</p>
<h3 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singlenton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singlenton INSTANCE; <span class="comment">// JIT</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singlenton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// DCL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singlenton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// double check 1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singlenton.class) &#123; <span class="comment">// LOCK</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123; <span class="comment">// double check 2</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singlenton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>避免对象半初始化状态</p>
<h3 id="局部变量赋值"><a href="#局部变量赋值" class="headerlink" title="局部变量赋值"></a>局部变量赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldThr = threshold;</span><br><span class="line"><span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;    </span><br><span class="line"><span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">    newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br></pre></td></tr></table></figure>

<p>这种写法在源码中比较常见</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/03/29/mysql-innodb-hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/29/mysql-innodb-hash/" class="post-title-link" itemprop="url">MySQL Innodb 自定义Hash索引</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-29 09:24:16 / 修改时间：10:58:34" itemprop="dateCreated datePublished" datetime="2021-03-29T09:24:16+08:00">2021-03-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL中，索引是在存储引擎实现的<br>MySQL中，只有 Memory 引擎显式支持哈希索引（非唯一）<br>MySQL中，默认的Innodb引擎是不支持 Hash 索引的</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引的数据结构：槽 Slot、值 Value</p>
<p>每个槽的编号是顺序的，但是值不是。<strong>值存储的是指向 行 的指针</strong></p>
<p>优点：<br>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。</p>
<p>缺点：<br>1 哈希值是无序的，无法用于排序<br>2 哈希索引只支持等值比较，不支持任何范围查询<br>3 哈希冲突，索引维护操作代价很高<br>4 不支持部分列匹配查找。例如：对数据列（A,B）建立哈希索引，此时查询A列，无法使用该索引</p>
<p><strong>因为这些限制，哈希索引只适用于某些特定的场合</strong>。而一旦适合哈希索引 ，则它带来性能提升将非常显著。</p>
<h3 id="大字符串类型索引"><a href="#大字符串类型索引" class="headerlink" title="大字符串类型索引"></a>大字符串类型索引</h3><blockquote>
<p>这里基于 Innodb 数据引擎讨论</p>
</blockquote>
<p>由于索引本身在 Innodb 中是以 B+Tree 的数据结构存在的。如果对于大字符串类型直接建立索引显然是不合理的。（这里不展开介绍 B+ 树在 MySQL 中的相关知识）</p>
<p>那么，假如现在要对数据列 email 或者 url 这类数据列建立索引。应该如何保证空间和效率？</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>这是一种常见的思路，取大字符串类型的前缀建立索引，节省空间的同时尽可能过滤数据。</p>
<p>难点在于需要合理定位一个前缀长度，尽可能过滤重复数据。</p>
<p>此外需要注意的是，前缀索引会导致覆盖索引失效。这里就不详细展开了。</p>
<h4 id="自定义-Hash-索引"><a href="#自定义-Hash-索引" class="headerlink" title="自定义 Hash 索引"></a>自定义 Hash 索引</h4><p>这个概念其实一直存在于 Innodb 引擎中。</p>
<blockquote>
<p>innodb内部做了很多优化：<br>1 读：可预测性预读，自动在内存中创建 <strong>自适应Hash索引</strong> 以加速读操作<br>2 写：加入缓冲区。加速插入操作</p>
</blockquote>
<p>上面的内容了解即可，本文中提到的 自定义Hash索引 是在 B+树 的基础上创建一个 <strong>伪哈希索引</strong>。</p>
<p>思路就是新增一列记录大字符串哈希算法的结（删除原来字符串的索引）。</p>
<h5 id="哈希算法的选择"><a href="#哈希算法的选择" class="headerlink" title="哈希算法的选择"></a>哈希算法的选择</h5><p>不要使用 SHA1() 和 MD5() 作为哈希函数。因为这两个函数是强加密函数。计算出来的哈希值非常长，浪费空间，索引过程也更慢。他们得设计目的是加密。</p>
<p>CRC32() 是一个比较好的选择，计算结果较小。但是随着数据量的增多会出现明显的哈希冲突问题。可以在此基础上优化得到适合自己项目需求的哈希算法。</p>
<h5 id="如何维护哈希值"><a href="#如何维护哈希值" class="headerlink" title="如何维护哈希值"></a>如何维护哈希值</h5><p>由于新增了一列伪哈希数据列。所以对于行数据的更新的插入操作。都是进行相应的哈希操作。</p>
<p>当然这一列哈希值的维护可以进行手动维护，也可以使用触发器实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER // </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> pseudohash_crc_in s <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> pseudohash <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SET</span> NEW.url_crc=<span class="keyword">crc32</span>(NEW.url); </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">// </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> pseudohash_crc_upd <span class="keyword">BEFORE</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> pseudohash <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">SET</span> NEW.url_crc=<span class="keyword">crc32</span>(NEW.url); </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">//</span><br></pre></td></tr></table></figure>

<h5 id="sql改写"><a href="#sql改写" class="headerlink" title="sql改写"></a>sql改写</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT id FROM url WHERE url=&quot;http://www.mysql.com&quot;;</span><br></pre></td></tr></table></figure>

<p>改进为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT id FROM url WHERE url=&quot;http://www.mysql.com&quot; AND url_crc=CRC32(&quot;http://www.mysql.com&quot;);</span><br></pre></td></tr></table></figure>
<p>由于哈希冲突。所以还是需要带有原条件，在伪哈希索引之后再扫描少量的数据。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本篇文章只是对于大字符串索引优化提供另一种思路。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/03/21/redisson-watchdog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/21/redisson-watchdog/" class="post-title-link" itemprop="url">redisson 锁续期</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-21 13:29:28 / 修改时间：13:33:55" itemprop="dateCreated datePublished" datetime="2021-03-21T13:29:28+08:00">2021-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>redisson 默认加锁有效期 30s</p>
<p>watchdog 调用频率 10s，每次调用会将锁有效期更新为 30s。</p>
<p>如果redis服务宕机，那么锁和watchdog都会停止服务。即，锁到期会正常过期，没有死锁。</p>
<p>相关源码如下：</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/redisson%E9%94%81%E7%BB%AD%E6%9C%9F.jpg"></p>
<p>参考：</p>
<p>简书作者，花神子 - <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0d3f5395ceaf">缓存Redis 分布式锁的续期</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/03/20/redis-pipelines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/20/redis-pipelines/" class="post-title-link" itemprop="url">redis pipelines</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-20 22:28:09 / 修改时间：23:30:34" itemprop="dateCreated datePublished" datetime="2021-03-20T22:28:09+08:00">2021-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是pipelines"><a href="#什么是pipelines" class="headerlink" title="什么是pipelines"></a>什么是pipelines</h3><p>redis pipelines，管道，是redis客户端提供的一个批量处理命令。</p>
<p>管道操作的本质是客户端通过对管道中的指令 <code>重排序</code> 执行。这样做可以大幅节省IO时间。</p>
<blockquote>
<p>我们知道redis的工作模型是基于单线程的，我个人认为他之所以这样设计，是因为CPU的性能不是redis性能瓶颈的关键因素。而是IO。<br>redis pipelines可以通过改变命令的读写顺序，将读指令合并执行、写指令合并执行。减少IO的频率从而减少网络通信的花费。</p>
</blockquote>
<h3 id="与原生批量命令-mget-mset-的区别"><a href="#与原生批量命令-mget-mset-的区别" class="headerlink" title="与原生批量命令 mget mset 的区别"></a>与原生批量命令 mget mset 的区别</h3><p>原生批量命令是redis服务端实现的。而pipelines是redis客户端实现的。</p>
<p>当key的数目过多时，mget和mset的执行效率会大于pipelines</p>
<p><em>pipelines不会阻塞其他客户端，而mget会。</em></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pipevsmget.jpg"></p>
<h3 id="pipelines-底层"><a href="#pipelines-底层" class="headerlink" title="pipelines 底层"></a>pipelines 底层</h3><p>依靠 <code>网络协议栈</code> 深入内核</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/pipelinesker.jpg"></p>
<p>流程简述：<br>客户端请求 -&gt; send buffer -&gt; 网卡（客户端） -&gt; 路由网关 -&gt; 网卡（服务器）-&gt;  recv buffer -&gt; 服务器处理<br>一个客户端请求被服务器处理完成后，原路返回。</p>
<p>总结：<br>1 写操作几乎没有耗时，写入客户端 send buffer 就直接返回<br>2 读操作需要经历完整的流程，最终从 recv buffer 中获取数据，这是真正耗时的操作</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>去探索一下redis单机性能的极限在哪里？</p>
<p>1 如果没有管道，最大承受qps是多少？<br>2 通过管道，最大承受qps是多少？</p>
<p>证实一下为什么redis性能瓶颈不取决于CPU，而是IO。<br>这也能换个角度更好的理解为什么redis要使用单线程模型。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/03/18/redis-mysql-cp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/18/redis-mysql-cp/" class="post-title-link" itemprop="url">蚂蚁金服初试：双写一致性延伸</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-18 23:45:57" itemprop="dateCreated datePublished" datetime="2021-03-18T23:45:57+08:00">2021-03-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-19 00:30:10" itemprop="dateModified" datetime="2021-03-19T00:30:10+08:00">2021-03-19</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天有幸参加了蚂蚁金服的线上初试，获益良多。</p>
<p>记录下来</p>
<h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>挑选您项目中比较有亮点的部分介绍一下?</p>
<blockquote>
<p>这个问题也许大家经常遇到，也没有足够的重视。其实这个问题在我个人看来是整场面试最关键的问题。<br>因为你有机会通过这个问题介绍一个成熟的解决方案！有时候打动面试官只需要一个成熟的解决方案。<br>这不仅仅说明你在业务上横向的全局思考能力，也体现了纵向的技术理解深度。</p>
</blockquote>
<p><strong>所以这个问题，一定要好好利用。</strong></p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>整场面试的重点是由 redis和mysql的双写一致性 引出的。</p>
<p><strong>问题是：如果mysql完成了数据更新，但是随后更新redis时失败了。如何处理？</strong></p>
<p>我当时没有很好的回答这个问题，思考过后与大家分享一个解决方案。</p>
<p>首先假设一个场景是购物车系统。使用redis hash维护了一个简单的购物车，同时持久化在mysql数据库中。</p>
<p>那么对于用户在购物车的操作需要反馈给数据库。</p>
<blockquote>
<p>PS：这里考虑借鉴缓冲池的思想，对用户的操作做一些预处理后再真实发生请求。尽量减少无效请求的次数。</p>
</blockquote>
<p>但是最终通过接口同步数据的时候发生了问题：mysql更新成功，随后redis写入失败。</p>
<blockquote>
<p>PS：这里先不讨论其他的双写一致性方案，比如：先删除redis数据，再更新数据库。<br>其次这里举例redis可能发生写入失败的场景：redis宕机、redis内存打满。</p>
</blockquote>
<p>此时，已经发生了redis和mysql数据不一致的情况。那么如何解决这个问题？</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>首先要进一步优化redis集群，保证redis高可用，从根源解决问题。</p>
<p>其次我的想法是借鉴分布式事务中 <code>最终一致性</code> 原则去解决这个问题。</p>
<p>这个场景中，先更新mysql，再更新redis，同时向mq中发送一条变更指令。mq会在后台消费这个变更指令，达到数据的最终一致性。</p>
<p>在此期间，如果用于有读请求发生，可以先去判断一下这个mq中是否存在未被消费的信息。如果有，这条读请求就直接打到数据库中。并更新redis（同时是否能让mq中的消息标记处理）</p>
<p>我感觉这样处理应该是可以最终保持数据一致性的。当然mq本身也要做集群高可用处理。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>整理一下正常面试的流程吧，说不定对大家有帮助。</p>
<p>1 从项目出发，面试官会根据项目中的业务场景发问，这需要你非常熟悉自己的项目，并且有比较完善的处理。</p>
<p>2 线上同步编码，会通过一个共享的编辑器窗口，现场完成几个简单的编程题。（算法、编程能力）</p>
<p>3 最后会问一些底层的问题：源码、JVM等</p>
<p>整个面试过程大约2个小时。</p>
<p>最主要的收获：</p>
<p>珍惜项目中遇到的每一个问题，提出解决方案，并不断的优化。</p>
<p>长久如此，肯定会有收获。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/03/08/all-life-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/08/all-life-study/" class="post-title-link" itemprop="url">终生学习者</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-03-08 13:53:59 / 修改时间：14:21:22" itemprop="dateCreated datePublished" datetime="2021-03-08T13:53:59+08:00">2021-03-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个词早在几年前就注意过，多为一些知乎作者的自我简介。没有过多深究。</p>
<p>但是随着短视频平台兴起，除了毫无营养的带货、搞笑视频，我更愿意关注一些产出作品的作者。</p>
<p>渐渐的，我的抖音画像也趋于成熟了，我喜欢的分类大概有：汽车、金融、摄影、篮球，当然还有一些分享干货的作者。这些干货往往在众多快餐式的短视频中特别能吸引我的眼球。他们产量并不高，甚至我有时候会一次性看完他们所有的作品，收获颇丰。</p>
<p>最近有关注到一位20几岁的年轻作者，斯坦福学士，互联网行业工作。我发现他的标签也有一个 “终生学习者”。</p>
<h2 id="什么是终生学习者？如何成为？"><a href="#什么是终生学习者？如何成为？" class="headerlink" title="什么是终生学习者？如何成为？"></a>什么是终生学习者？如何成为？</h2><p>这里只能从知乎搬砖了，把准确的定义分享出来。</p>
<blockquote>
<p>信息论中有一个很有意思的概念：只有正确且少数人知道的信息才是有价值的！<br>从这个角度看，终身学习者就是努力掌握有价值的信息的人。<br>关于如何成为终身学习者，我自己并没有百分之百准确的答案，只提一点点心得：<br>1.建立准确清晰的概念。这一点是李笑来反复强调的。为什么我们听了很多道理但就是过不好这一生？实际上很多情况下是你根本没有清晰理解那个道理。没有概念，就没有行动，没有行动，就没有结果。<br>2.活在未来。这也是李笑来提出的。不断预测未来，按照未来的情况指导你当下的行动。<br>3.不落后于人。不论在财富、社会地位、健康、教育等等各个方面，都应该努力超过你身边的人，做到前50%，继而做到前90%，再做到前98%，继而升级，并且继续超越。</p>
</blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53028316/answer/134617342">不知所谓</a></p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>战略上的理解<br>终生学习的周期可能是20年左右。因为平均每20几年，人就会为人父母。人需要用新的方式方法经历自己曾经经历过的一切。把子女教育成为更好的人。所以你只能不断学习，教育也要不断更新。重复基础教育中经典的=部分，并把过去的经验总结给自己的下一代。</p>
<p>战术上的理解<br>每个人要通过不断的学习、不断更新对事物的认识来准确的定位自己。这个过程不一定要与人对比，而是成为共有价值体系中更优秀的人。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望有朝一日自己可以成为一个终生学习者</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/02/20/HashMap-long-long/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/20/HashMap-long-long/" class="post-title-link" itemprop="url">HashMap<Long, Long> 的空间效率问题</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-20 11:54:16 / 修改时间：12:18:52" itemprop="dateCreated datePublished" datetime="2021-02-20T11:54:16+08:00">2021-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为什么要讨论 <code>HashMap&lt;Long, Long&gt;</code> 这个数据结构的空间效率问题？</p>
<p>因为不恰当的使用数据结构可能会导致内存占用过大，从而加剧JVM垃圾回收时的用户线程停顿时间，造成不良的用户体验。</p>
<p><code>HashMap&lt;Long, Long&gt;</code> 有多低呢？</p>
<p>在 <code>HashMap&lt;Long，Long&gt;</code> 结构中：<br>1 Key和Value所存放的两个长整型数据是有效数据，共16字节（2×8字节）。<br>2 这两个长整型数据包装成 <code>java.lang.Long</code> 对象之后，就分别具有8字节的Mark Word、8字节的Klass指针，再加8字节存储数据的long值。<br>3 然后这2个Long对象组成 <code>Map.Entry</code> 之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充<br>4 最后还有HashMap中对这个Entry的8字节的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24byte)×2)+Entry(32byte)+HashMapRef(8byte)=88byte</p>
<p>空间效率为有效数据除以全部内存空间，即16字节/88字节=<strong>18%</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/02/11/jvm-gc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/11/jvm-gc/" class="post-title-link" itemprop="url">堆 & 垃圾回收机制</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-11 14:15:58" itemprop="dateCreated datePublished" datetime="2021-02-11T14:15:58+08:00">2021-02-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-19 12:24:08" itemprop="dateModified" datetime="2021-02-19T12:24:08+08:00">2021-02-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆内存中可以细分为三个区域：<br>1 新生代Young：伊甸园区Eden、幸存0区from、幸存1区to<br>2 老年代Old：默认一个对象经历了15次GC还没被回收，会进入老年代，可以通过<code>-XX:MaxTenuringThreshold</code>更改次数<br>3 永久代Perm：方法区（1.7）/元数据区（1.8）</p>
<blockquote>
<p>永久代有两种理解：<br>1 把他理解成与堆是分开的独立区域<br>2 把他理解在堆内，逻辑上存在，物理上不占用堆内空间</p>
</blockquote>
<p>堆内存溢出OOM：OutOfMemoryError:Java heap space<br>处理堆OOM：<br>1 扩大堆内存<br>2 分析内存，找问题（定位简单，调优难）</p>
<p>常用调试工具：<br>1 JProfiler工具<br>2 Eclipse自带的MAT<br>3 在Java的Jdk中 jconsole.exe 和 jvisualvm.exe<br>4 <a target="_blank" rel="noopener" href="https://github.com/alibaba/arthas">arthas</a></p>
<p>Jprofiler使用：<br>1 分析Dump内存文件<br>2 查看堆中的数据信息<br>3 查看堆中的线程信息</p>
<h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        s += <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">        s += <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">        s += <span class="keyword">new</span> Random().nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置运行参数：<code>-Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDetails</code></p>
</blockquote>
<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/oom-error.jpg"></p>
<h5 id="分析Dump文件"><a href="#分析Dump文件" class="headerlink" title="分析Dump文件"></a>分析Dump文件</h5><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jprofiler-obj.jpg" alt="Object"></p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jprofiler-thread.jpg" alt="Thread"></p>
<h5 id="常用调优参数"><a href="#常用调优参数" class="headerlink" title="常用调优参数"></a>常用调优参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">常见的如下：</span><br><span class="line">-Xms64m 最小堆内存 64m.</span><br><span class="line">-Xmx128m 最大堆内存 128m.</span><br><span class="line">-XX:NewSize&#x3D;30m 新生代初始化大小为30m.</span><br><span class="line">-XX:MaxNewSize&#x3D;40m 新生代最大大小为40m.</span><br><span class="line">-Xss&#x3D;256k 线程栈大小。</span><br><span class="line">-XX:+PrintGCDetails 显示堆内存信息和GC信息</span><br><span class="line">-XX:+PrintHeapAtGC 当发生 GC 时打印内存布局。</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError 发送内存溢出时 dump 内存。</span><br><span class="line"></span><br><span class="line">新生代和老年代的默认比例为 1:2，也就是说新生代占用 1&#x2F;3的堆内存，而老年代占用 2&#x2F;3 的堆内存。</span><br><span class="line">可以通过参数 -XX:NewRatio&#x3D;2 来设置老年代&#x2F;新生代的比例。</span><br></pre></td></tr></table></figure>

<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>符合大多数成熟运营的实际情况的经验法则。<br>将Java堆划分成不同的区域，根据回收对象的年龄（经历的垃圾回收次数）分配到不同区域存储。</p>
<p>三大假说：<br>1 弱分代假说：绝大多数对象都是朝生夕灭<br>2 强分代假说：熬过越多次垃圾收集过程的对象就越难以清除<br>3 跨代引用假说：跨代引用相对同代引用来说占极少数</p>
<blockquote>
<p>堆划分成新生代和老年代，分代收集时对象不是孤立的，对象之间存在跨代引用<br>思考：Minor GC时一个新生代中的对象回收时被老年代引用，此时是否需要额外遍历整个老年代？<br>根据第3条假说，具体做法是：在新生代上建立一个全局数据结构（记忆集 Remembered Set），这个结构把老年代划分成若干小块，标志出哪一块存在跨代引用。只遍历这一小块即可</p>
</blockquote>
<p>不同区域的垃圾回收类型：<br>1 Minor GC：新生代收集<br>2 Major GC ：老年代收集。CMS收集器独有<br><strong>3 Mixed GC：混合收集，新生代+部分老年代。G1收集器独有</strong><br>4 Full GC：整堆收集，收集Java堆和方法区（元数据区）</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><h5 id="标记-复制算法：将存活的对象进行复制和移动"><a href="#标记-复制算法：将存活的对象进行复制和移动" class="headerlink" title="标记-复制算法：将存活的对象进行复制和移动"></a>标记-复制算法：将存活的对象进行复制和移动</h5><p>每次Minor GC都会清空Eden区和幸存to区：<br>1 将Eden中存活的对象复制到幸存to区。<br>2 将原本幸存from区中存活的对象复制到幸存to区，并交换幸存from和to区。所以最后幸存to区是空的。<br>优点：没有内存碎片<br>缺点：两个幸存区永远有一个是空的。浪费了一半的空间</p>
<h5 id="标记-清除算法：两次扫描"><a href="#标记-清除算法：两次扫描" class="headerlink" title="标记-清除算法：两次扫描"></a>标记-清除算法：两次扫描</h5><p>第一次扫描全部对象，对存活的对象进行标记。<br>第二次扫描全部对象，对没有标记的对象进行清除<br>优点：不浪费额外的空间<br>缺点：两次扫描，浪费时间。会产生内存碎片</p>
<h5 id="标记-在整理-压缩算法：在标记清除的基础上，防止内存碎片。"><a href="#标记-在整理-压缩算法：在标记清除的基础上，防止内存碎片。" class="headerlink" title="标记-在整理/压缩算法：在标记清除的基础上，防止内存碎片。"></a>标记-在整理/压缩算法：在标记清除的基础上，防止内存碎片。</h5><p>再次扫描全部对象（清除过后的对象），向一端移动存活的对象（移动对象有一定开销）<br>可以在多次标记清除算法后，再执行一次标记压缩，节省开销。<br>缺点：移动存活对象，更新引用要全程暂停程序（STW Stop The World）。<br>其实，标记-清除算法也存在STW，只是停顿的时间很短而已<br>这是为了保证结果的准确性（不然在分析或回收过程中，对象引用关系还在不断变化）</p>
<h5 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h5><p>很少用，与iOS中的引用计数器原理基本相同。实例每建立一个强引用就会给对应的引用计数器加一。其实类似的思想在JUC源码中有很多体现。缺点就是要维护一个引用变量。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>时间复杂度（从低到高）：复制算法 &gt; 标记清除法 &gt; 标记压缩法<br>内存整齐度：复制算法 = 标记压缩法 &gt; 标记清除法<br>内存利用率：标记压缩法 = 标记清除法 &gt; 复制算法</p>
<p><strong><em>复制算法</em></strong> 最佳使用场景：对象存活度较低的区域——新生代</p>
<p><strong><em>标记清除 + 标记压缩</em></strong> 最佳使用场景：对象存活率高，空间大的区域——老年代</p>
<h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/gc_collector.png"></p>
<p>没有<strong>最好的</strong>收集器，更不存在<strong>万能的</strong>收集器，值有<strong>最合适的</strong>收集器</p>
<h5 id="Serial-收集器（新生代收集器）"><a href="#Serial-收集器（新生代收集器）" class="headerlink" title="Serial 收集器（新生代收集器）"></a>Serial 收集器（新生代收集器）</h5><p>一个<strong>单线程工作</strong>的收集器：进行垃圾收集时，必须暂停其他所有工作线程，直至收集结束。<br>特点：简单而高效，没有线程交互的开销。<br>应用：微服务应用中（虚拟机，内存小的场景）</p>
<h5 id="ParNew-收集器（新生代收集器）"><a href="#ParNew-收集器（新生代收集器）" class="headerlink" title="ParNew 收集器（新生代收集器）"></a>ParNew 收集器（新生代收集器）</h5><p>Serial收集器的<strong>多线程并行</strong>版本<br>收集算法、对象分配规则、回收策略等都一样，代码很多共用</p>
<h5 id="CMS-收集器（老年代收集器）"><a href="#CMS-收集器（老年代收集器）" class="headerlink" title="CMS 收集器（老年代收集器）"></a>CMS 收集器（老年代收集器）</h5><p>首次实现了让<strong>垃圾收集线程与用户线程同时工作</strong><br>但是它只能与Serial或者ParNew配合（默认）工作。</p>
<blockquote>
<p>相关命令：<br>-XX:+UseConcMarkSweepGC 启用CMS<br>-XX:+/-UseParNewGC 指定或禁止使用ParNew收集器。<br>-XX:ParallelGCThreads 限制垃圾收集的线程数</p>
</blockquote>
<p><strong>四个步骤：</strong><br>1 初始标记：标记一下GC Roots能直接关联的对象，速度很快<br>2 并发标记：从上面的直连对象开始遍历整个对象图，不需要STW<br>3 重新标记：修正并发标记期间变动的对象，时间也很短<br>4 并发清除：清除被标记死亡的对象，不需移动存活对象，所以不需要STW<br><strong>步骤1和3会STW</strong></p>
<p>缺点：<br>1 对处理器资源非常敏感，处理器核心数不足4个时不建议使用<br>2 无法处理“浮动垃圾”— 因为CMS在并发标记和清除时无需停止用户线程，有可能出现本次收集过程中出现新的垃圾对象。<br>由于浮动垃圾的问题，CMS必须预留一些内存空间（并不是老年代满了才进行垃圾回收）。CMS开始执行是到达68%空间后执行<br>3 基于标记-清除算法会产生大量内存碎片<br>解决：在多次进行标记清除后执行一次标记整理<br>-XX:+UseCMS-CompactAtFullCollection 默认开启，JDK9废除<br>-XX:CMSFullGCsBeforeCompaction 默认0，几次标记清除后执行标记整理，JDK9废除</p>
<h5 id="Parallel-Scavenge-收集器（新生代收集器）"><a href="#Parallel-Scavenge-收集器（新生代收集器）" class="headerlink" title="Parallel Scavenge 收集器（新生代收集器）"></a>Parallel Scavenge 收集器（新生代收集器）</h5><p>与Serial和ParNew一样，都是基于标记-复制算法，也是<strong>多线程并行</strong>的<br>与其他收集器的侧重点不同：其他关注用户线程的停顿时间，而PS侧重于吞吐量=用户代码时间/总消耗时间。<br>自适应调节策略：-XX:+UseAdaptiveSizePolicy。区别于ParNew的一个重要特性</p>
<h5 id="Serial-Old-收集器（老年代收集器）"><a href="#Serial-Old-收集器（老年代收集器）" class="headerlink" title="Serial Old 收集器（老年代收集器）"></a>Serial Old 收集器（老年代收集器）</h5><p>是Serial收集器的老年代版本。一个<strong>单线程</strong>收集器，基于标记-整理</p>
<h5 id="Parallel-Old-收集器（老年代收集器）"><a href="#Parallel-Old-收集器（老年代收集器）" class="headerlink" title="Parallel Old 收集器（老年代收集器）"></a>Parallel Old 收集器（老年代收集器）</h5><p>是Parallel Scavenge 收集器的老年代版本。支持<strong>多线程并发</strong>收集，基于标记-整理</p>
<h5 id="G1-收集器（分区模型）"><a href="#G1-收集器（分区模型）" class="headerlink" title="G1 收集器（分区模型）"></a>G1 收集器（分区模型）</h5><p>JDK9，服务端模式下默认的垃圾收集器，取代PS+PO组合<br>Mixed GC，不区分新生代和老年代，而是把Java堆划分为多个大小相等的独立区域（Region，单次回收的最小单元），看回收哪块内存的收益最大。<br>G1可以根据需要将这些Region扮演成不同的空间，新生代的Eden空间、Survivor空间或者老年代空间和<strong>Humongous空间</strong>，不同的空间采用不同的策略去处理。<br><strong>Humongous空间，专门用来存储大对象（超过一个Region的一半的对象），可以把这个空间理解成老年代的一部分</strong></p>
<p>可预测停顿时间：<br>因为G1将Region作为单次回收的最小单元。每次回收的内存空间都是Region的整数倍。<br>后台维护了一个优先级列表（优先级，回收的空间和耗时计算得出），优先处理回收价值最大的Region</p>
<p>问题：<br>1 跨Region引用对象如何解决？ 解决：记忆集<br>2 并发标记阶段如何保证收集线程和用户线程互不干扰？解决：SATB原始快照<br>3 如何建立起可靠的停顿预测模型？解决：衰减均值</p>
<p>四个步骤：<br>1 初始标记：标记一下GC Roots能直接关联的对象，并修改TAMS指针的值，速度很快<br>2 并发标记：从 GC Root开始对对重的对象进行可达性分析，递归扫描整个对象图<br>3 最终标记：处理并发标记遗留的少量SATB记录<br>4 筛选回收：对各个Region进行优先级排序，<strong>根据用户期望的停顿时间来制定回收计划</strong>，复制部分Region的存活对象到空Region，最后清理Region。必须暂停用户线程。<br><strong>步骤1,3,4都会STW</strong></p>
<p>缺点：<br>垃圾收集时产生的内存占用和运行时额外执行负载都比CMS高</p>
<p>与CMS对比总结：<br>哪款收集器好，要针对具体的场景定量比较。小内存应用上CMS的表现会优于G1。反之G1在大内存应用上可以发挥优势。这个平衡点6-8G。<br>不过就趋势而言，随着G1的不断优化，结果必定会向G1倾斜。</p>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>黑色：自己已经标记，且关联对象都标记完成，垃圾回收器不会再查询该节点<br>灰色：自己标记完成，但关联对象未标记<br>白色：没有遍历到的节点</p>
<p>CMS和G1都是采用三色标记法来标记对象。</p>
<p>通过之前的介绍，已知在CMS和G1收集器中，并发标记阶段时收集线程和用户线程是同时在工作的。与之对应的步骤三种的问题如下：</p>
<h5 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h5><blockquote>
<p>A -&gt; B -&gt; D</p>
</blockquote>
<p>并发标记过程中，标记完D节点后，B-&gt;D的引用消失了，产生浮动垃圾。下次垃圾回收器标记时再处理D垃圾</p>
<h5 id="对象漏标"><a href="#对象漏标" class="headerlink" title="对象漏标"></a>对象漏标</h5><blockquote>
<p>A -&gt; B<br>A -&gt; D</p>
</blockquote>
<p>当A节点被标记为黑色之后，又建立了对D的引用。因为黑色节点不会再被垃圾回收器处理。所以D节点会被垃圾回收器清除</p>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>1 CMS对增加引用环节进行处理（Increment Update）<br>当黑色节点新增引用时，把黑色节点编程灰色，这样下次回收器标及时会扫描它的fields节点（但是在多线程标记时依然会出现漏标。<br>所以，CMS的remark阶段，必须从头扫描一遍，会产生严重的STW</p>
<p>2 G1则对删除引用环节进行处理(SATB 原始快照)</p>
<h4 id="内存分配与回收策略："><a href="#内存分配与回收策略：" class="headerlink" title="内存分配与回收策略："></a>内存分配与回收策略：</h4><p>1 对象优先在Eden分配<br>2 大对象直接进入老年代<br>    -XX:PretenureSizeThreshold=3M 超过3M的对象直接进入老年代<br>3 长期存活的对象将进入老年代<br>    -XX:MaxTenuringThreshold=15 经历多少次Minor GC后进入老年代<br>4 动态对象年龄判定<br>    如果相同年龄的对象大小总和超过幸存区的一般，那么会将他们以及比他们年龄大的对象都移动到老年代。（不一定等到年龄是15）<br>5 空间分配担保<br>    如果在Minor GC时，老年代并没有足够的空间容纳新进的对象，那么在Minor GC后立刻进行一次Full GC。<br>    开启担保 -XX:HandlePromotionFailure=true 后会判断避免这次Full GC，通常会打开担保</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2021/02/09/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/09/java/" class="post-title-link" itemprop="url">JVM 类加载器 & 运行时区域</a>
        </h2>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-09 17:17:55" itemprop="dateCreated datePublished" datetime="2021-02-09T17:17:55+08:00">2021-02-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-18 15:05:37" itemprop="dateModified" datetime="2021-02-18T15:05:37+08:00">2021-02-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Class-Loader-和-双亲委派机制"><a href="#Class-Loader-和-双亲委派机制" class="headerlink" title="Class Loader 和 双亲委派机制"></a>Class Loader 和 双亲委派机制</h4><p>寻找类加载器：</p>
<p>AppClassLoader -&gt; ExtClassLoader -&gt; BootstrapClassLoader(c++中)<br>一直找到最上层的加载器后，检查能否加载当前这个类，如果可以则使用当前加载器。否则，抛出异常向下通知子加载器加载。<br>如果没有加载器可以加载这个类，报异常 <code>ClassNotFoundException</code></p>
<blockquote>
<p>注意：向上寻找加载器的过程中有一个判断这个类是否已经被加载的过程。如果加载过了就不用重复加载（保证数据安全）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student().getClass().getClassLoader();</span><br><span class="line">s.getClass() <span class="comment">// class com.yy.string.ClassLoaderTest</span></span><br><span class="line">s.getClass().getClassLoader() <span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">s.getClass().getClassLoader().getParent() <span class="comment">// sun.misc.Launcher$ExtClassLoader@5ca881b5</span></span><br><span class="line">s.getClass().getClassLoader().getParent().getParent() <span class="comment">// null，在c++中，获取不到</span></span><br></pre></td></tr></table></figure>

<p>双亲委派机制作用：<br>1 防止重复加载同一个class<br>2 保证源码的class文件不被覆盖篡改（例如:定义一个java.lang.String的类，实例化时依然会加载jdk中的String类）</p>
<p><img src="https://yloopdaed-oss.oss-cn-beijing.aliyuncs.com/jvm.jpg"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/02/09/java/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yloopdaed</span>
  
  <a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">沪ICP备2020029595号-1</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
