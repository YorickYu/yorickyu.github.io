<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yloopdaed.icu","root":"/","images":"/images","scheme":"Pisces","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Hash冲突因为ThreadLocalMap中的数据其实是存在Entry[]数组中的，一个纯数组的结构能存储值的数量是非常有限的，几遍在Hash算法中使用了黄金分割，但是不可避免的还是会产生Hash冲突。当插入Entry[]数组时发生Hash冲突时，会进入for循环 12345678910111213141516171819for (Entry e &#x3D; tab[i];     e !&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="尝试阅读ThreadLocal源码-Hash冲突、启动&#x2F;探测式清理、扩容">
<meta property="og:url" content="http://yloopdaed.icu/2020/12/13/threadlocal2/index.html">
<meta property="og:site_name" content="yloopdaed">
<meta property="og:description" content="Hash冲突因为ThreadLocalMap中的数据其实是存在Entry[]数组中的，一个纯数组的结构能存储值的数量是非常有限的，几遍在Hash算法中使用了黄金分割，但是不可避免的还是会产生Hash冲突。当插入Entry[]数组时发生Hash冲突时，会进入for循环 12345678910111213141516171819for (Entry e &#x3D; tab[i];     e !&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-13T14:20:41.000Z">
<meta property="article:modified_time" content="2020-12-15T06:47:21.231Z">
<meta property="article:author" content="yloopdaed">
<meta property="article:tag" content="Hash冲突">
<meta property="article:tag" content="数组扩容">
<meta property="article:tag" content="启动式清理">
<meta property="article:tag" content="探测式清理">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yloopdaed.icu/2020/12/13/threadlocal2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>尝试阅读ThreadLocal源码-Hash冲突、启动/探测式清理、扩容 | yloopdaed</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">yloopdaed</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">YYYYYY iOS to Java. DON'T BE WILD</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-xmind">

    <a href="/xmind/" rel="section"><i class="fa fa-tags fa-fw"></i>导图</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash%E5%86%B2%E7%AA%81"><span class="nav-number">1.</span> <span class="nav-text">Hash冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#replaceStaleEntry"><span class="nav-number">2.</span> <span class="nav-text">replaceStaleEntry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yloopdaed"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">yloopdaed</p>
  <div class="site-description" itemprop="description">可能是个非典型程序员吧 ^ ^</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YorickYu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YorickYu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yykeepbreak@gmail.com" title="E-Mail → mailto:yykeepbreak@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/9901b7042663" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9901b7042663" rel="noopener" target="_blank">简书</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/14337507/yloopdaed" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;14337507&#x2F;yloopdaed" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/YorickYu/JPP" title="https:&#x2F;&#x2F;github.com&#x2F;YorickYu&#x2F;JPP" rel="noopener" target="_blank">JPP</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/YorickYu/YYTODOLIST" title="https:&#x2F;&#x2F;github.com&#x2F;YorickYu&#x2F;YYTODOLIST" rel="noopener" target="_blank">TODOLIST</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://github.com/YorickYu/IHAVEAQUESTION" title="https:&#x2F;&#x2F;github.com&#x2F;YorickYu&#x2F;IHAVEAQUESTION" rel="noopener" target="_blank">IHAVEAQUESTION</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://azh.ink/" title="http:&#x2F;&#x2F;azh.ink" rel="noopener" target="_blank">azh</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://lan.yitian.online/blog" title="http:&#x2F;&#x2F;lan.yitian.online&#x2F;blog" rel="noopener" target="_blank">lan</a>
        </li>
    </ul>
  </div>

        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yloopdaed.icu/2020/12/13/threadlocal2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="yloopdaed">
      <meta itemprop="description" content="可能是个非典型程序员吧 ^ ^">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yloopdaed">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          尝试阅读ThreadLocal源码-Hash冲突、启动/探测式清理、扩容
        </h1>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-13 22:20:41" itemprop="dateCreated datePublished" datetime="2020-12-13T22:20:41+08:00">2020-12-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-15 14:47:21" itemprop="dateModified" datetime="2020-12-15T14:47:21+08:00">2020-12-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h4 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h4><p>因为ThreadLocalMap中的数据其实是存在Entry[]数组中的，一个纯数组的结构能存储值的数量是非常有限的，几遍在Hash算法中使用了黄金分割，但是不可避免的还是会产生Hash冲突。<br>当插入Entry[]数组时发生Hash冲突时，会进入for循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for (Entry e &#x3D; tab[i]; </span><br><span class="line">    e !&#x3D; null;</span><br><span class="line">    e &#x3D; tab[i &#x3D; nextIndex(i, len)]) &#123;  &#x2F;&#x2F; Hash冲突</span><br><span class="line">    ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">    if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">        e.value &#x3D; value;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (k &#x3D;&#x3D; null) &#123;</span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int nextIndex(int i, int len) &#123;</span><br><span class="line">    return ((i + 1 &lt; len) ? i + 1 : 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如当前ThreadLocal计算出的下标是5，tab[5]对应的Entry不为null，则说明产生了Hash冲突。<br>进入for循环：<br>1 判断这个Entry的key是否等于传入的ThreadLocal，如果相等，替换并返回<br>2 判断这个Entry的key是否为null（说明key已经过期），开始探测式清理<br>3 循环过程中，数组下标通过 <code>nextIndex(i, len)]</code> 累加，如果发现新下标对应数组位置为空，那么会插入在新的位置</p>
<a id="more"></a>

<h4 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a>replaceStaleEntry</h4><p>ThreadLocalMap中的set方法，在key值计算的数组下标处元素不为null，且循环过程中遇到key已经过期的元素时会进入这个方法。</p>
<p>这里涉及到了探测式清除<br>总之最后方法执行的结果是，清除了过期的Entry元素，并且通过多次for循环和hash计算，让之前发生过Hash冲突的元素更靠近正确的位置。达到优化查询效率的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</span><br><span class="line">                               int staleSlot) &#123;</span><br><span class="line">    Entry[] tab &#x3D; table;</span><br><span class="line">    int len &#x3D; tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Back up to check for prior stale entry in current run.</span><br><span class="line">    &#x2F;&#x2F; We clean out whole runs at a time to avoid continual</span><br><span class="line">    &#x2F;&#x2F; incremental rehashing due to garbage collector freeing</span><br><span class="line">    &#x2F;&#x2F; up refs in bunches (i.e., whenever the collector runs).</span><br><span class="line">    int slotToExpunge &#x3D; staleSlot;</span><br><span class="line">    for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; prevIndex(i, len))</span><br><span class="line">        if (e.get() &#x3D;&#x3D; null)</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find either the key or trailing null slot of run, whichever</span><br><span class="line">    &#x2F;&#x2F; occurs first</span><br><span class="line">    for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">         (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">         i &#x3D; nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we find key, then we need to swap it</span><br><span class="line">        &#x2F;&#x2F; with the stale entry to maintain hash table order.</span><br><span class="line">        &#x2F;&#x2F; The newly stale slot, or any other stale slot</span><br><span class="line">        &#x2F;&#x2F; encountered above it, can then be sent to expungeStaleEntry</span><br><span class="line">        &#x2F;&#x2F; to remove or rehash all of the other entries in run.</span><br><span class="line">        if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line"></span><br><span class="line">            tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">            tab[staleSlot] &#x3D; e;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Start expunge at preceding stale entry if it exists</span><br><span class="line">            if (slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">                slotToExpunge &#x3D; i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If we didn&#39;t find stale entry on backward scan, the</span><br><span class="line">        &#x2F;&#x2F; first stale entry seen while scanning for key is the</span><br><span class="line">        &#x2F;&#x2F; first still present in the run.</span><br><span class="line">        if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If key not found, put new entry in stale slot</span><br><span class="line">    tab[staleSlot].value &#x3D; null;</span><br><span class="line">    tab[staleSlot] &#x3D; new Entry(key, value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If there are any other stale entries in run, expunge them</span><br><span class="line">    if (slotToExpunge !&#x3D; staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要明确，方法传入的参数有3个：<br>1 当前线程中创建的一个ThreadLocal对象<br>2 需要存入的value值<br>3 在ThreadLocalMap的set方法中发生Hash冲突时，遍历找到的一个过期的Entry的下标<br><strong>这个下标处的Entry是一个过期的Entry</strong></p>
<p>我们逐行理解一下源码：<br>1 将传入的第三个参数（过期Entry的下标）记录在 <code>slotToExpunge</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int slotToExpunge &#x3D; staleSlot;</span><br></pre></td></tr></table></figure>

<p>2 第一个for循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; prevIndex(staleSlot, len);</span><br><span class="line">    (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">    i &#x3D; prevIndex(i, len)) &#x2F;&#x2F; 循环往前</span><br><span class="line">    if (e.get() &#x3D;&#x3D; null)</span><br><span class="line">        slotToExpunge &#x3D; i;</span><br><span class="line"></span><br><span class="line">private static int prevIndex(int i, int len) &#123;</span><br><span class="line">    return ((i - 1 &gt;&#x3D; 0) ? i - 1 : len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.1 从传入的下标位置，<strong>循环往前</strong> 遍历数组，直到发现Entry为null停止。<br>2.2 在遍历的过程中，如果发现key为null的过期元素，更新 <code>slotToExpunge</code> 的值。<br>2.3 for循环中数组下标的计算是 <code>prevIndex(i, len)</code> 方法，可以看出，如果向前遍历到下标为0时，会更新下标为 <code>len-1</code> 继续循环。停止的唯一条件是找到 <code>Entry==null</code> 才停止。</p>
<p>3 第二个for循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; nextIndex(staleSlot, len);</span><br><span class="line">        (e &#x3D; tab[i]) !&#x3D; null;</span><br><span class="line">        i &#x3D; nextIndex(i, len)) &#123; &#x2F;&#x2F; 循环往后</span><br><span class="line">    ThreadLocal&lt;?&gt; k &#x3D; e.get();</span><br><span class="line"></span><br><span class="line">    if (k &#x3D;&#x3D; key) &#123;</span><br><span class="line">        e.value &#x3D; value;</span><br><span class="line"></span><br><span class="line">        tab[i] &#x3D; tab[staleSlot];</span><br><span class="line">        tab[staleSlot] &#x3D; e;</span><br><span class="line"></span><br><span class="line">        if (slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">            slotToExpunge &#x3D; i;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (k &#x3D;&#x3D; null &amp;&amp; slotToExpunge &#x3D;&#x3D; staleSlot)</span><br><span class="line">        slotToExpunge &#x3D; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.1 从传入的下标位置，<strong>循环往后</strong> 遍历数组，直到发现 <code>Entry==null</code> 或者 找到一个Entry的key与传入参数的ThreadLocal相同时停止。<br>3.2 如果向后遍历时发现了一个key相同的Entry，那么会先更新这个Entry的value，然后把这个Entry与此次发生Hash冲突的Entry进行交换。<br>3.3 交换完成后开始过期Entry的清理工作，清理从 <code>slotToExpunge</code> 下标开始。<br>如果 <code>slotToExpunge == staleSlot</code>，这说明在之前的两个for循环中都未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的index，即 <code>slotToExpunge = i</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">&gt; 这个方法后面详细讲</span><br><span class="line">3.4 如果循环过程中没有找到相同key的Entry，会判断这个Entry是否已经过期（即 &#96;k&#x3D;&#x3D;null&#96;），如果过期了，且在上面第一个for循环中没有更新过 &#96;slotToExpunge&#96;。那么会更新 &#96;slotToExpunge&#96; 的值。</span><br><span class="line"></span><br><span class="line">4 代码执行到这里，说明在数组中没有找到key相同的Entry。</span><br><span class="line">那么就创建一个新的Entry，替换table[stableSlot]的过期Entry。</span><br><span class="line"></span><br><span class="line">5 最后，通过判断 &#96;slotToExpunge !&#x3D; staleSlot&#96; 可以得知除了 staleSlot 这个传入的下标以外，是否还有其他的过期Entry在数组中。如果有，则执行清理操作</span><br><span class="line">**清理分为两种：&#96;探测式清理&#96; 和 &#96;启发式清理&#96;**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 探测式清除</span><br><span class="line">从开始位置 **循环向后** 探测清理过期数据</span><br></pre></td></tr></table></figure>
<p>private int expungeStaleEntry(int staleSlot) {<br>    Entry[] tab = table;<br>    int len = tab.length;</p>
<pre><code>// expunge entry at staleSlot
tab[staleSlot].value = null;
tab[staleSlot] = null;
size--;

// Rehash until we encounter null
Entry e;
int i;
for (i = nextIndex(staleSlot, len);
     (e = tab[i]) != null;
     i = nextIndex(i, len)) &#123;
    ThreadLocal&lt;?&gt; k = e.get();
    if (k == null) &#123;
        e.value = null;
        tab[i] = null;
        size--;
    &#125; else &#123;
        int h = k.threadLocalHashCode &amp; (len - 1);
        if (h != i) &#123;
            tab[i] = null;

            // Unlike Knuth 6.4 Algorithm R, we must scan until
            // null because multiple entries could have been stale.
            while (tab[h] != null)
                h = nextIndex(h, len);
            tab[h] = e;
        &#125;
    &#125;
&#125;
return i;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过程：</span><br><span class="line">1 因为调用方法时传入的 &#96;slotToExpunge&#96; 就是记录过期元素下标位置的，所以进入方法用 &#96;staleSlot&#96; 接收这个参数，并直接将对应位置的Entry置空。</span><br></pre></td></tr></table></figure>
<p>tab[staleSlot].value = null;<br>tab[staleSlot] = null;<br>size–;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2 接下去 **循环向后** 遍历每一个Entry，遇到 &#96;key&#x3D;&#x3D;null&#96; 就置空。如果不为空就 &#96;rehash&#96; 获取新的数组下标，由于Entry对象插入数组的过程是向后循环找空位，所以rehash的下标肯定在当前下标之前。</span><br><span class="line">2.1 从新下标的位置，向后遍历，如果找到空位就插入</span><br><span class="line">2.2 如果找不到空位，最坏情况就是插入到原本的位置</span><br><span class="line"></span><br><span class="line">3 这个方法最后会返回一个数组下标，这个下标位置的 &#96;Entry&#96; 为 &#96;null&#96;。**可以理解为，数组中从入参 &#96;slateSlot&#96; 到出参 &#96;i&#96; 这个区间内的元素都完成了清理和重定位**。</span><br><span class="line"></span><br><span class="line">**探测式清理结束后，数组中过期的元素应该会被 ~~全部清理~~ 部分清除，而且之前发生 &#96;Hash冲突&#96; 的Entry元素的位置应该更接近真实hash出来的位置。提升了查找的效率**</span><br><span class="line"></span><br><span class="line">&gt; 这里探测式清理并不能全部清除数组中的过期元素，而是从传入的下标清理到第一个 &#96;Entry&#x3D;&#x3D;null&#96; 为止。部分清除。</span><br><span class="line">&gt; 其余的部分，需要通过 **启发式清理**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 启发式清除</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private boolean cleanSomeSlots(int i, int n) {<br>    boolean removed = false;<br>    Entry[] tab = table;<br>    int len = tab.length;<br>    do {<br>        i = nextIndex(i, len);<br>        Entry e = tab[i];<br>        if (e != null &amp;&amp; e.get() == null) {<br>            n = len;<br>            removed = true;<br>            i = expungeStaleEntry(i);<br>        }<br>    } while ( (n &gt;&gt;&gt;= 1) != 0);<br>    return removed;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">启发式清理需要接收两个参数：</span><br><span class="line">1 探测式清理后返回的数字下标，这里至少保证了Hash冲突的下标至探测式清理后返回的下标这个区间无过期的Entry。</span><br><span class="line">2 数组总长度</span><br><span class="line"></span><br><span class="line">根据源码可以看出，启动式清理会从传入的下标 &#96;i&#96; 处，向后遍历。</span><br><span class="line">如果发现过期的Entry则再次触发探测式清理，并重置 &#96;n&#96;。这个n是用来控制 &#96;do while&#96; 循环的跳出条件。</span><br><span class="line">如果遍历过程中，连续 &#96;m&#96; 次没有发现过期的Entry，就可以认为数组中已经没有过期Entry了。</span><br><span class="line">这个 &#96;m&#96; 的计算是 &#96;n &gt;&gt;&gt;&#x3D; 1&#96; ，你也可以理解成是数组长度的2的几次幂。</span><br><span class="line"></span><br><span class="line">&gt; 例如：数组长度是16，那么2^4^&#x3D;16，也就是连续4次没有过期Entry</span><br><span class="line"></span><br><span class="line">#### 扩容</span><br><span class="line"></span><br><span class="line">在 ThreadLocalMap 的 &#96;set&#96; 方法最后，执行完 &#96;cleanSomeSlots(i, sz)&#96; 启动式清理后，如果没有发现过期元素，那么说明此时数组长度进行了 &#96;size++&#96;。需要判断是否需要进行数组扩容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**Entry[] 数组的扩容阈值是 &#96;len * 2 &#x2F; 3&#96;，数组长度的三分之二。**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private void rehash() {<br>    expungeStaleEntries();</p>
<pre><code>if (size &gt;= threshold - threshold / 4)
    resize();</code></pre>
<p>}</p>
<p>private void expungeStaleEntries() {<br>    Entry[] tab = table;<br>    int len = tab.length;<br>    for (int j = 0; j &lt; len; j++) {<br>        Entry e = tab[j];<br>        if (e != null &amp;&amp; e.get() == null)<br>            expungeStaleEntry(j);<br>    }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过上面的代码可以发现，数组扩容之前会进行一次 **全面的清理**，直接用 &#96;fori&#96; 全部遍历数组中的每一个元素，如果发现过期的Entry就进行探测式清理。</span><br><span class="line"></span><br><span class="line">全面清理结束之后，会进一步判断数组的长度是否满足 &#96;size &gt;&#x3D; threshold - threshold &#x2F; 4&#96;，也就是说，扩容前真正的阈值判断是 &#96;len * 2&#x2F;3 * 3&#x2F;4&#96;，也就是阈值真正的值是 **数组长度的1&#x2F;2**。是两个步骤计算出来的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>private void resize() {<br>    Entry[] oldTab = table;<br>    int oldLen = oldTab.length;<br>    int newLen = oldLen * 2;<br>    Entry[] newTab = new Entry[newLen];<br>    int count = 0;</p>
<pre><code>for (int j = 0; j &lt; oldLen; ++j) &#123;
    Entry e = oldTab[j];
    if (e != null) &#123;
        ThreadLocal&lt;?&gt; k = e.get();
        if (k == null) &#123;
            e.value = null; // Help the GC
        &#125; else &#123;
            int h = k.threadLocalHashCode &amp; (newLen - 1);
            while (newTab[h] != null)
                h = nextIndex(h, newLen);
            newTab[h] = e;
            count++;
        &#125;
    &#125;
&#125;

setThreshold(newLen);
size = count;
table = newTab;</code></pre>
<p>}</p>
<p>```<br>每次扩容会将数组长度扩容至原来的2倍，然后遍历老数组，将老数组中的元素重新计算下标，并插入新数组。<br>插入时如果发生Hash冲突，那就向后遍历寻找空位。这个遍历的过程和探测式清理中有点类似。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>阅读过程中发现ThreadLocal的源码远比我想想的要复杂的多得多，关于Hash冲突、数组清理机制、扩容机制的逻辑非常复杂。而且我只是根据源码逐行理解了大概的思路。具体的流程我也没有通过Demo去调试代码。</strong></p>
<p><strong>不过阅读ThreadLocal的源码的收获还是很大的。原来数组这种数据结构还可以通过这种方式解决Hash冲突的问题。</strong></p>
<p><strong>也给实际开发中，处理并发安全问题时提供了多一种解决方案。</strong></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Hash%E5%86%B2%E7%AA%81/" rel="tag"># Hash冲突</a>
              <a href="/tags/%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9/" rel="tag"># 数组扩容</a>
              <a href="/tags/%E5%90%AF%E5%8A%A8%E5%BC%8F%E6%B8%85%E7%90%86/" rel="tag"># 启动式清理</a>
              <a href="/tags/%E6%8E%A2%E6%B5%8B%E5%BC%8F%E6%B8%85%E7%90%86/" rel="tag"># 探测式清理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/12/12/java-boxing-unboxing/" rel="prev" title="自动装箱和拆箱的发生场景">
                  <i class="fa fa-chevron-left"></i> 自动装箱和拆箱的发生场景
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yloopdaed</span>
  
  <a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/">沪ICP备2020029595号-1</a>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
